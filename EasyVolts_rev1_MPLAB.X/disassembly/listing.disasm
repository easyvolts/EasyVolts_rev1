Disassembly Listing for EasyPowerUSB
Generated From:
C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/dist/default/debug/EasyPowerUSB.X.debug.elf
27.05.2017 14:58:58

---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/usb/usb_events.c  -----------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #include "system.h"
22:            
23:            #include "app_uart_usb_utils.h"
24:            
25:            #include "usb.h"
26:            #include "usb_device.h"
27:            #include "usb_device_cdc.h"
28:            
29:            extern void main_CDC_to_RS485_Initialize(void);
30:            extern void main_Communication_Initialize(void);
31:            
32:            /*******************************************************************
33:             * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
34:             *                        USB_EVENT event, void *pdata, uint16_t size)
35:             *
36:             * PreCondition:    None
37:             *
38:             * Input:           USB_EVENT event - the type of event
39:             *                  void *pdata - pointer to the event data
40:             *                  uint16_t size - size of the event data
41:             *
42:             * Output:          None
43:             *
44:             * Side Effects:    None
45:             *
46:             * Overview:        This function is called from the USB stack to
47:             *                  notify a user application that a USB event
48:             *                  occured.  This callback is in interrupt context
49:             *                  when the USB_INTERRUPT option is selected.
50:             *
51:             * Note:            None
52:             *******************************************************************/
53:            bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
54:            {
55:                switch( (int) event )
1481  2C94     GOTO 0x494
1494  0021     MOVLB 0x1
1495  0867     MOVF 0xE7, W
1496  3A00     XORLW 0x0
1497  1903     BTFSC 0x83, 0x2
1498  2C9D     GOTO 0x49D
1499  3A7F     XORLW 0x7F
149A  1903     BTFSC 0x83, 0x2
149B  2CB7     GOTO 0x4B7
149C  2CBC     GOTO 0x4BC
149D  0866     MOVF buffer, W
149E  3A01     XORLW 0x1
149F  1903     BTFSC 0x83, 0x2
14A0  2C82     GOTO 0x482
14A1  3A03     XORLW 0x3
14A2  1903     BTFSC 0x83, 0x2
14A3  2CBC     GOTO 0x4BC
14A4  3A01     XORLW 0x1
14A5  1903     BTFSC 0x83, 0x2
14A6  2C8E     GOTO 0x48E
14A7  3A06     XORLW 0x6
14A8  1903     BTFSC 0x83, 0x2
14A9  2CBC     GOTO 0x4BC
14AA  3A77     XORLW 0x77
14AB  1903     BTFSC 0x83, 0x2
14AC  2CBC     GOTO 0x4BC
14AD  3A01     XORLW 0x1
14AE  1903     BTFSC 0x83, 0x2
14AF  2CBC     GOTO 0x4BC
14B0  3A07     XORLW 0x7
14B1  1903     BTFSC 0x83, 0x2
14B2  2CBC     GOTO 0x4BC
14B3  3A01     XORLW 0x1
14B4  1903     BTFSC 0x83, 0x2
14B5  2CBC     GOTO 0x4BC
14B6  2CBC     GOTO 0x4BC
14B7  0866     MOVF buffer, W
14B8  3AFF     XORLW 0xFF
14B9  1903     BTFSC 0x83, 0x2
14BA  2CBC     GOTO 0x4BC
14BB  2CBC     GOTO 0x4BC
56:                {
57:                    case EVENT_TRANSFER:
58:                        break;
59:            
60:                    case EVENT_SOF:
61:                        /* We are using the SOF as a timer to time the LED indicator.  Call
62:                         * the LED update function here. */
63:            //            APP_LEDUpdateUSBStatus();
64:                        break;
65:            
66:                    case EVENT_SUSPEND:
67:                        /* Update the LED status for the suspend event. */
68:            //            APP_LEDUpdateUSBStatus();
69:            
70:                        //Call the hardware platform specific handler for suspend events for
71:                        //possible further action (like optionally going reconfiguring the application
72:                        //for lower power states and going to sleep during the suspend event).  This
73:                        //would normally be done in USB compliant bus powered applications, although
74:                        //no further processing is needed for purely self powered applications that
75:                        //don't consume power from the host.
76:            //            SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND);
77:                        break;
78:            
79:                    case EVENT_RESUME:
80:                        /* Update the LED status for the resume event. */
81:            //            APP_LEDUpdateUSBStatus();
82:            
83:                        //Call the hardware platform specific resume from suspend handler (ex: to
84:                        //restore I/O pins to higher power states if they were changed during the 
85:                        //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
86:                        //of the suspend condition.
87:            //            SYSTEM_Initialize(SYSTEM_STATE_USB_RESUME);
88:                        break;
89:            
90:                    case EVENT_CONFIGURED:
91:                        /* When the device is configured, we can (re)initialize the 
92:                         * demo code. */
93:                        CDCInitEP();
1482  3194     MOVLP 0x14
1483  240B     CALL 0x40B
1484  3194     MOVLP 0x14
94:                        CDCInitEP2();
1485  3194     MOVLP 0x14
1486  2446     CALL 0x446
1487  3194     MOVLP 0x14
95:            //            APP_DeviceCDCBasicDemoInitialize();
96:                        main_CDC_to_RS485_Initialize();
1488  3193     MOVLP 0x13
1489  237F     CALL 0x37F
148A  3194     MOVLP 0x14
97:                        main_Communication_Initialize();
148B  3193     MOVLP 0x13
148C  2336     CALL 0x336
98:                        break;
99:            
100:                   case EVENT_SET_DESCRIPTOR:
101:                       break;
148D  0008     RETURN
102:           
103:                   case EVENT_EP0_REQUEST:
104:                       /* We have received a non-standard USB request.  The HID driver
105:                        * needs to check to see if the request was for it. */
106:                       USBCheckCDCRequest();
148E  3197     MOVLP 0x17
148F  27A1     CALL 0x7A1
1490  3194     MOVLP 0x14
107:                       USBCheckCDCRequest2();
1491  3188     MOVLP 0x8
1492  200C     CALL 0xC
108:                       break;
109:           
110:                   case EVENT_BUS_ERROR:
111:                       break;
112:           
113:                   case EVENT_TRANSFER_TERMINATED:
114:                       break;
115:           
116:                   default:
117:                       break;
118:               }
1493  0008     RETURN
119:               return true;
120:           }
14BC  0008     RETURN
121:           
122:           /*******************************************************************************
123:            End of File
124:           */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/usb/core/usb_device_cdc2.c  -------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /********************************************************************
23:             Change History:
24:              Rev    Description
25:              ----   -----------
26:              2.3    Deprecated the mUSBUSARTIsTxTrfReady() macro.  It is 
27:                     replaced by the USBUSARTIsTxTrfReady() function.
28:            
29:              2.6    Minor definition changes
30:            
31:              2.6a   No Changes
32:            
33:              2.7    Fixed error in the part support list of the variables section
34:                     where the address of the CDC variables are defined.  The 
35:                     PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
36:                     was incorrectly named PIC18F4458.
37:            
38:                     http://www.microchip.com/forums/fb.aspx?m=487397
39:            
40:              2.8    Minor change to CDCInitEP() to enhance ruggedness in
41:                     multi0-threaded usage scenarios.
42:              
43:              2.9b   Updated to implement optional support for DTS reporting.
44:            
45:            ********************************************************************/
46:            
47:            /** I N C L U D E S **********************************************************/
48:            #include "system.h"
49:            #include "usb.h"
50:            #include "usb_device_cdc.h"
51:            
52:            #ifdef USB_USE_CDC
53:            
54:            #ifndef FIXED_ADDRESS_MEMORY
55:                #define IN_DATA_BUFFER_ADDRESS_TAG
56:                #define OUT_DATA_BUFFER_ADDRESS_TAG
57:                #define CONTROL_BUFFER_ADDRESS_TAG
58:            #endif
59:            
60:            #if !defined(IN_DATA_BUFFER_ADDRESS_TAG) || !defined(OUT_DATA_BUFFER_ADDRESS_TAG) || !defined(CONTROL_BUFFER_ADDRESS_TAG)
61:                #error "One of the fixed memory address definitions is not defined.  Please define the required address tags for the required buffers."
62:            #endif
63:            
64:            /** V A R I A B L E S ********************************************************/
65:            volatile unsigned char cdc_data_tx2[CDC_DATA_IN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;
66:            volatile unsigned char cdc_data_rx2[CDC_DATA_OUT_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;
67:            
68:            typedef union
69:            {
70:                LINE_CODING lineCoding2;
71:                CDC_NOTICE cdcNotice2;
72:            } CONTROL_BUFFER;
73:            
74:            //static CONTROL_BUFFER controlBuffer CONTROL_BUFFER_ADDRESS_TAG;
75:            
76:            LINE_CODING line_coding2;    // Buffer to store line coding information
77:            CDC_NOTICE cdc_notice2;
78:            
79:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
80:                SERIAL_STATE_NOTIFICATION SerialStatePacket2;
81:            #endif
82:            
83:            uint8_t cdc_rx_len2;            // total rx length
84:            uint8_t cdc_trf_state2;         // States are defined cdc.h
85:            POINTER pCDCSrc2;            // Dedicated source pointer
86:            POINTER pCDCDst2;            // Dedicated destination pointer
87:            uint8_t cdc_tx_len2;            // total tx length
88:            uint8_t cdc_mem_type2;          // _ROM, _RAM
89:            
90:            USB_HANDLE CDCDataOutHandle2;
91:            USB_HANDLE CDCDataInHandle2;
92:            
93:            
94:            CONTROL_SIGNAL_BITMAP control_signal_bitmap2;
95:            uint32_t BaudRateGen2;			// BRG value calculated from baud rate
96:            
97:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
98:                BM_SERIAL_STATE SerialStateBitmap2;
99:                BM_SERIAL_STATE OldSerialStateBitmap2;
100:               USB_HANDLE CDCNotificationInHandle2;
101:           #endif
102:           
103:           /**************************************************************************
104:             SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
105:             requests according to the CDC specification.
106:             However, it is not really being used here, therefore a dummy buffer is
107:             used for conformance.
108:            **************************************************************************/
109:           #define dummy_length    0x08
110:           uint8_t dummy_encapsulated_cmd_response2[dummy_length];
111:           
112:           #if defined(USB_CDC_SET_LINE_CODING_HANDLER2)
113:           CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER2(CTRL_TRF_PARAMS);
114:           #endif
115:           
116:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
117:           void USBCDCSetLineCoding2(void);
118:           
119:           /** D E C L A R A T I O N S **************************************************/
120:           //#pragma code
121:           
122:           /** C L A S S  S P E C I F I C  R E Q ****************************************/
123:           /******************************************************************************
124:            	Function:
125:            		void USBCheckCDCRequest(void)
126:            
127:            	Description:
128:            		This routine checks the most recently received SETUP data packet to 
129:            		see if the request is specific to the CDC class.  If the request was
130:            		a CDC specific request, this function will take care of handling the
131:            		request and responding appropriately.
132:            		
133:            	PreCondition:
134:            		This function should only be called after a control transfer SETUP
135:            		packet has arrived from the host.
136:           
137:           	Parameters:
138:           		None
139:           		
140:           	Return Values:
141:           		None
142:           		
143:           	Remarks:
144:           		This function does not change status or do anything if the SETUP packet
145:           		did not contain a CDC class specific request.		 
146:             *****************************************************************************/
147:           void USBCheckCDCRequest2(void)
148:           {
149:               /*
150:                * If request recipient is not an interface then return
151:                */
152:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
080C  0021     MOVLB 0x1
080D  0820     MOVF SetupPkt, W
080E  391F     ANDLW 0x1F
080F  3A01     XORLW 0x1
0810  1D03     BTFSS 0x83, 0x2
0811  0008     RETURN
153:           
154:               /*
155:                * If request type is not class-specific then return
156:                */
157:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
0812  0E20     SWAPF SetupPkt, W
0813  0C89     RRF 0x89, F
0814  3903     ANDLW 0x3
0815  3A01     XORLW 0x1
0816  1D03     BTFSS 0x83, 0x2
0817  0008     RETURN
158:           
159:               /*
160:                * Interface ID must match interface numbers associated with
161:                * CDC class, else return
162:                */
163:               if((SetupPkt.bIntfID != CDC_COMM_INTF_ID2)&&
164:                  (SetupPkt.bIntfID != CDC_DATA_INTF_ID2)) return;
0818  3002     MOVLW 0x2
0819  0624     XORWF 0xA4, W
081A  1903     BTFSC 0x83, 0x2
081B  285D     GOTO 0x5D
081C  3003     MOVLW 0x3
081D  0624     XORWF 0xA4, W
081E  1D03     BTFSS 0x83, 0x2
081F  0008     RETURN
0820  285D     GOTO 0x5D
165:               
166:               switch(SetupPkt.bRequest)
085D  0021     MOVLB 0x1
085E  0821     MOVF 0xA1, W
085F  3A00     XORLW 0x0
0860  1903     BTFSC 0x83, 0x2
0861  2821     GOTO 0x21
0862  3A01     XORLW 0x1
0863  1903     BTFSC 0x83, 0x2
0864  282D     GOTO 0x2D
0865  3A21     XORLW 0x21
0866  1903     BTFSC 0x83, 0x2
0867  2834     GOTO 0x34
0868  3A01     XORLW 0x1
0869  1903     BTFSC 0x83, 0x2
086A  2846     GOTO 0x46
086B  3A03     XORLW 0x3
086C  1903     BTFSC 0x83, 0x2
086D  2854     GOTO 0x54
086E  286F     GOTO 0x6F
167:               {
168:                   //****** These commands are required ******//
169:                   case SEND_ENCAPSULATED_COMMAND:
170:                    //send the packet
171:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response2;
0821  30BC     MOVLW 0xBC
0822  0023     MOVLB 0x3
0823  00B1     MOVWF inPipes
0824  3002     MOVLW 0x2
0825  00B2     MOVWF 0x1B2
172:                       inPipes[0].wCount.Val = dummy_length;
0826  3008     MOVLW 0x8
0827  00B4     MOVWF 0x1B4
0828  3000     MOVLW 0x0
0829  00B5     MOVWF 0x1B5
173:                       inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
082A  1433     BSF 0x1B3, 0x0
174:                       inPipes[0].info.bits.busy = 1;
082B  17B3     BSF 0x1B3, 0x7
175:                       break;
082C  0008     RETURN
176:                   case GET_ENCAPSULATED_RESPONSE:
177:                       // Populate dummy_encapsulated_cmd_response first.
178:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response2;
082D  30BC     MOVLW 0xBC
082E  0023     MOVLB 0x3
082F  00B1     MOVWF inPipes
0830  3002     MOVLW 0x2
0831  00B2     MOVWF 0x1B2
179:                       inPipes[0].info.bits.busy = 1;
0832  17B3     BSF 0x1B3, 0x7
180:                       break;
0833  0008     RETURN
181:                   //****** End of required commands ******//
182:           
183:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
184:                   case SET_LINE_CODING:
185:                       outPipes[0].wCount.Val = SetupPkt.wLength;
0834  0021     MOVLB 0x1
0835  0827     MOVF 0xA7, W
0836  0023     MOVLB 0x3
0837  00AE     MOVWF 0x1AE
0838  0021     MOVLB 0x1
0839  0826     MOVF 0xA6, W
083A  0023     MOVLB 0x3
083B  00AD     MOVWF 0x1AD
186:                       outPipes[0].pDst.bRam = (uint8_t*)LINE_CODING_TARGET2;
083C  30AA     MOVLW 0xAA
083D  00F2     MOVWF 0x1F2
083E  0872     MOVF 0x1F2, W
083F  00AA     MOVWF outPipes
187:                       outPipes[0].pFunc = LINE_CODING_PFUNC2;
0840  3045     MOVLW 0x45
0841  00AF     MOVWF 0x1AF
0842  3017     MOVLW 0x17
0843  00B0     MOVWF 0x1B0
188:                       outPipes[0].info.bits.busy = 1;
0844  17AC     BSF 0x1AC, 0x7
189:                       break;
0845  0008     RETURN
190:                       
191:                   case GET_LINE_CODING:
192:                       USBEP0SendRAMPtr(
0846  305E     MOVLW 0x5E
0847  0023     MOVLB 0x3
0848  00B1     MOVWF inPipes
0849  3002     MOVLW 0x2
084A  00B2     MOVWF 0x1B2
084B  3007     MOVLW 0x7
084C  00B4     MOVWF 0x1B4
084D  3000     MOVLW 0x0
084E  00B5     MOVWF 0x1B5
084F  30C1     MOVLW 0xC1
0850  00F2     MOVWF 0x1F2
0851  0872     MOVF 0x1F2, W
0852  00B3     MOVWF 0x1B3
193:                           (uint8_t*)&line_coding2,
194:                           LINE_CODING_LENGTH,
195:                           USB_EP0_INCLUDE_ZERO);
196:                       break;
0853  0008     RETURN
197:           
198:                   case SET_CONTROL_LINE_STATE:
199:                       control_signal_bitmap2._byte = (uint8_t)SetupPkt.wValue;
0854  0021     MOVLB 0x1
0855  0822     MOVF 0xA2, W
0856  00F2     MOVWF 0xF2
0857  0872     MOVF 0xF2, W
0858  0024     MOVLB 0x4
0859  00D6     MOVWF control_signal_bitmap2
200:                       //------------------------------------------------------------------            
201:                       //One way to control the RTS pin is to allow the USB host to decide the value
202:                       //that should be output on the RTS pin.  Although RTS and CTS pin functions
203:                       //are technically intended for UART hardware based flow control, some legacy
204:                       //UART devices use the RTS pin like a "general purpose" output pin 
205:                       //from the PC host.  In this usage model, the RTS pin is not related
206:                       //to flow control for RX/TX.
207:                       //In this scenario, the USB host would want to be able to control the RTS
208:                       //pin, and the below line of code should be uncommented.
209:                       //However, if the intention is to implement true RTS/CTS flow control
210:                       //for the RX/TX pair, then this application firmware should override
211:                       //the USB host's setting for RTS, and instead generate a real RTS signal,
212:                       //based on the amount of remaining buffer space available for the 
213:                       //actual hardware UART of this microcontroller.  In this case, the 
214:                       //below code should be left commented out, but instead RTS should be 
215:                       //controlled in the application firmware responsible for operating the 
216:                       //hardware UART of this microcontroller.
217:                       //---------            
218:                       //CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);  
219:                       //------------------------------------------------------------------            
220:                       
221:                       #if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
222:                           if(control_signal_bitmap2.DTE_PRESENT == 1)
223:                           {
224:                               UART_DTR2 = USB_CDC_DTR_ACTIVE_LEVEL;
225:                           }
226:                           else
227:                           {
228:                               UART_DTR2 = (USB_CDC_DTR_ACTIVE_LEVEL ^ 1);
229:                           }        
230:                       #endif
231:                       inPipes[0].info.bits.busy = 1;
085A  0023     MOVLB 0x3
085B  17B3     BSF 0x1B3, 0x7
232:                       break;
233:                   #endif
234:           
235:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
236:                   case SEND_BREAK:                        // Optional
237:                       inPipes[0].info.bits.busy = 1;
238:           			if (SetupPkt.wValue == 0xFFFF)  //0xFFFF means send break indefinitely until a new SEND_BREAK command is received
239:           			{
240:           				UART_Tx2 = 0;       // Prepare to drive TX low (for break signaling)
241:           				UART_TRISTx2 = 0;   // Make sure TX pin configured as an output
242:           				UART_ENABLE2 = 0;   // Turn off USART (to relinquish TX pin control)
243:           			}
244:           			else if (SetupPkt.wValue == 0x0000) //0x0000 means stop sending indefinite break 
245:           			{
246:               			UART_ENABLE2 = 1;   // turn on USART
247:           				UART_TRISTx2 = 1;   // Make TX pin an input
248:           			}
249:           			else
250:           			{
251:                           //Send break signaling on the pin for (SetupPkt.wValue) milliseconds
252:                           UART_SEND_BREAK2();
253:           			}
254:                       break;
255:                   #endif
256:                   default:
257:                       break;
258:               }//end switch(SetupPkt.bRequest)
085C  0008     RETURN
259:           
260:           }//end USBCheckCDCRequest
086F  0008     RETURN
261:           
262:           /** U S E R  A P I ***********************************************************/
263:           
264:           /**************************************************************************
265:             Function:
266:                   void CDCInitEP(void)
267:               
268:             Summary:
269:               This function initializes the CDC function driver. This function should
270:               be called after the SET_CONFIGURATION command (ex: within the context of
271:               the USBCBInitEP() function).
272:             Description:
273:               This function initializes the CDC function driver. This function sets
274:               the default line coding (baud rate, bit parity, number of data bits,
275:               and format). This function also enables the endpoints and prepares for
276:               the first transfer from the host.
277:               
278:               This function should be called after the SET_CONFIGURATION command.
279:               This is most simply done by calling this function from the
280:               USBCBInitEP() function.
281:               
282:               Typical Usage:
283:               <code>
284:                   void USBCBInitEP(void)
285:                   {
286:                       CDCInitEP();
287:                   }
288:               </code>
289:             Conditions:
290:               None
291:             Remarks:
292:               None                                                                   
293:             **************************************************************************/
294:           void CDCInitEP2(void)
295:           {
296:               //Abstract line coding information
297:               line_coding2.dwDTERate   = 19200;      // baud rate
1446  3000     MOVLW 0x0
1447  0024     MOVLB 0x4
1448  00E1     MOVWF 0x261
1449  3000     MOVLW 0x0
144A  00E0     MOVWF 0x260
144B  304B     MOVLW 0x4B
144C  00DF     MOVWF 0x25F
144D  3000     MOVLW 0x0
144E  00DE     MOVWF line_coding2
298:               line_coding2.bCharFormat = 0x00;             // 1 stop bit
144F  01E2     CLRF 0x262
299:               line_coding2.bParityType = 0x00;             // None
1450  01E3     CLRF 0x263
300:               line_coding2.bDataBits = 0x08;               // 5,6,7,8, or 16
1451  3008     MOVLW 0x8
1452  0021     MOVLB 0x1
1453  00E5     MOVWF byte_to_send
1454  0865     MOVF byte_to_send, W
1455  0024     MOVLB 0x4
1456  00E4     MOVWF 0x264
301:           
302:               cdc_rx_len2 = 0;
1457  0023     MOVLB 0x3
1458  01D4     CLRF cdc_rx_len2
303:               
304:               /*
305:                * Do not have to init Cnt of IN pipes here.
306:                * Reason:  Number of BYTEs to send to the host
307:                *          varies from one transaction to
308:                *          another. Cnt should equal the exact
309:                *          number of BYTEs to transmit for
310:                *          a given IN transaction.
311:                *          This number of BYTEs will only
312:                *          be known right before the data is
313:                *          sent.
314:                */
315:               USBEnableEndpoint(CDC_COMM_EP2,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1459  301A     MOVLW 0x1A
145A  0021     MOVLB 0x1
145B  00E5     MOVWF byte_to_send
145C  0865     MOVF byte_to_send, W
145D  00F9     MOVWF 0xF9
145E  3003     MOVLW 0x3
145F  3193     MOVLP 0x13
1460  2313     CALL 0x313
1461  3194     MOVLP 0x14
316:               USBEnableEndpoint(CDC_DATA_EP2,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1462  301E     MOVLW 0x1E
1463  0021     MOVLB 0x1
1464  00E5     MOVWF byte_to_send
1465  0865     MOVF byte_to_send, W
1466  00F9     MOVWF 0xF9
1467  3004     MOVLW 0x4
1468  3193     MOVLP 0x13
1469  2313     CALL 0x313
146A  3194     MOVLP 0x14
317:           
318:               CDCDataOutHandle2 = USBRxOnePacket(CDC_DATA_EP2,(uint8_t*)&cdc_data_rx2,sizeof(cdc_data_rx2));
146B  01F2     CLRF 0xF2
146C  3020     MOVLW 0x20
146D  00F3     MOVWF 0xF3
146E  3001     MOVLW 0x1
146F  00F4     MOVWF 0xF4
1470  3040     MOVLW 0x40
1471  0021     MOVLB 0x1
1472  00E5     MOVWF byte_to_send
1473  0865     MOVF byte_to_send, W
1474  00F5     MOVWF 0xF5
1475  3004     MOVLW 0x4
1476  318B     MOVLP 0xB
1477  2315     CALL 0x315
1478  0873     MOVF 0xF3, W
1479  0023     MOVLB 0x3
147A  00BD     MOVWF 0x1BD
147B  0872     MOVF 0x1F2, W
147C  00BC     MOVWF CDCDataOutHandle2
319:               CDCDataInHandle2 = NULL;
147D  01B8     CLRF CDCDataInHandle2
147E  01B9     CLRF 0x1B9
320:           
321:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
322:                 	CDCNotificationInHandle2 = NULL;
323:                   mInitDTSPin2();  //Configure DTS as a digital input
324:                 	SerialStateBitmap2.byte = 0x00;
325:                 	OldSerialStateBitmap2.byte = !SerialStateBitmap2.byte;    //To force firmware to send an initial serial state packet to the host.
326:                   //Prepare a SerialState notification element packet (contains info like DSR state)
327:                   SerialStatePacket2.bmRequestType = 0xA1; //Always 0xA1 for this type of packet.
328:                   SerialStatePacket2.bNotification = SERIAL_STATE;
329:                   SerialStatePacket2.wValue = 0x0000;  //Always 0x0000 for this type of packet
330:                   SerialStatePacket2.wIndex = CDC_COMM_INTF_ID;  //Interface number  
331:                   SerialStatePacket2.SerialState.byte = 0x00;
332:                   SerialStatePacket2.Reserved = 0x00;
333:                   SerialStatePacket2.wLength = 0x02;   //Always 2 bytes for this type of packet    
334:                   CDCNotificationHandler2();
335:             	#endif
336:             	
337:             	#if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
338:             	    mInitDTRPin2();
339:             	#endif
340:             	
341:             	#if defined(USB_CDC_SUPPORT_HARDWARE_FLOW_CONTROL)
342:             	    mInitRTSPin2();
343:             	    mInitCTSPin2();
344:             	#endif
345:               
346:               cdc_trf_state2 = CDC_TX_READY;
147F  01D6     CLRF cdc_trf_state2
347:           }//end CDCInitEP
1480  0008     RETURN
348:           
349:           
350:           /**************************************************************************
351:             Function: void CDCNotificationHandler(void)
352:             Summary: Checks for changes in DSR status and reports them to the USB host.
353:             Description: Checks for changes in DSR pin state and reports any changes
354:                          to the USB host. 
355:             Conditions: CDCInitEP() must have been called previously, prior to calling
356:                         CDCNotificationHandler() for the first time.
357:             Remarks:
358:               This function is only implemented and needed when the 
359:               USB_CDC_SUPPORT_DSR_REPORTING option has been enabled.  If the function is
360:               enabled, it should be called periodically to sample the DSR pin and feed
361:               the information to the USB host.  This can be done by calling 
362:               CDCNotificationHandler() by itself, or, by calling CDCTxService() which
363:               also calls CDCNotificationHandler() internally, when appropriate.
364:             **************************************************************************/
365:           #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
366:           void CDCNotificationHandler2(void)
367:           {
368:               //Check the DTS I/O pin and if a state change is detected, notify the 
369:               //USB host by sending a serial state notification element packet.
370:               if(UART_DTS2 == USB_CDC_DSR_ACTIVE_LEVEL) //UART_DTS must be defined to be an I/O pin in the hardware profile to use the DTS feature (ex: "PORTXbits.RXY")
371:               {
372:                   SerialStateBitmap2.bits.DSR = 1;
373:               }  
374:               else
375:               {
376:                   SerialStateBitmap2.bits.DSR = 0;
377:               }        
378:               
379:               //If the state has changed, and the endpoint is available, send a packet to
380:               //notify the hUSB host of the change.
381:               if((SerialStateBitmap2.byte != OldSerialStateBitmap2.byte) && (!USBHandleBusy(CDCNotificationInHandle2)))
382:               {
383:                   //Copy the updated value into the USB packet buffer to send.
384:                   SerialStatePacket2.SerialState.byte = SerialStateBitmap2.byte;
385:                   //We don't need to write to the other bytes in the SerialStatePacket USB
386:                   //buffer, since they don't change and will always be the same as our
387:                   //initialized value.
388:           
389:                   //Send the packet over USB to the host.
390:                   CDCNotificationInHandle2 = USBTransferOnePacket(CDC_COMM_EP2, IN_TO_HOST, (uint8_t*)&SerialStatePacket2, sizeof(SERIAL_STATE_NOTIFICATION));
391:                   
392:                   //Save the old value, so we can detect changes later.
393:                   OldSerialStateBitmap2.byte = SerialStateBitmap2.byte;
394:               }    
395:           }//void CDCNotificationHandler2(void)    
396:           #else
397:               #define CDCNotificationHandler2() {}
398:           #endif
399:           
400:           
401:           /**********************************************************************************
402:             Function:
403:               bool USBCDCEventHandler(USB_EVENT event, void *pdata, uint16_t size)
404:               
405:             Summary:
406:               Handles events from the USB stack, which may have an effect on the CDC 
407:               endpoint(s).
408:           
409:             Description:
410:               Handles events from the USB stack.  This function should be called when 
411:               there is a USB event that needs to be processed by the CDC driver.
412:               
413:             Conditions:
414:               Value of input argument 'len' should be smaller than the maximum
415:               endpoint size responsible for receiving bulk data from USB host for CDC
416:               class. Input argument 'buffer' should point to a buffer area that is
417:               bigger or equal to the size specified by 'len'.
418:             Input:
419:               event - the type of event that occurred
420:               pdata - pointer to the data that caused the event
421:               size - the size of the data that is pointed to by pdata
422:                                                                                              
423:             **********************************************************************************/
424:           bool USBCDCEventHandler2(USB_EVENT event, void *pdata, uint16_t size)
425:           {
426:               switch( (uint16_t)event )
427:               {  
428:                   case EVENT_TRANSFER_TERMINATED:
429:                       if(pdata == CDCDataOutHandle2)
430:                       {
431:                           CDCDataOutHandle2 = USBRxOnePacket(CDC_DATA_EP2,(uint8_t*)&cdc_data_rx2,sizeof(cdc_data_rx2));
432:                       }
433:                       if(pdata == CDCDataInHandle2)
434:                       {
435:                           //flush all of the data in the CDC buffer
436:                           cdc_trf_state2 = CDC_TX_READY;
437:                           cdc_tx_len2 = 0;
438:                       }
439:                       break;
440:                   default:
441:                       return false;
442:               }      
443:               return true;
444:           }
445:           
446:           /**********************************************************************************
447:             Function:
448:                   uint8_t getsUSBUSART(char *buffer, uint8_t len)
449:               
450:             Summary:
451:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
452:               endpoint to a user's specified location. It is a non-blocking function.
453:               It does not wait for data if there is no data available. Instead it
454:               returns '0' to notify the caller that there is no data available.
455:           
456:             Description:
457:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
458:               endpoint to a user's specified location. It is a non-blocking function.
459:               It does not wait for data if there is no data available. Instead it
460:               returns '0' to notify the caller that there is no data available.
461:               
462:               Typical Usage:
463:               <code>
464:                   uint8_t numBytes;
465:                   uint8_t buffer[64]
466:               
467:                   numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
468:                   if(numBytes \> 0)
469:                   {
470:                       //we received numBytes bytes of data and they are copied into
471:                       //  the "buffer" variable.  We can do something with the data
472:                       //  here.
473:                   }
474:               </code>
475:             Conditions:
476:               Value of input argument 'len' should be smaller than the maximum
477:               endpoint size responsible for receiving bulk data from USB host for CDC
478:               class. Input argument 'buffer' should point to a buffer area that is
479:               bigger or equal to the size specified by 'len'.
480:             Input:
481:               buffer -  Pointer to where received BYTEs are to be stored
482:               len -     The number of BYTEs expected.
483:                                                                                              
484:             **********************************************************************************/
485:           uint8_t getsUSBUSART2(uint8_t *buffer, uint8_t len)
486:           {
487:               cdc_rx_len2 = 0;
488:               
489:               if(!USBHandleBusy(CDCDataOutHandle2))
490:               {
491:                   /*
492:                    * Adjust the expected number of BYTEs to equal
493:                    * the actual number of BYTEs received.
494:                    */
495:                   if(len > USBHandleGetLength(CDCDataOutHandle2))
496:                       len = USBHandleGetLength(CDCDataOutHandle2);
497:                   
498:                   /*
499:                    * Copy data from dual-ram buffer to user's buffer
500:                    */
501:                   for(cdc_rx_len2 = 0; cdc_rx_len2 < len; cdc_rx_len2++)
502:                       buffer[cdc_rx_len2] = cdc_data_rx2[cdc_rx_len2];
503:           
504:                   /*
505:                    * Prepare dual-ram buffer for next OUT transaction
506:                    */
507:           
508:                   CDCDataOutHandle2 = USBRxOnePacket(CDC_DATA_EP2,(uint8_t*)&cdc_data_rx2,sizeof(cdc_data_rx2));
509:           
510:               }//end if
511:               
512:               return cdc_rx_len2;
513:               
514:           }//end getsUSBUSART
515:           
516:           /******************************************************************************
517:             Function:
518:           	void putUSBUSART(char *data, uint8_t length)
519:           		
520:             Summary:
521:               putUSBUSART writes an array of data to the USB. Use this version, is
522:               capable of transferring 0x00 (what is typically a NULL character in any of
523:               the string transfer functions).
524:           
525:             Description:
526:               putUSBUSART writes an array of data to the USB. Use this version, is
527:               capable of transferring 0x00 (what is typically a NULL character in any of
528:               the string transfer functions).
529:               
530:               Typical Usage:
531:               <code>
532:                   if(USBUSARTIsTxTrfReady())
533:                   {
534:                       char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
535:                       putUSBUSART(data,5);
536:                   }
537:               </code>
538:               
539:               The transfer mechanism for device-to-host(put) is more flexible than
540:               host-to-device(get). It can handle a string of data larger than the
541:               maximum size of bulk IN endpoint. A state machine is used to transfer a
542:               \long string of data over multiple USB transactions. CDCTxService()
543:               must be called periodically to keep sending blocks of data to the host.
544:           
545:             Conditions:
546:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
547:               transfer is complete and is ready to receive a new block of data. The
548:               string of characters pointed to by 'data' must equal to or smaller than
549:               255 BYTEs.
550:           
551:             Input:
552:               char *data - pointer to a RAM array of data to be transfered to the host
553:               uint8_t length - the number of bytes to be transfered (must be less than 255).
554:           		
555:            *****************************************************************************/
556:           void putUSBUSART2(uint8_t *data, uint8_t  length)
557:           {
558:               /*
559:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
560:                * before calling this function.
561:                * As a safety precaution, this function checks the state one more time
562:                * to make sure it does not override any pending transactions.
563:                *
564:                * Currently it just quits the routine without reporting any errors back
565:                * to the user.
566:                *
567:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
568:                *             before calling this function!
569:                * Example:
570:                * if(USBUSARTIsTxTrfReady())
571:                *     putUSBUSART(pData, Length);
572:                *
573:                * IMPORTANT: Never use the following blocking while loop to wait:
574:                * while(!USBUSARTIsTxTrfReady())
575:                *     putUSBUSART(pData, Length);
576:                *
577:                * The whole firmware framework is written based on cooperative
578:                * multi-tasking and a blocking code is not acceptable.
579:                * Use a state machine instead.
580:                */
581:               USBMaskInterrupts();
582:               if(cdc_trf_state2 == CDC_TX_READY)
583:               {
584:                   mUSBUSARTTxRam2((uint8_t*)data, length);     // See cdc.h
585:               }
586:               USBUnmaskInterrupts();
587:           }//end putUSBUSART
588:           
589:           /******************************************************************************
590:           	Function:
591:           		void putsUSBUSART(char *data)
592:           		
593:             Summary:
594:               putsUSBUSART writes a string of data to the USB including the null
595:               character. Use this version, 'puts', to transfer data from a RAM buffer.
596:           
597:             Description:
598:               putsUSBUSART writes a string of data to the USB including the null
599:               character. Use this version, 'puts', to transfer data from a RAM buffer.
600:               
601:               Typical Usage:
602:               <code>
603:                   if(USBUSARTIsTxTrfReady())
604:                   {
605:                       char data[] = "Hello World";
606:                       putsUSBUSART(data);
607:                   }
608:               </code>
609:               
610:               The transfer mechanism for device-to-host(put) is more flexible than
611:               host-to-device(get). It can handle a string of data larger than the
612:               maximum size of bulk IN endpoint. A state machine is used to transfer a
613:               \long string of data over multiple USB transactions. CDCTxService()
614:               must be called periodically to keep sending blocks of data to the host.
615:           
616:             Conditions:
617:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
618:               transfer is complete and is ready to receive a new block of data. The
619:               string of characters pointed to by 'data' must equal to or smaller than
620:               255 BYTEs.
621:           
622:             Input:
623:               char *data -  null\-terminated string of constant data. If a
624:                                       null character is not found, 255 BYTEs of data
625:                                       will be transferred to the host.
626:           		
627:            *****************************************************************************/
628:            
629:           void putsUSBUSART2(char *data)
630:           {
631:               uint8_t len;
632:               char *pData;
633:           
634:               /*
635:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
636:                * before calling this function.
637:                * As a safety precaution, this function checks the state one more time
638:                * to make sure it does not override any pending transactions.
639:                *
640:                * Currently it just quits the routine without reporting any errors back
641:                * to the user.
642:                *
643:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
644:                *             before calling this function!
645:                * Example:
646:                * if(USBUSARTIsTxTrfReady())
647:                *     putsUSBUSART(pData, Length);
648:                *
649:                * IMPORTANT: Never use the following blocking while loop to wait:
650:                * while(!USBUSARTIsTxTrfReady())
651:                *     putsUSBUSART(pData);
652:                *
653:                * The whole firmware framework is written based on cooperative
654:                * multi-tasking and a blocking code is not acceptable.
655:                * Use a state machine instead.
656:                */
657:               USBMaskInterrupts();
658:               if(cdc_trf_state2 != CDC_TX_READY)
659:               {
660:                   USBUnmaskInterrupts();
661:                   return;
662:               }
663:               
664:               /*
665:                * While loop counts the number of BYTEs to send including the
666:                * null character.
667:                */
668:               len = 0;
669:               pData = data;
670:               do
671:               {
672:                   len++;
673:                   if(len == 255) break;       // Break loop once max len is reached.
674:               }while(*pData++);
675:               
676:               /*
677:                * Second piece of information (length of data to send) is ready.
678:                * Call mUSBUSARTTxRam to setup the transfer.
679:                * The actual transfer process will be handled by CDCTxService(),
680:                * which should be called once per Main Program loop.
681:                */
682:               mUSBUSARTTxRam2((uint8_t*)data, len);     // See cdc.h
683:               USBUnmaskInterrupts();
684:           }//end putsUSBUSART
685:           
686:           /**************************************************************************
687:             Function:
688:                   void putrsUSBUSART(const const char *data)
689:               
690:             Summary:
691:               putrsUSBUSART writes a string of data to the USB including the null
692:               character. Use this version, 'putrs', to transfer data literals and
693:               data located in program memory.
694:           
695:             Description:
696:               putrsUSBUSART writes a string of data to the USB including the null
697:               character. Use this version, 'putrs', to transfer data literals and
698:               data located in program memory.
699:               
700:               Typical Usage:
701:               <code>
702:                   if(USBUSARTIsTxTrfReady())
703:                   {
704:                       putrsUSBUSART("Hello World");
705:                   }
706:               </code>
707:               
708:               The transfer mechanism for device-to-host(put) is more flexible than
709:               host-to-device(get). It can handle a string of data larger than the
710:               maximum size of bulk IN endpoint. A state machine is used to transfer a
711:               \long string of data over multiple USB transactions. CDCTxService()
712:               must be called periodically to keep sending blocks of data to the host.
713:           
714:             Conditions:
715:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
716:               transfer is complete and is ready to receive a new block of data. The
717:               string of characters pointed to by 'data' must equal to or smaller than
718:               255 BYTEs.
719:           
720:             Input:
721:               const const char *data -  null\-terminated string of constant data. If a
722:                                       null character is not found, 255 uint8_ts of data
723:                                       will be transferred to the host.
724:                                                                                      
725:             **************************************************************************/
726:           void putrsUSBUSART2(const const char *data)
727:           {
728:               uint8_t len;
729:               const const char *pData;
730:           
731:               /*
732:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
733:                * before calling this function.
734:                * As a safety precaution, this function checks the state one more time
735:                * to make sure it does not override any pending transactions.
736:                *
737:                * Currently it just quits the routine without reporting any errors back
738:                * to the user.
739:                *
740:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()
741:                *             before calling this function!
742:                * Example:
743:                * if(USBUSARTIsTxTrfReady())
744:                *     putsUSBUSART(pData);
745:                *
746:                * IMPORTANT: Never use the following blocking while loop to wait:
747:                * while(cdc_trf_state != CDC_TX_READY)
748:                *     putsUSBUSART(pData);
749:                *
750:                * The whole firmware framework is written based on cooperative
751:                * multi-tasking and a blocking code is not acceptable.
752:                * Use a state machine instead.
753:                */
754:               USBMaskInterrupts();
755:               if(cdc_trf_state2 != CDC_TX_READY)
756:               {
757:                   USBUnmaskInterrupts();
758:                   return;
759:               }
760:               
761:               /*
762:                * While loop counts the number of BYTEs to send including the
763:                * null character.
764:                */
765:               len = 0;
766:               pData = data;
767:               do
768:               {
769:                   len++;
770:                   if(len == 255) break;       // Break loop once max len is reached.
771:               }while(*pData++);
772:               
773:               /*
774:                * Second piece of information (length of data to send) is ready.
775:                * Call mUSBUSARTTxRom to setup the transfer.
776:                * The actual transfer process will be handled by CDCTxService(),
777:                * which should be called once per Main Program loop.
778:                */
779:           
780:               mUSBUSARTTxRom2((const uint8_t*)data,len); // See cdc.h
781:               USBUnmaskInterrupts();
782:           
783:           }//end putrsUSBUSART
784:           
785:           /************************************************************************
786:             Function:
787:                   void CDCTxService(void)
788:               
789:             Summary:
790:               CDCTxService handles device-to-host transaction(s). This function
791:               should be called once per Main Program loop after the device reaches
792:               the configured state.
793:             Description:
794:               CDCTxService handles device-to-host transaction(s). This function
795:               should be called once per Main Program loop after the device reaches
796:               the configured state (after the CDCIniEP() function has already executed).
797:               This function is needed, in order to advance the internal software state 
798:               machine that takes care of sending multiple transactions worth of IN USB
799:               data to the host, associated with CDC serial data.  Failure to call 
800:               CDCTxService() periodically will prevent data from being sent to the
801:               USB host, over the CDC serial data interface.
802:               
803:               Typical Usage:
804:               <code>
805:               void main(void)
806:               {
807:                   USBDeviceInit();
808:                   while(1)
809:                   {
810:                       USBDeviceTasks();
811:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
812:                          (USBIsDeviceSuspended() == true))
813:                       {
814:                           //Either the device is not configured or we are suspended
815:                           //  so we don't want to do execute any application code
816:                           continue;   //go back to the top of the while loop
817:                       }
818:                       else
819:                       {
820:                           //Keep trying to send data to the PC as required
821:                           CDCTxService();
822:               
823:                           //Run application code.
824:                           UserApplication();
825:                       }
826:                   }
827:               }
828:               </code>
829:             Conditions:
830:               CDCIniEP() function should have already executed/the device should be
831:               in the CONFIGURED_STATE.
832:             Remarks:
833:               None                                                                 
834:             ************************************************************************/
835:            
836:           void CDCTxService2(void)
837:           {
838:               uint8_t byte_to_send;
839:               uint8_t i;
840:               
841:               USBMaskInterrupts();
842:               
843:               CDCNotificationHandler2();
844:               
845:               if(USBHandleBusy(CDCDataInHandle2)) 
846:               {
847:                   USBUnmaskInterrupts();
848:                   return;
849:               }
850:           
851:               /*
852:                * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
853:                * By having this stage, user can always check cdc_trf_state,
854:                * and not having to call mCDCUsartTxIsBusy() directly.
855:                */
856:               if(cdc_trf_state2 == CDC_TX_COMPLETING)
857:                   cdc_trf_state2 = CDC_TX_READY;
858:               
859:               /*
860:                * If CDC_TX_READY state, nothing to do, just return.
861:                */
862:               if(cdc_trf_state2 == CDC_TX_READY)
863:               {
864:                   USBUnmaskInterrupts();
865:                   return;
866:               }
867:               
868:               /*
869:                * If CDC_TX_BUSY_ZLP state, send zero length packet
870:                */
871:               if(cdc_trf_state2 == CDC_TX_BUSY_ZLP)
872:               {
873:                   CDCDataInHandle2 = USBTxOnePacket(CDC_DATA_EP2,NULL,0);
874:                   //CDC_DATA_BD_IN.CNT = 0;
875:                   cdc_trf_state2 = CDC_TX_COMPLETING;
876:               }
877:               else if(cdc_trf_state2 == CDC_TX_BUSY)
878:               {
879:                   /*
880:                    * First, have to figure out how many byte of data to send.
881:                    */
882:               	if(cdc_tx_len2 > sizeof(cdc_data_tx2))
883:               	    byte_to_send = sizeof(cdc_data_tx2);
884:               	else
885:               	    byte_to_send = cdc_tx_len2;
886:           
887:                   /*
888:                    * Subtract the number of bytes just about to be sent from the total.
889:                    */
890:               	cdc_tx_len2 = cdc_tx_len2 - byte_to_send;
891:               	  
892:                   pCDCDst2.bRam = (uint8_t*)&cdc_data_tx2; // Set destination pointer
893:                   
894:                   i = byte_to_send;
895:                   if(cdc_mem_type2 == USB_EP0_ROM)            // Determine type of memory source
896:                   {
897:                       while(i)
898:                       {
899:                           *pCDCDst2.bRam = *pCDCSrc2.bRom;
900:                           pCDCDst2.bRam++;
901:                           pCDCSrc2.bRom++;
902:                           i--;
903:                       }//end while(byte_to_send)
904:                   }
905:                   else
906:                   {
907:                       while(i)
908:                       {
909:                           *pCDCDst2.bRam = *pCDCSrc2.bRam;
910:                           pCDCDst2.bRam++;
911:                           pCDCSrc2.bRam++;
912:                           i--;
913:                       }
914:                   }
915:                   
916:                   /*
917:                    * Lastly, determine if a zero length packet state is necessary.
918:                    * See explanation in USB Specification 2.0: Section 5.8.3
919:                    */
920:                   if(cdc_tx_len2 == 0)
921:                   {
922:                       if(byte_to_send == CDC_DATA_IN_EP_SIZE2)
923:                           cdc_trf_state2 = CDC_TX_BUSY_ZLP;
924:                       else
925:                           cdc_trf_state2 = CDC_TX_COMPLETING;
926:                   }//end if(cdc_tx_len...)
927:                   CDCDataInHandle2 = USBTxOnePacket(CDC_DATA_EP2,(uint8_t*)&cdc_data_tx2,byte_to_send);
928:           
929:               }//end if(cdc_tx_sate == CDC_TX_BUSY)
930:               
931:               USBUnmaskInterrupts();
932:           }//end CDCTxService
933:           
934:           #endif //USB_USE_CDC
935:           
936:           /** EOF cdc.c ****************************************************************/
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/usb/core/usb_device_cdc.c  --------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /********************************************************************
23:             Change History:
24:              Rev    Description
25:              ----   -----------
26:              2.3    Deprecated the mUSBUSARTIsTxTrfReady() macro.  It is 
27:                     replaced by the USBUSARTIsTxTrfReady() function.
28:            
29:              2.6    Minor definition changes
30:            
31:              2.6a   No Changes
32:            
33:              2.7    Fixed error in the part support list of the variables section
34:                     where the address of the CDC variables are defined.  The 
35:                     PIC18F2553 was incorrectly named PIC18F2453 and the PIC18F4558
36:                     was incorrectly named PIC18F4458.
37:            
38:                     http://www.microchip.com/forums/fb.aspx?m=487397
39:            
40:              2.8    Minor change to CDCInitEP() to enhance ruggedness in
41:                     multi0-threaded usage scenarios.
42:              
43:              2.9b   Updated to implement optional support for DTS reporting.
44:            
45:            ********************************************************************/
46:            
47:            /** I N C L U D E S **********************************************************/
48:            #include "system.h"
49:            #include "usb.h"
50:            #include "usb_device_cdc.h"
51:            
52:            #ifdef USB_USE_CDC
53:            
54:            #ifndef FIXED_ADDRESS_MEMORY
55:                #define IN_DATA_BUFFER_ADDRESS_TAG
56:                #define OUT_DATA_BUFFER_ADDRESS_TAG
57:                #define CONTROL_BUFFER_ADDRESS_TAG
58:            #endif
59:            
60:            #if !defined(IN_DATA_BUFFER_ADDRESS_TAG) || !defined(OUT_DATA_BUFFER_ADDRESS_TAG) || !defined(CONTROL_BUFFER_ADDRESS_TAG)
61:                #error "One of the fixed memory address definitions is not defined.  Please define the required address tags for the required buffers."
62:            #endif
63:            
64:            /** V A R I A B L E S ********************************************************/
65:            volatile unsigned char cdc_data_tx[CDC_DATA_IN_EP_SIZE] IN_DATA_BUFFER_ADDRESS_TAG;
66:            volatile unsigned char cdc_data_rx[CDC_DATA_OUT_EP_SIZE] OUT_DATA_BUFFER_ADDRESS_TAG;
67:            
68:            typedef union
69:            {
70:                LINE_CODING lineCoding;
71:                CDC_NOTICE cdcNotice;
72:            } CONTROL_BUFFER;
73:            
74:            //static CONTROL_BUFFER controlBuffer CONTROL_BUFFER_ADDRESS_TAG;
75:            
76:            LINE_CODING line_coding;    // Buffer to store line coding information
77:            CDC_NOTICE cdc_notice;
78:            
79:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
80:                SERIAL_STATE_NOTIFICATION SerialStatePacket;
81:            #endif
82:            
83:            uint8_t cdc_rx_len;            // total rx length
84:            uint8_t cdc_trf_state;         // States are defined cdc.h
85:            POINTER pCDCSrc;            // Dedicated source pointer
86:            POINTER pCDCDst;            // Dedicated destination pointer
87:            uint8_t cdc_tx_len;            // total tx length
88:            uint8_t cdc_mem_type;          // _ROM, _RAM
89:            
90:            USB_HANDLE CDCDataOutHandle;
91:            USB_HANDLE CDCDataInHandle;
92:            
93:            
94:            CONTROL_SIGNAL_BITMAP control_signal_bitmap;
95:            uint32_t BaudRateGen;			// BRG value calculated from baud rate
96:            
97:            #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
98:                BM_SERIAL_STATE SerialStateBitmap;
99:                BM_SERIAL_STATE OldSerialStateBitmap;
100:               USB_HANDLE CDCNotificationInHandle;
101:           #endif
102:           
103:           /**************************************************************************
104:             SEND_ENCAPSULATED_COMMAND and GET_ENCAPSULATED_RESPONSE are required
105:             requests according to the CDC specification.
106:             However, it is not really being used here, therefore a dummy buffer is
107:             used for conformance.
108:            **************************************************************************/
109:           #define dummy_length    0x08
110:           uint8_t dummy_encapsulated_cmd_response[dummy_length];
111:           
112:           #if defined(USB_CDC_SET_LINE_CODING_HANDLER)
113:           CTRL_TRF_RETURN USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);
114:           #endif
115:           
116:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
117:           void USBCDCSetLineCoding(void);
118:           
119:           /** D E C L A R A T I O N S **************************************************/
120:           //#pragma code
121:           
122:           /** C L A S S  S P E C I F I C  R E Q ****************************************/
123:           /******************************************************************************
124:            	Function:
125:            		void USBCheckCDCRequest(void)
126:            
127:            	Description:
128:            		This routine checks the most recently received SETUP data packet to 
129:            		see if the request is specific to the CDC class.  If the request was
130:            		a CDC specific request, this function will take care of handling the
131:            		request and responding appropriately.
132:            		
133:            	PreCondition:
134:            		This function should only be called after a control transfer SETUP
135:            		packet has arrived from the host.
136:           
137:           	Parameters:
138:           		None
139:           		
140:           	Return Values:
141:           		None
142:           		
143:           	Remarks:
144:           		This function does not change status or do anything if the SETUP packet
145:           		did not contain a CDC class specific request.		 
146:             *****************************************************************************/
147:           void USBCheckCDCRequest(void)
148:           {
149:               /*
150:                * If request recipient is not an interface then return
151:                */
152:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
17A1  0021     MOVLB 0x1
17A2  0820     MOVF SetupPkt, W
17A3  391F     ANDLW 0x1F
17A4  3A01     XORLW 0x1
17A5  1D03     BTFSS 0x83, 0x2
17A6  0008     RETURN
153:           
154:               /*
155:                * If request type is not class-specific then return
156:                */
157:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD) return;
17A7  0E20     SWAPF SetupPkt, W
17A8  0C89     RRF 0x89, F
17A9  3903     ANDLW 0x3
17AA  3A01     XORLW 0x1
17AB  1D03     BTFSS 0x83, 0x2
17AC  0008     RETURN
158:           
159:               /*
160:                * Interface ID must match interface numbers associated with
161:                * CDC class, else return
162:                */
163:               if((SetupPkt.bIntfID != CDC_COMM_INTF_ID)&&
164:                  (SetupPkt.bIntfID != CDC_DATA_INTF_ID)) return;
17AD  0824     MOVF 0xA4, W
17AE  1903     BTFSC 0x83, 0x2
17AF  2FED     GOTO 0x7ED
17B0  0324     DECF 0xA4, W
17B1  1D03     BTFSS 0x83, 0x2
17B2  0008     RETURN
17B3  2FED     GOTO 0x7ED
165:               
166:               switch(SetupPkt.bRequest)
17ED  0021     MOVLB 0x1
17EE  0821     MOVF 0xA1, W
17EF  3A00     XORLW 0x0
17F0  1903     BTFSC 0x83, 0x2
17F1  2FB4     GOTO 0x7B4
17F2  3A01     XORLW 0x1
17F3  1903     BTFSC 0x83, 0x2
17F4  2FC0     GOTO 0x7C0
17F5  3A21     XORLW 0x21
17F6  1903     BTFSC 0x83, 0x2
17F7  2FC7     GOTO 0x7C7
17F8  3A01     XORLW 0x1
17F9  1903     BTFSC 0x83, 0x2
17FA  2FD7     GOTO 0x7D7
17FB  3A03     XORLW 0x3
17FC  1903     BTFSC 0x83, 0x2
17FD  2FE5     GOTO 0x7E5
17FE  2FFF     GOTO 0x7FF
167:               {
168:                   //****** These commands are required ******//
169:                   case SEND_ENCAPSULATED_COMMAND:
170:                    //send the packet
171:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response;
17B4  30B4     MOVLW 0xB4
17B5  0023     MOVLB 0x3
17B6  00B1     MOVWF inPipes
17B7  3002     MOVLW 0x2
17B8  00B2     MOVWF 0x1B2
172:                       inPipes[0].wCount.Val = dummy_length;
17B9  3008     MOVLW 0x8
17BA  00B4     MOVWF 0x1B4
17BB  3000     MOVLW 0x0
17BC  00B5     MOVWF 0x1B5
173:                       inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;
17BD  1433     BSF 0x1B3, 0x0
174:                       inPipes[0].info.bits.busy = 1;
17BE  17B3     BSF 0x1B3, 0x7
175:                       break;
17BF  0008     RETURN
176:                   case GET_ENCAPSULATED_RESPONSE:
177:                       // Populate dummy_encapsulated_cmd_response first.
178:                       inPipes[0].pSrc.bRam = (uint8_t*)&dummy_encapsulated_cmd_response;
17C0  30B4     MOVLW 0xB4
17C1  0023     MOVLB 0x3
17C2  00B1     MOVWF inPipes
17C3  3002     MOVLW 0x2
17C4  00B2     MOVWF 0x1B2
179:                       inPipes[0].info.bits.busy = 1;
17C5  17B3     BSF 0x1B3, 0x7
180:                       break;
17C6  0008     RETURN
181:                   //****** End of required commands ******//
182:           
183:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)
184:                   case SET_LINE_CODING:
185:                       outPipes[0].wCount.Val = SetupPkt.wLength;
17C7  0021     MOVLB 0x1
17C8  0827     MOVF 0xA7, W
17C9  0023     MOVLB 0x3
17CA  00AE     MOVWF 0x1AE
17CB  0021     MOVLB 0x1
17CC  0826     MOVF 0xA6, W
17CD  0023     MOVLB 0x3
17CE  00AD     MOVWF 0x1AD
186:                       outPipes[0].pDst.bRam = (uint8_t*)LINE_CODING_TARGET;
17CF  3057     MOVLW 0x57
17D0  00F2     MOVWF 0x1F2
17D1  0872     MOVF 0x1F2, W
17D2  00AA     MOVWF outPipes
187:                       outPipes[0].pFunc = LINE_CODING_PFUNC;
17D3  01AF     CLRF 0x1AF
17D4  01B0     CLRF 0x1B0
188:                       outPipes[0].info.bits.busy = 1;
17D5  17AC     BSF 0x1AC, 0x7
189:                       break;
17D6  0008     RETURN
190:                       
191:                   case GET_LINE_CODING:
192:                       USBEP0SendRAMPtr(
17D7  3057     MOVLW 0x57
17D8  0023     MOVLB 0x3
17D9  00B1     MOVWF inPipes
17DA  3002     MOVLW 0x2
17DB  00B2     MOVWF 0x1B2
17DC  3007     MOVLW 0x7
17DD  00B4     MOVWF 0x1B4
17DE  3000     MOVLW 0x0
17DF  00B5     MOVWF 0x1B5
17E0  30C1     MOVLW 0xC1
17E1  00F2     MOVWF 0x1F2
17E2  0872     MOVF 0x1F2, W
17E3  00B3     MOVWF 0x1B3
193:                           (uint8_t*)&line_coding,
194:                           LINE_CODING_LENGTH,
195:                           USB_EP0_INCLUDE_ZERO);
196:                       break;
17E4  0008     RETURN
197:           
198:                   case SET_CONTROL_LINE_STATE:
199:                       control_signal_bitmap._byte = (uint8_t)SetupPkt.wValue;
17E5  0021     MOVLB 0x1
17E6  0822     MOVF 0xA2, W
17E7  00F2     MOVWF 0xF2
17E8  0872     MOVF 0xF2, W
17E9  0023     MOVLB 0x3
17EA  00DA     MOVWF control_signal_bitmap
200:                       //------------------------------------------------------------------            
201:                       //One way to control the RTS pin is to allow the USB host to decide the value
202:                       //that should be output on the RTS pin.  Although RTS and CTS pin functions
203:                       //are technically intended for UART hardware based flow control, some legacy
204:                       //UART devices use the RTS pin like a "general purpose" output pin 
205:                       //from the PC host.  In this usage model, the RTS pin is not related
206:                       //to flow control for RX/TX.
207:                       //In this scenario, the USB host would want to be able to control the RTS
208:                       //pin, and the below line of code should be uncommented.
209:                       //However, if the intention is to implement true RTS/CTS flow control
210:                       //for the RX/TX pair, then this application firmware should override
211:                       //the USB host's setting for RTS, and instead generate a real RTS signal,
212:                       //based on the amount of remaining buffer space available for the 
213:                       //actual hardware UART of this microcontroller.  In this case, the 
214:                       //below code should be left commented out, but instead RTS should be 
215:                       //controlled in the application firmware responsible for operating the 
216:                       //hardware UART of this microcontroller.
217:                       //---------            
218:                       //CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);  
219:                       //------------------------------------------------------------------            
220:                       
221:                       #if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
222:                           if(control_signal_bitmap.DTE_PRESENT == 1)
223:                           {
224:                               UART_DTR = USB_CDC_DTR_ACTIVE_LEVEL;
225:                           }
226:                           else
227:                           {
228:                               UART_DTR = (USB_CDC_DTR_ACTIVE_LEVEL ^ 1);
229:                           }        
230:                       #endif
231:                       inPipes[0].info.bits.busy = 1;
17EB  17B3     BSF 0x1B3, 0x7
232:                       break;
233:                   #endif
234:           
235:                   #if defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)
236:                   case SEND_BREAK:                        // Optional
237:                       inPipes[0].info.bits.busy = 1;
238:           			if (SetupPkt.wValue == 0xFFFF)  //0xFFFF means send break indefinitely until a new SEND_BREAK command is received
239:           			{
240:           				UART_Tx = 0;       // Prepare to drive TX low (for break signaling)
241:           				UART_TRISTx = 0;   // Make sure TX pin configured as an output
242:           				UART_ENABLE = 0;   // Turn off USART (to relinquish TX pin control)
243:           			}
244:           			else if (SetupPkt.wValue == 0x0000) //0x0000 means stop sending indefinite break 
245:           			{
246:               			UART_ENABLE = 1;   // turn on USART
247:           				UART_TRISTx = 1;   // Make TX pin an input
248:           			}
249:           			else
250:           			{
251:                           //Send break signaling on the pin for (SetupPkt.wValue) milliseconds
252:                           UART_SEND_BREAK();
253:           			}
254:                       break;
255:                   #endif
256:                   default:
257:                       break;
258:               }//end switch(SetupPkt.bRequest)
17EC  0008     RETURN
259:           
260:           }//end USBCheckCDCRequest
17FF  0008     RETURN
261:           
262:           /** U S E R  A P I ***********************************************************/
263:           
264:           /**************************************************************************
265:             Function:
266:                   void CDCInitEP(void)
267:               
268:             Summary:
269:               This function initializes the CDC function driver. This function should
270:               be called after the SET_CONFIGURATION command (ex: within the context of
271:               the USBCBInitEP() function).
272:             Description:
273:               This function initializes the CDC function driver. This function sets
274:               the default line coding (baud rate, bit parity, number of data bits,
275:               and format). This function also enables the endpoints and prepares for
276:               the first transfer from the host.
277:               
278:               This function should be called after the SET_CONFIGURATION command.
279:               This is most simply done by calling this function from the
280:               USBCBInitEP() function.
281:               
282:               Typical Usage:
283:               <code>
284:                   void USBCBInitEP(void)
285:                   {
286:                       CDCInitEP();
287:                   }
288:               </code>
289:             Conditions:
290:               None
291:             Remarks:
292:               None                                                                   
293:             **************************************************************************/
294:           void CDCInitEP(void)
295:           {
296:               //Abstract line coding information
297:               line_coding.dwDTERate   = 19200;      // baud rate
140B  3000     MOVLW 0x0
140C  0024     MOVLB 0x4
140D  00DA     MOVWF 0x25A
140E  3000     MOVLW 0x0
140F  00D9     MOVWF 0x259
1410  304B     MOVLW 0x4B
1411  00D8     MOVWF 0x258
1412  3000     MOVLW 0x0
1413  00D7     MOVWF line_coding
298:               line_coding.bCharFormat = 0x00;             // 1 stop bit
1414  01DB     CLRF 0x25B
299:               line_coding.bParityType = 0x00;             // None
1415  01DC     CLRF 0x25C
300:               line_coding.bDataBits = 0x08;               // 5,6,7,8, or 16
1416  3008     MOVLW 0x8
1417  0021     MOVLB 0x1
1418  00E5     MOVWF byte_to_send
1419  0865     MOVF byte_to_send, W
141A  0024     MOVLB 0x4
141B  00DD     MOVWF 0x25D
301:           
302:               cdc_rx_len = 0;
141C  0023     MOVLB 0x3
141D  01D3     CLRF cdc_rx_len
303:               
304:               /*
305:                * Do not have to init Cnt of IN pipes here.
306:                * Reason:  Number of BYTEs to send to the host
307:                *          varies from one transaction to
308:                *          another. Cnt should equal the exact
309:                *          number of BYTEs to transmit for
310:                *          a given IN transaction.
311:                *          This number of BYTEs will only
312:                *          be known right before the data is
313:                *          sent.
314:                */
315:               USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
141E  301A     MOVLW 0x1A
141F  0021     MOVLB 0x1
1420  00E5     MOVWF byte_to_send
1421  0865     MOVF byte_to_send, W
1422  00F9     MOVWF 0xF9
1423  3001     MOVLW 0x1
1424  3193     MOVLP 0x13
1425  2313     CALL 0x313
1426  3194     MOVLP 0x14
316:               USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
1427  301E     MOVLW 0x1E
1428  0021     MOVLB 0x1
1429  00E5     MOVWF byte_to_send
142A  0865     MOVF byte_to_send, W
142B  00F9     MOVWF 0xF9
142C  3002     MOVLW 0x2
142D  3193     MOVLP 0x13
142E  2313     CALL 0x313
142F  3194     MOVLP 0x14
317:           
318:               CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
1430  01F2     CLRF 0xF2
1431  3020     MOVLW 0x20
1432  00F3     MOVWF 0xF3
1433  3001     MOVLW 0x1
1434  00F4     MOVWF 0xF4
1435  3040     MOVLW 0x40
1436  0021     MOVLB 0x1
1437  00E5     MOVWF byte_to_send
1438  0865     MOVF byte_to_send, W
1439  00F5     MOVWF 0xF5
143A  3002     MOVLW 0x2
143B  318B     MOVLP 0xB
143C  2315     CALL 0x315
143D  0873     MOVF 0xF3, W
143E  0023     MOVLB 0x3
143F  00BB     MOVWF 0x1BB
1440  0872     MOVF 0x1F2, W
1441  00BA     MOVWF CDCDataOutHandle
319:               CDCDataInHandle = NULL;
1442  01B6     CLRF CDCDataInHandle
1443  01B7     CLRF 0x1B7
320:           
321:               #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
322:                 	CDCNotificationInHandle = NULL;
323:                   mInitDTSPin();  //Configure DTS as a digital input
324:                 	SerialStateBitmap.byte = 0x00;
325:                 	OldSerialStateBitmap.byte = !SerialStateBitmap.byte;    //To force firmware to send an initial serial state packet to the host.
326:                   //Prepare a SerialState notification element packet (contains info like DSR state)
327:                   SerialStatePacket.bmRequestType = 0xA1; //Always 0xA1 for this type of packet.
328:                   SerialStatePacket.bNotification = SERIAL_STATE;
329:                   SerialStatePacket.wValue = 0x0000;  //Always 0x0000 for this type of packet
330:                   SerialStatePacket.wIndex = CDC_COMM_INTF_ID;  //Interface number  
331:                   SerialStatePacket.SerialState.byte = 0x00;
332:                   SerialStatePacket.Reserved = 0x00;
333:                   SerialStatePacket.wLength = 0x02;   //Always 2 bytes for this type of packet    
334:                   CDCNotificationHandler();
335:             	#endif
336:             	
337:             	#if defined(USB_CDC_SUPPORT_DTR_SIGNALING)
338:             	    mInitDTRPin();
339:             	#endif
340:             	
341:             	#if defined(USB_CDC_SUPPORT_HARDWARE_FLOW_CONTROL)
342:             	    mInitRTSPin();
343:             	    mInitCTSPin();
344:             	#endif
345:               
346:               cdc_trf_state = CDC_TX_READY;
1444  01D5     CLRF cdc_trf_state
347:           }//end CDCInitEP
1445  0008     RETURN
348:           
349:           
350:           /**************************************************************************
351:             Function: void CDCNotificationHandler(void)
352:             Summary: Checks for changes in DSR status and reports them to the USB host.
353:             Description: Checks for changes in DSR pin state and reports any changes
354:                          to the USB host. 
355:             Conditions: CDCInitEP() must have been called previously, prior to calling
356:                         CDCNotificationHandler() for the first time.
357:             Remarks:
358:               This function is only implemented and needed when the 
359:               USB_CDC_SUPPORT_DSR_REPORTING option has been enabled.  If the function is
360:               enabled, it should be called periodically to sample the DSR pin and feed
361:               the information to the USB host.  This can be done by calling 
362:               CDCNotificationHandler() by itself, or, by calling CDCTxService() which
363:               also calls CDCNotificationHandler() internally, when appropriate.
364:             **************************************************************************/
365:           #if defined(USB_CDC_SUPPORT_DSR_REPORTING)
366:           void CDCNotificationHandler(void)
367:           {
368:               //Check the DTS I/O pin and if a state change is detected, notify the 
369:               //USB host by sending a serial state notification element packet.
370:               if(UART_DTS == USB_CDC_DSR_ACTIVE_LEVEL) //UART_DTS must be defined to be an I/O pin in the hardware profile to use the DTS feature (ex: "PORTXbits.RXY")
371:               {
372:                   SerialStateBitmap.bits.DSR = 1;
373:               }  
374:               else
375:               {
376:                   SerialStateBitmap.bits.DSR = 0;
377:               }        
378:               
379:               //If the state has changed, and the endpoint is available, send a packet to
380:               //notify the hUSB host of the change.
381:               if((SerialStateBitmap.byte != OldSerialStateBitmap.byte) && (!USBHandleBusy(CDCNotificationInHandle)))
382:               {
383:                   //Copy the updated value into the USB packet buffer to send.
384:                   SerialStatePacket.SerialState.byte = SerialStateBitmap.byte;
385:                   //We don't need to write to the other bytes in the SerialStatePacket USB
386:                   //buffer, since they don't change and will always be the same as our
387:                   //initialized value.
388:           
389:                   //Send the packet over USB to the host.
390:                   CDCNotificationInHandle = USBTransferOnePacket(CDC_COMM_EP, IN_TO_HOST, (uint8_t*)&SerialStatePacket, sizeof(SERIAL_STATE_NOTIFICATION));
391:                   
392:                   //Save the old value, so we can detect changes later.
393:                   OldSerialStateBitmap.byte = SerialStateBitmap.byte;
394:               }    
395:           }//void CDCNotificationHandler(void)    
396:           #else
397:               #define CDCNotificationHandler() {}
398:           #endif
399:           
400:           
401:           /**********************************************************************************
402:             Function:
403:               bool USBCDCEventHandler(USB_EVENT event, void *pdata, uint16_t size)
404:               
405:             Summary:
406:               Handles events from the USB stack, which may have an effect on the CDC 
407:               endpoint(s).
408:           
409:             Description:
410:               Handles events from the USB stack.  This function should be called when 
411:               there is a USB event that needs to be processed by the CDC driver.
412:               
413:             Conditions:
414:               Value of input argument 'len' should be smaller than the maximum
415:               endpoint size responsible for receiving bulk data from USB host for CDC
416:               class. Input argument 'buffer' should point to a buffer area that is
417:               bigger or equal to the size specified by 'len'.
418:             Input:
419:               event - the type of event that occurred
420:               pdata - pointer to the data that caused the event
421:               size - the size of the data that is pointed to by pdata
422:                                                                                              
423:             **********************************************************************************/
424:           bool USBCDCEventHandler(USB_EVENT event, void *pdata, uint16_t size)
425:           {
426:               switch( (uint16_t)event )
427:               {  
428:                   case EVENT_TRANSFER_TERMINATED:
429:                       if(pdata == CDCDataOutHandle)
430:                       {
431:                           CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
432:                       }
433:                       if(pdata == CDCDataInHandle)
434:                       {
435:                           //flush all of the data in the CDC buffer
436:                           cdc_trf_state = CDC_TX_READY;
437:                           cdc_tx_len = 0;
438:                       }
439:                       break;
440:                   default:
441:                       return false;
442:               }      
443:               return true;
444:           }
445:           
446:           /**********************************************************************************
447:             Function:
448:                   uint8_t getsUSBUSART(char *buffer, uint8_t len)
449:               
450:             Summary:
451:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
452:               endpoint to a user's specified location. It is a non-blocking function.
453:               It does not wait for data if there is no data available. Instead it
454:               returns '0' to notify the caller that there is no data available.
455:           
456:             Description:
457:               getsUSBUSART copies a string of BYTEs received through USB CDC Bulk OUT
458:               endpoint to a user's specified location. It is a non-blocking function.
459:               It does not wait for data if there is no data available. Instead it
460:               returns '0' to notify the caller that there is no data available.
461:               
462:               Typical Usage:
463:               <code>
464:                   uint8_t numBytes;
465:                   uint8_t buffer[64]
466:               
467:                   numBytes = getsUSBUSART(buffer,sizeof(buffer)); //until the buffer is free.
468:                   if(numBytes \> 0)
469:                   {
470:                       //we received numBytes bytes of data and they are copied into
471:                       //  the "buffer" variable.  We can do something with the data
472:                       //  here.
473:                   }
474:               </code>
475:             Conditions:
476:               Value of input argument 'len' should be smaller than the maximum
477:               endpoint size responsible for receiving bulk data from USB host for CDC
478:               class. Input argument 'buffer' should point to a buffer area that is
479:               bigger or equal to the size specified by 'len'.
480:             Input:
481:               buffer -  Pointer to where received BYTEs are to be stored
482:               len -     The number of BYTEs expected.
483:                                                                                              
484:             **********************************************************************************/
485:           uint8_t getsUSBUSART(uint8_t *buffer, uint8_t len)
1639  0021     MOVLB 0x1
163A  00E6     MOVWF buffer
486:           {
487:               cdc_rx_len = 0;
163B  0023     MOVLB 0x3
163C  01D3     CLRF cdc_rx_len
488:               
489:               if(!USBHandleBusy(CDCDataOutHandle))
163D  083A     MOVF CDCDataOutHandle, W
163E  043B     IORWF 0x1BB, W
163F  1903     BTFSC 0x183, 0x2
1640  2E47     GOTO 0x647
1641  083A     MOVF CDCDataOutHandle, W
1642  0086     MOVWF 0x186
1643  083B     MOVF 0x1BB, W
1644  0087     MOVWF 0x187
1645  1B81     BTFSC 0x181, 0x7
1646  2E8F     GOTO 0x68F
490:               {
491:                   /*
492:                    * Adjust the expected number of BYTEs to equal
493:                    * the actual number of BYTEs received.
494:                    */
495:                   if(len > USBHandleGetLength(CDCDataOutHandle))
1647  083A     MOVF CDCDataOutHandle, W
1648  0086     MOVWF 0x186
1649  083B     MOVF 0x1BB, W
164A  0087     MOVWF 0x187
164B  3141     ADDFSR 1, 1
164C  0021     MOVLB 0x1
164D  0863     MOVF len, W
164E  0201     SUBWF 0x81, W
164F  1803     BTFSC 0x83, 0x0
1650  2E5C     GOTO 0x65C
496:                       len = USBHandleGetLength(CDCDataOutHandle);
1651  0023     MOVLB 0x3
1652  083A     MOVF CDCDataOutHandle, W
1653  0086     MOVWF 0x186
1654  083B     MOVF 0x1BB, W
1655  0087     MOVWF 0x187
1656  3141     ADDFSR 1, 1
1657  0801     MOVF 0x181, W
1658  0021     MOVLB 0x1
1659  00E4     MOVWF ep
165A  0864     MOVF ep, W
165B  00E3     MOVWF len
497:                   
498:                   /*
499:                    * Copy data from dual-ram buffer to user's buffer
500:                    */
501:                   for(cdc_rx_len = 0; cdc_rx_len < len; cdc_rx_len++)
165C  0023     MOVLB 0x3
165D  01D3     CLRF cdc_rx_len
165E  0021     MOVLB 0x1
165F  0863     MOVF len, W
1660  0023     MOVLB 0x3
1661  0253     SUBWF cdc_rx_len, W
1662  1803     BTFSC 0x183, 0x0
1663  2E7D     GOTO 0x67D
1677  3001     MOVLW 0x1
1678  00E4     MOVWF 0x1E4
1679  0864     MOVF 0x1E4, W
167A  0023     MOVLB 0x3
167B  07D3     ADDWF cdc_rx_len, F
167C  2E5E     GOTO 0x65E
502:                       buffer[cdc_rx_len] = cdc_data_rx[cdc_rx_len];
1664  0853     MOVF cdc_rx_len, W
1665  3E20     ADDLW 0x20
1666  0086     MOVWF 0x186
1667  3001     MOVLW 0x1
1668  0087     MOVWF 0x187
1669  0801     MOVF 0x181, W
166A  0021     MOVLB 0x1
166B  00E4     MOVWF ep
166C  0023     MOVLB 0x3
166D  0853     MOVF cdc_rx_len, W
166E  0021     MOVLB 0x1
166F  0766     ADDWF buffer, W
1670  00E5     MOVWF byte_to_send
1671  0865     MOVF byte_to_send, W
1672  0086     MOVWF 0x86
1673  3003     MOVLW 0x3
1674  0087     MOVWF 0x87
1675  0864     MOVF ep, W
1676  0081     MOVWF 0x81
503:           
504:                   /*
505:                    * Prepare dual-ram buffer for next OUT transaction
506:                    */
507:           
508:                   CDCDataOutHandle = USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));
167D  01F2     CLRF 0xF2
167E  3020     MOVLW 0x20
167F  00F3     MOVWF 0xF3
1680  3001     MOVLW 0x1
1681  00F4     MOVWF 0xF4
1682  3040     MOVLW 0x40
1683  0021     MOVLB 0x1
1684  00E4     MOVWF ep
1685  0864     MOVF ep, W
1686  00F5     MOVWF 0xF5
1687  3002     MOVLW 0x2
1688  318B     MOVLP 0xB
1689  2315     CALL 0x315
168A  0873     MOVF 0xF3, W
168B  0023     MOVLB 0x3
168C  00BB     MOVWF 0x1BB
168D  0872     MOVF 0x1F2, W
168E  00BA     MOVWF CDCDataOutHandle
509:           
510:               }//end if
511:               
512:               return cdc_rx_len;
168F  0853     MOVF cdc_rx_len, W
513:               
514:           }//end getsUSBUSART
515:           
516:           /******************************************************************************
517:             Function:
518:           	void putUSBUSART(char *data, uint8_t length)
519:           		
520:             Summary:
521:               putUSBUSART writes an array of data to the USB. Use this version, is
522:               capable of transferring 0x00 (what is typically a NULL character in any of
523:               the string transfer functions).
524:           
525:             Description:
526:               putUSBUSART writes an array of data to the USB. Use this version, is
527:               capable of transferring 0x00 (what is typically a NULL character in any of
528:               the string transfer functions).
529:               
530:               Typical Usage:
531:               <code>
532:                   if(USBUSARTIsTxTrfReady())
533:                   {
534:                       char data[] = {0x00, 0x01, 0x02, 0x03, 0x04};
535:                       putUSBUSART(data,5);
536:                   }
537:               </code>
538:               
539:               The transfer mechanism for device-to-host(put) is more flexible than
540:               host-to-device(get). It can handle a string of data larger than the
541:               maximum size of bulk IN endpoint. A state machine is used to transfer a
542:               \long string of data over multiple USB transactions. CDCTxService()
543:               must be called periodically to keep sending blocks of data to the host.
544:           
545:             Conditions:
546:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
547:               transfer is complete and is ready to receive a new block of data. The
548:               string of characters pointed to by 'data' must equal to or smaller than
549:               255 BYTEs.
550:           
551:             Input:
552:               char *data - pointer to a RAM array of data to be transfered to the host
553:               uint8_t length - the number of bytes to be transfered (must be less than 255).
554:           		
555:            *****************************************************************************/
556:           void putUSBUSART(uint8_t *data, uint8_t  length)
557:           {
558:               /*
559:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
560:                * before calling this function.
561:                * As a safety precaution, this function checks the state one more time
562:                * to make sure it does not override any pending transactions.
563:                *
564:                * Currently it just quits the routine without reporting any errors back
565:                * to the user.
566:                *
567:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
568:                *             before calling this function!
569:                * Example:
570:                * if(USBUSARTIsTxTrfReady())
571:                *     putUSBUSART(pData, Length);
572:                *
573:                * IMPORTANT: Never use the following blocking while loop to wait:
574:                * while(!USBUSARTIsTxTrfReady())
575:                *     putUSBUSART(pData, Length);
576:                *
577:                * The whole firmware framework is written based on cooperative
578:                * multi-tasking and a blocking code is not acceptable.
579:                * Use a state machine instead.
580:                */
581:               USBMaskInterrupts();
582:               if(cdc_trf_state == CDC_TX_READY)
121C  0023     MOVLB 0x3
121D  0855     MOVF cdc_trf_state, W
121E  1D03     BTFSS 0x183, 0x2
121F  0008     RETURN
583:               {
584:                   mUSBUSARTTxRam((uint8_t*)data, length);     // See cdc.h
1220  0873     MOVF 0x1F3, W
585:               }
586:               USBUnmaskInterrupts();
587:           }//end putUSBUSART
588:           
589:           /******************************************************************************
590:           	Function:
591:           		void putsUSBUSART(char *data)
592:           		
593:             Summary:
594:               putsUSBUSART writes a string of data to the USB including the null
595:               character. Use this version, 'puts', to transfer data from a RAM buffer.
596:           
597:             Description:
598:               putsUSBUSART writes a string of data to the USB including the null
599:               character. Use this version, 'puts', to transfer data from a RAM buffer.
600:               
601:               Typical Usage:
602:               <code>
603:                   if(USBUSARTIsTxTrfReady())
604:                   {
605:                       char data[] = "Hello World";
606:                       putsUSBUSART(data);
607:                   }
608:               </code>
609:               
610:               The transfer mechanism for device-to-host(put) is more flexible than
611:               host-to-device(get). It can handle a string of data larger than the
612:               maximum size of bulk IN endpoint. A state machine is used to transfer a
613:               \long string of data over multiple USB transactions. CDCTxService()
614:               must be called periodically to keep sending blocks of data to the host.
615:           
616:             Conditions:
617:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
618:               transfer is complete and is ready to receive a new block of data. The
619:               string of characters pointed to by 'data' must equal to or smaller than
620:               255 BYTEs.
621:           
622:             Input:
623:               char *data -  null\-terminated string of constant data. If a
624:                                       null character is not found, 255 BYTEs of data
625:                                       will be transferred to the host.
626:           		
627:            *****************************************************************************/
628:            
629:           void putsUSBUSART(char *data)
630:           {
631:               uint8_t len;
632:               char *pData;
633:           
634:               /*
635:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
636:                * before calling this function.
637:                * As a safety precaution, this function checks the state one more time
638:                * to make sure it does not override any pending transactions.
639:                *
640:                * Currently it just quits the routine without reporting any errors back
641:                * to the user.
642:                *
643:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()==1
644:                *             before calling this function!
645:                * Example:
646:                * if(USBUSARTIsTxTrfReady())
647:                *     putsUSBUSART(pData, Length);
648:                *
649:                * IMPORTANT: Never use the following blocking while loop to wait:
650:                * while(!USBUSARTIsTxTrfReady())
651:                *     putsUSBUSART(pData);
652:                *
653:                * The whole firmware framework is written based on cooperative
654:                * multi-tasking and a blocking code is not acceptable.
655:                * Use a state machine instead.
656:                */
657:               USBMaskInterrupts();
658:               if(cdc_trf_state != CDC_TX_READY)
659:               {
660:                   USBUnmaskInterrupts();
661:                   return;
662:               }
663:               
664:               /*
665:                * While loop counts the number of BYTEs to send including the
666:                * null character.
667:                */
668:               len = 0;
669:               pData = data;
670:               do
671:               {
672:                   len++;
673:                   if(len == 255) break;       // Break loop once max len is reached.
674:               }while(*pData++);
675:               
676:               /*
677:                * Second piece of information (length of data to send) is ready.
678:                * Call mUSBUSARTTxRam to setup the transfer.
679:                * The actual transfer process will be handled by CDCTxService(),
680:                * which should be called once per Main Program loop.
681:                */
682:               mUSBUSARTTxRam((uint8_t*)data, len);     // See cdc.h
683:               USBUnmaskInterrupts();
684:           }//end putsUSBUSART
685:           
686:           /**************************************************************************
687:             Function:
688:                   void putrsUSBUSART(const const char *data)
689:               
690:             Summary:
691:               putrsUSBUSART writes a string of data to the USB including the null
692:               character. Use this version, 'putrs', to transfer data literals and
693:               data located in program memory.
694:           
695:             Description:
696:               putrsUSBUSART writes a string of data to the USB including the null
697:               character. Use this version, 'putrs', to transfer data literals and
698:               data located in program memory.
699:               
700:               Typical Usage:
701:               <code>
702:                   if(USBUSARTIsTxTrfReady())
703:                   {
704:                       putrsUSBUSART("Hello World");
705:                   }
706:               </code>
707:               
708:               The transfer mechanism for device-to-host(put) is more flexible than
709:               host-to-device(get). It can handle a string of data larger than the
710:               maximum size of bulk IN endpoint. A state machine is used to transfer a
711:               \long string of data over multiple USB transactions. CDCTxService()
712:               must be called periodically to keep sending blocks of data to the host.
713:           
714:             Conditions:
715:               USBUSARTIsTxTrfReady() must return true. This indicates that the last
716:               transfer is complete and is ready to receive a new block of data. The
717:               string of characters pointed to by 'data' must equal to or smaller than
718:               255 BYTEs.
719:           
720:             Input:
721:               const const char *data -  null\-terminated string of constant data. If a
722:                                       null character is not found, 255 uint8_ts of data
723:                                       will be transferred to the host.
724:                                                                                      
725:             **************************************************************************/
726:           void putrsUSBUSART(const const char *data)
727:           {
728:               uint8_t len;
729:               const const char *pData;
730:           
731:               /*
732:                * User should have checked that cdc_trf_state is in CDC_TX_READY state
733:                * before calling this function.
734:                * As a safety precaution, this function checks the state one more time
735:                * to make sure it does not override any pending transactions.
736:                *
737:                * Currently it just quits the routine without reporting any errors back
738:                * to the user.
739:                *
740:                * Bottom line: User MUST make sure that USBUSARTIsTxTrfReady()
741:                *             before calling this function!
742:                * Example:
743:                * if(USBUSARTIsTxTrfReady())
744:                *     putsUSBUSART(pData);
745:                *
746:                * IMPORTANT: Never use the following blocking while loop to wait:
747:                * while(cdc_trf_state != CDC_TX_READY)
748:                *     putsUSBUSART(pData);
749:                *
750:                * The whole firmware framework is written based on cooperative
751:                * multi-tasking and a blocking code is not acceptable.
752:                * Use a state machine instead.
753:                */
754:               USBMaskInterrupts();
755:               if(cdc_trf_state != CDC_TX_READY)
756:               {
757:                   USBUnmaskInterrupts();
758:                   return;
759:               }
760:               
761:               /*
762:                * While loop counts the number of BYTEs to send including the
763:                * null character.
764:                */
765:               len = 0;
766:               pData = data;
767:               do
768:               {
769:                   len++;
770:                   if(len == 255) break;       // Break loop once max len is reached.
771:               }while(*pData++);
772:               
773:               /*
774:                * Second piece of information (length of data to send) is ready.
775:                * Call mUSBUSARTTxRom to setup the transfer.
776:                * The actual transfer process will be handled by CDCTxService(),
777:                * which should be called once per Main Program loop.
778:                */
779:           
780:               mUSBUSARTTxRom((const uint8_t*)data,len); // See cdc.h
781:               USBUnmaskInterrupts();
782:           
783:           }//end putrsUSBUSART
784:           
785:           /************************************************************************
786:             Function:
787:                   void CDCTxService(void)
788:               
789:             Summary:
790:               CDCTxService handles device-to-host transaction(s). This function
791:               should be called once per Main Program loop after the device reaches
792:               the configured state.
793:             Description:
794:               CDCTxService handles device-to-host transaction(s). This function
795:               should be called once per Main Program loop after the device reaches
796:               the configured state (after the CDCIniEP() function has already executed).
797:               This function is needed, in order to advance the internal software state 
798:               machine that takes care of sending multiple transactions worth of IN USB
799:               data to the host, associated with CDC serial data.  Failure to call 
800:               CDCTxService() periodically will prevent data from being sent to the
801:               USB host, over the CDC serial data interface.
802:               
803:               Typical Usage:
804:               <code>
805:               void main(void)
806:               {
807:                   USBDeviceInit();
808:                   while(1)
809:                   {
810:                       USBDeviceTasks();
811:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
812:                          (USBIsDeviceSuspended() == true))
813:                       {
814:                           //Either the device is not configured or we are suspended
815:                           //  so we don't want to do execute any application code
816:                           continue;   //go back to the top of the while loop
817:                       }
818:                       else
819:                       {
820:                           //Keep trying to send data to the PC as required
821:                           CDCTxService();
822:               
823:                           //Run application code.
824:                           UserApplication();
825:                       }
826:                   }
827:               }
828:               </code>
829:             Conditions:
830:               CDCIniEP() function should have already executed/the device should be
831:               in the CONFIGURED_STATE.
832:             Remarks:
833:               None                                                                 
834:             ************************************************************************/
835:            
836:           void CDCTxService(void)
837:           {
838:               uint8_t byte_to_send;
839:               uint8_t i;
840:               
841:               USBMaskInterrupts();
842:               
843:               CDCNotificationHandler();
844:               
845:               if(USBHandleBusy(CDCDataInHandle)) 
0E86  0023     MOVLB 0x3
0E87  0836     MOVF CDCDataInHandle, W
0E88  0437     IORWF 0x1B7, W
0E89  1903     BTFSC 0x183, 0x2
0E8A  2E91     GOTO 0x691
0E8B  0836     MOVF CDCDataInHandle, W
0E8C  0086     MOVWF 0x186
0E8D  0837     MOVF 0x1B7, W
0E8E  0087     MOVWF 0x187
0E8F  1B81     BTFSC 0x181, 0x7
0E90  0008     RETURN
846:               {
847:                   USBUnmaskInterrupts();
848:                   return;
849:               }
850:           
851:               /*
852:                * Completing stage is necessary while [ mCDCUSartTxIsBusy()==1 ].
853:                * By having this stage, user can always check cdc_trf_state,
854:                * and not having to call mCDCUsartTxIsBusy() directly.
855:                */
856:               if(cdc_trf_state == CDC_TX_COMPLETING)
0E91  3003     MOVLW 0x3
0E92  0655     XORWF cdc_trf_state, W
0E93  1903     BTFSC 0x183, 0x2
857:                   cdc_trf_state = CDC_TX_READY;
0E94  01D5     CLRF cdc_trf_state
858:               
859:               /*
860:                * If CDC_TX_READY state, nothing to do, just return.
861:                */
862:               if(cdc_trf_state == CDC_TX_READY)
0E95  0855     MOVF cdc_trf_state, W
0E96  1903     BTFSC 0x183, 0x2
0E97  0008     RETURN
863:               {
864:                   USBUnmaskInterrupts();
865:                   return;
866:               }
867:               
868:               /*
869:                * If CDC_TX_BUSY_ZLP state, send zero length packet
870:                */
871:               if(cdc_trf_state == CDC_TX_BUSY_ZLP)
0E98  3002     MOVLW 0x2
0E99  0655     XORWF cdc_trf_state, W
0E9A  1D03     BTFSS 0x183, 0x2
0E9B  2EB2     GOTO 0x6B2
872:               {
873:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,NULL,0);
0E9C  01F2     CLRF 0x1F2
0E9D  0AF2     INCF 0x1F2, F
0E9E  3000     MOVLW 0x0
0E9F  00F3     MOVWF 0x1F3
0EA0  3000     MOVLW 0x0
0EA1  00F4     MOVWF 0x1F4
0EA2  01F5     CLRF 0x1F5
0EA3  3002     MOVLW 0x2
0EA4  318B     MOVLP 0xB
0EA5  2315     CALL 0x315
0EA6  0873     MOVF 0x1F3, W
0EA7  0023     MOVLB 0x3
0EA8  00B7     MOVWF 0x1B7
0EA9  0872     MOVF 0x1F2, W
0EAA  00B6     MOVWF CDCDataInHandle
874:                   //CDC_DATA_BD_IN.CNT = 0;
875:                   cdc_trf_state = CDC_TX_COMPLETING;
0EAB  3003     MOVLW 0x3
0EAC  0021     MOVLB 0x1
0EAD  00E3     MOVWF len
0EAE  0863     MOVF len, W
0EAF  0023     MOVLB 0x3
0EB0  00D5     MOVWF cdc_trf_state
876:               }
0EB1  0008     RETURN
877:               else if(cdc_trf_state == CDC_TX_BUSY)
0EB2  0355     DECF cdc_trf_state, W
0EB3  1D03     BTFSS 0x183, 0x2
0EB4  0008     RETURN
878:               {
879:                   /*
880:                    * First, have to figure out how many byte of data to send.
881:                    */
882:               	if(cdc_tx_len > sizeof(cdc_data_tx))
0EB5  3041     MOVLW 0x41
0EB6  0257     SUBWF cdc_tx_len, W
0EB7  1C03     BTFSS 0x183, 0x0
0EB8  2EBB     GOTO 0x6BB
883:               	    byte_to_send = sizeof(cdc_data_tx);
0EB9  3040     MOVLW 0x40
0EBA  2EBD     GOTO 0x6BD
884:               	else
885:               	    byte_to_send = cdc_tx_len;
0EBB  0023     MOVLB 0x3
0EBC  0857     MOVF cdc_tx_len, W
0EBD  0021     MOVLB 0x1
0EBE  00E3     MOVWF len
0EBF  0863     MOVF len, W
0EC0  00E5     MOVWF byte_to_send
886:           
887:                   /*
888:                    * Subtract the number of bytes just about to be sent from the total.
889:                    */
890:               	cdc_tx_len = cdc_tx_len - byte_to_send;
0EC1  0365     DECF byte_to_send, W
0EC2  3AFF     XORLW 0xFF
0EC3  0023     MOVLB 0x3
0EC4  0757     ADDWF cdc_tx_len, W
0EC5  0021     MOVLB 0x1
0EC6  00E3     MOVWF len
0EC7  0863     MOVF len, W
0EC8  0023     MOVLB 0x3
0EC9  00D7     MOVWF cdc_tx_len
891:               	  
892:                   pCDCDst.bRam = (uint8_t*)&cdc_data_tx; // Set destination pointer
0ECA  30A0     MOVLW 0xA0
0ECB  0021     MOVLB 0x1
0ECC  00E3     MOVWF len
0ECD  0863     MOVF len, W
0ECE  0024     MOVLB 0x4
0ECF  00CE     MOVWF pCDCDst
893:                   
894:                   i = byte_to_send;
0ED0  0021     MOVLB 0x1
0ED1  0865     MOVF byte_to_send, W
0ED2  00E3     MOVWF len
0ED3  0863     MOVF len, W
0ED4  00E4     MOVWF ep
895:                   if(cdc_mem_type == USB_EP0_ROM)            // Determine type of memory source
0ED5  0023     MOVLB 0x3
0ED6  0851     MOVF cdc_mem_type, W
0ED7  1903     BTFSC 0x183, 0x2
0ED8  2EF5     GOTO 0x6F5
0ED9  2F15     GOTO 0x715
896:                   {
897:                       while(i)
0EF5  0021     MOVLB 0x1
0EF6  0864     MOVF ep, W
0EF7  1903     BTFSC 0x83, 0x2
0EF8  2F19     GOTO 0x719
0EF9  2EDA     GOTO 0x6DA
898:                       {
899:                           *pCDCDst.bRam = *pCDCSrc.bRom;
0EDA  0024     MOVLB 0x4
0EDB  0852     MOVF pCDCSrc, W
0EDC  0086     MOVWF 0x206
0EDD  0853     MOVF 0x253, W
0EDE  0087     MOVWF 0x207
0EDF  0801     MOVF 0x201, W
0EE0  0021     MOVLB 0x1
0EE1  00E3     MOVWF len
0EE2  0024     MOVLB 0x4
0EE3  084E     MOVF pCDCDst, W
0EE4  0086     MOVWF 0x206
0EE5  0187     CLRF 0x207
0EE6  0021     MOVLB 0x1
0EE7  0863     MOVF len, W
0EE8  0081     MOVWF 0x81
900:                           pCDCDst.bRam++;
0EE9  3001     MOVLW 0x1
0EEA  00E3     MOVWF len
0EEB  0863     MOVF len, W
0EEC  0024     MOVLB 0x4
0EED  07CE     ADDWF pCDCDst, F
901:                           pCDCSrc.bRom++;
0EEE  3001     MOVLW 0x1
0EEF  07D2     ADDWF pCDCSrc, F
0EF0  3000     MOVLW 0x0
0EF1  3DD3     ADDWFC 0x253, F
902:                           i--;
0EF2  3001     MOVLW 0x1
0EF3  0021     MOVLB 0x1
0EF4  02E4     SUBWF ep, F
903:                       }//end while(byte_to_send)
904:                   }
905:                   else
906:                   {
907:                       while(i)
0F15  0021     MOVLB 0x1
0F16  0864     MOVF ep, W
0F17  1D03     BTFSS 0x83, 0x2
0F18  2EFA     GOTO 0x6FA
908:                       {
909:                           *pCDCDst.bRam = *pCDCSrc.bRam;
0EFA  0024     MOVLB 0x4
0EFB  0852     MOVF pCDCSrc, W
0EFC  0086     MOVWF 0x206
0EFD  0853     MOVF 0x253, W
0EFE  0087     MOVWF 0x207
0EFF  0801     MOVF 0x201, W
0F00  0021     MOVLB 0x1
0F01  00E3     MOVWF len
0F02  0024     MOVLB 0x4
0F03  084E     MOVF pCDCDst, W
0F04  0086     MOVWF 0x206
0F05  0187     CLRF 0x207
0F06  0021     MOVLB 0x1
0F07  0863     MOVF len, W
0F08  0081     MOVWF 0x81
910:                           pCDCDst.bRam++;
0F09  3001     MOVLW 0x1
0F0A  00E3     MOVWF len
0F0B  0863     MOVF len, W
0F0C  0024     MOVLB 0x4
0F0D  07CE     ADDWF pCDCDst, F
911:                           pCDCSrc.bRam++;
0F0E  3001     MOVLW 0x1
0F0F  07D2     ADDWF pCDCSrc, F
0F10  3000     MOVLW 0x0
0F11  3DD3     ADDWFC 0x253, F
912:                           i--;
0F12  3001     MOVLW 0x1
0F13  0021     MOVLB 0x1
0F14  02E4     SUBWF ep, F
913:                       }
914:                   }
915:                   
916:                   /*
917:                    * Lastly, determine if a zero length packet state is necessary.
918:                    * See explanation in USB Specification 2.0: Section 5.8.3
919:                    */
920:                   if(cdc_tx_len == 0)
0F19  0023     MOVLB 0x3
0F1A  0857     MOVF cdc_tx_len, W
0F1B  1D03     BTFSS 0x183, 0x2
0F1C  2F2A     GOTO 0x72A
921:                   {
922:                       if(byte_to_send == CDC_DATA_IN_EP_SIZE)
0F1D  3040     MOVLW 0x40
0F1E  0021     MOVLB 0x1
0F1F  0665     XORWF byte_to_send, W
0F20  1D03     BTFSS 0x83, 0x2
0F21  2F24     GOTO 0x724
923:                           cdc_trf_state = CDC_TX_BUSY_ZLP;
0F22  3002     MOVLW 0x2
0F23  2F26     GOTO 0x726
924:                       else
925:                           cdc_trf_state = CDC_TX_COMPLETING;
0F24  3003     MOVLW 0x3
0F25  0021     MOVLB 0x1
0F26  00E3     MOVWF len
0F27  0863     MOVF len, W
0F28  0023     MOVLB 0x3
0F29  00D5     MOVWF cdc_trf_state
926:                   }//end if(cdc_tx_len...)
927:                   CDCDataInHandle = USBTxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_tx,byte_to_send);
0F2A  01F2     CLRF 0x1F2
0F2B  0AF2     INCF 0x1F2, F
0F2C  30A0     MOVLW 0xA0
0F2D  00F3     MOVWF 0x1F3
0F2E  3000     MOVLW 0x0
0F2F  00F4     MOVWF 0x1F4
0F30  0021     MOVLB 0x1
0F31  0865     MOVF byte_to_send, W
0F32  00E3     MOVWF len
0F33  0863     MOVF len, W
0F34  00F5     MOVWF 0xF5
0F35  3002     MOVLW 0x2
0F36  318B     MOVLP 0xB
0F37  2315     CALL 0x315
0F38  0873     MOVF 0xF3, W
0F39  0023     MOVLB 0x3
0F3A  00B7     MOVWF 0x1B7
0F3B  0872     MOVF 0x1F2, W
0F3C  00B6     MOVWF CDCDataInHandle
928:           
929:               }//end if(cdc_tx_sate == CDC_TX_BUSY)
0F3D  0008     RETURN
930:               
931:               USBUnmaskInterrupts();
932:           }//end CDCTxService
933:           
934:           #endif //USB_USE_CDC
935:           
936:           /** EOF cdc.c ****************************************************************/
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/usb/core/usb_device.c  ------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <xc.h>
46:            
47:            #include <stdint.h>
48:            #include <stddef.h>
49:            #include <string.h>
50:            
51:            #include "usb_config.h"
52:            
53:            #include "usb.h"
54:            #include "usb_ch9.h"
55:            #include "usb_device.h"
56:            #include "usb_device_local.h"
57:            
58:            #ifndef uintptr_t
59:                #if  defined(__XC8__) || defined(__XC16__)
60:                    #define uintptr_t uint16_t
61:                #elif defined (__XC32__)
62:                    #define uintptr_t uint32_t
63:                #endif
64:            #endif
65:            
66:            #if defined(USB_USE_MSD)
67:                #include "usb_device_msd.h"
68:            #endif
69:            
70:            // *****************************************************************************
71:            // *****************************************************************************
72:            // Section: File Scope or Global Constants
73:            // *****************************************************************************
74:            // *****************************************************************************
75:            #if !defined(USE_USB_BUS_SENSE_IO)
76:                //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                //been properly defined elsewhere in the project.
79:                #undef USB_BUS_SENSE
80:                #define USB_BUS_SENSE 1
81:            #endif
82:            
83:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                #define _DTS_CHECKING_ENABLED 0
85:            #else
86:                #define _DTS_CHECKING_ENABLED _DTSEN
87:            #endif
88:            
89:            #if !defined(self_power)
90:                //Assume the application is always bus powered, unless self_power has been
91:                //defined elsewhere in the project
92:                #define self_power 0    //0 = bus powered
93:            #endif
94:            
95:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                //Assume the application only implements one configuration descriptor,
97:                //unless otherwise specified elsewhere in the project
98:                #define USB_MAX_NUM_CONFIG_DSC      1
99:            #endif
100:           
101:           #if defined(__XC8)
102:               //Suppress expected/harmless compiler warning message about unused RAM variables
103:               //and certain function pointer usage.
104:               //Certain variables and function pointers are not used if you don't use all
105:               //of the USB stack APIs.  However, these variables should not be
106:               //removed (since they are still used/needed in some applications, and this
107:               //is a common file shared by many projects, some of which rely on the "unused"
108:               //variables/function pointers).
109:               #pragma warning disable 1090
110:               #if __XC8_VERSION > 1300
111:                   #pragma warning disable 1471
112:               #endif
113:           #endif
114:           
115:           // *****************************************************************************
116:           // *****************************************************************************
117:           // Section: File Scope Data Types
118:           // *****************************************************************************
119:           // *****************************************************************************
120:           typedef union
121:           {
122:               uint8_t Val;
123:               struct __PACKED
124:               {
125:                   unsigned b0:1;
126:                   unsigned b1:1;
127:                   unsigned b2:1;
128:                   unsigned b3:1;
129:                   unsigned b4:1;
130:                   unsigned b5:1;
131:                   unsigned b6:1;
132:                   unsigned b7:1;
133:               } bits;
134:           } uint8_t_VAL, uint8_t_BITS;
135:           
136:           // *****************************************************************************
137:           // *****************************************************************************
138:           // Section: Variables
139:           // *****************************************************************************
140:           // *****************************************************************************
141:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:           USB_VOLATILE uint8_t USBActiveConfiguration;
143:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:           USB_VOLATILE uint8_t shortPacketStatus;
149:           USB_VOLATILE uint8_t controlTransferState;
150:           USB_VOLATILE IN_PIPE inPipes[1];
151:           USB_VOLATILE OUT_PIPE outPipes[1];
152:           USB_VOLATILE uint8_t *pDst;
153:           USB_VOLATILE bool RemoteWakeup;
154:           USB_VOLATILE bool USBBusIsSuspended;
155:           USB_VOLATILE USTAT_FIELDS USTATcopy;
156:           USB_VOLATILE uint8_t endpoint_number;
157:           USB_VOLATILE bool BothEP0OutUOWNsSet;
158:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:           volatile bool USBDeferStatusStagePacket;
162:           volatile bool USBStatusStageEnabledFlag1;
163:           volatile bool USBStatusStageEnabledFlag2;
164:           volatile bool USBDeferINDataStagePackets;
165:           volatile bool USBDeferOUTDataStagePackets;
166:           USB_VOLATILE uint32_t USB1msTickCount;
167:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:           
169:           /** USB FIXED LOCATION VARIABLES ***********************************/
170:           #if defined(COMPILER_MPLAB_C18)
171:               #pragma udata USB_BDT=USB_BDT_ADDRESS
172:           #endif
173:           
174:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:           
176:           /********************************************************************
177:            * EP0 Buffer Space
178:            *******************************************************************/
179:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:           
182:           /********************************************************************
183:            * non-EP0 Buffer Space
184:            *******************************************************************/
185:           #if defined(USB_USE_MSD)
186:               //Check if the MSD application specific USB endpoint buffer placement address 
187:               //macros have already been defined or not (ex: in a processor specific header)
188:               //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:               //must be at a certain address range on certain microcontrollers).
190:               #if !defined(MSD_CBW_ADDR_TAG)
191:                   //Not previously defined.  Assume in this case all microcontroller RAM is
192:                   //USB module accessible, and therefore, no specific address tag value is needed.
193:                   #define MSD_CBW_ADDR_TAG
194:                   #define MSD_CSW_ADDR_TAG
195:               #endif
196:           	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:           	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:           
199:               #if defined(__18CXX) || defined(__XC8)
200:                   volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
201:               #else
202:                   volatile char msd_buffer[512];
203:           	#endif
204:           #endif
205:           
206:           //Depricated in v2.2 - will be removed in a future revision
207:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
208:               //Device descriptor
209:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
210:           #else
211:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
212:           #endif
213:           
214:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
215:               //Array of configuration descriptors
216:               extern const uint8_t *const USB_CD_Ptr[];
217:           #else
218:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
219:           #endif
220:           
221:           extern const uint8_t *const USB_SD_Ptr[];
222:           
223:           
224:           // *****************************************************************************
225:           // *****************************************************************************
226:           // Section: Private and External Prototypes
227:           // *****************************************************************************
228:           // *****************************************************************************
229:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
230:           
231:           static void USBCtrlEPService(void);
232:           static void USBCtrlTrfSetupHandler(void);
233:           static void USBCtrlTrfInHandler(void);
234:           static void USBCheckStdRequest(void);
235:           static void USBStdGetDscHandler(void);
236:           static void USBCtrlEPServiceComplete(void);
237:           static void USBCtrlTrfTxService(void);
238:           static void USBCtrlTrfRxService(void);
239:           static void USBStdSetCfgHandler(void);
240:           static void USBStdGetStatusHandler(void);
241:           static void USBStdFeatureReqHandler(void);
242:           static void USBCtrlTrfOutHandler(void);
243:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
244:           static void USBWakeFromSuspend(void);
245:           static void USBSuspend(void);
246:           static void USBStallHandler(void);
247:           
248:           // *****************************************************************************
249:           // *****************************************************************************
250:           // Section: Macros or Functions
251:           // *****************************************************************************
252:           // *****************************************************************************
253:           
254:           /**************************************************************************
255:               Function:
256:                   void USBDeviceInit(void)
257:               
258:               Description:
259:                   This function initializes the device stack it in the default state. The
260:                   USB module will be completely reset including all of the internal
261:                   variables, registers, and interrupt flags.
262:                           
263:               Precondition:
264:                   This function must be called before any of the other USB Device
265:                   functions can be called, including USBDeviceTasks().
266:                   
267:               Parameters:
268:                   None
269:                
270:               Return Values:
271:                   None
272:                   
273:               Remarks:
274:                   None
275:                                                                     
276:             ***************************************************************************/
277:           void USBDeviceInit(void)
278:           {
279:               uint8_t i;
280:           
281:               USBDisableInterrupts();
0DD8  0021     MOVLB 0x1
0DD9  1112     BCF PIE2, 0x2
282:           
283:               //Make sure that if a GPIO output driver exists on VBUS, that it is 
284:               //tri-stated to avoid potential contention with the host
285:               USB_HAL_VBUSTristate();
286:               
287:               // Clear all USB error flags
288:               USBClearInterruptRegister(U1EIR);  
0DDA  003D     MOVLB 0x1D
0DDB  0193     CLRF UEIR
289:                  
290:               // Clears all USB interrupts          
291:               USBClearInterruptRegister(U1IR); 
0DDC  0190     CLRF UIR
292:           
293:               //Clear all of the endpoint control registers
294:               U1EP0 = 0;
0DDD  0198     CLRF UEP0
295:               
296:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0DDE  300E     MOVLW 0xE
0DDF  00F4     MOVWF 0xEF4
0DE0  3099     MOVLW 0x99
0DE1  00F3     MOVWF 0xEF3
0DE2  01F5     CLRF 0xEF5
0DE3  3004     MOVLW 0x4
0DE4  0275     SUBWF 0xEF5, W
0DE5  1803     BTFSC 0xE83, 0x0
0DE6  2DF8     GOTO 0x5F8
0DE7  0873     MOVF 0xEF3, W
0DE8  0086     MOVWF 0xE86
0DE9  0874     MOVF 0xEF4, W
0DEA  0087     MOVWF 0xE87
0DEB  0181     CLRF 0xE81
0DEC  3001     MOVLW 0x1
0DED  07F3     ADDWF 0xEF3, F
0DEE  3000     MOVLW 0x0
0DEF  3DF4     ADDWFC 0xEF4, F
0DF0  3001     MOVLW 0x1
0DF1  00F2     MOVWF 0xEF2
0DF2  0872     MOVF 0xEF2, W
0DF3  07F5     ADDWF 0xEF5, F
0DF4  3004     MOVLW 0x4
0DF5  0275     SUBWF 0xEF5, W
0DF6  1C03     BTFSS 0xE83, 0x0
0DF7  2DE7     GOTO 0x5E7
297:           
298:               SetConfigurationOptions();
0DF8  3016     MOVLW 0x16
0DF9  003D     MOVLB 0x1D
0DFA  0091     MOVWF UCFG
0DFB  309F     MOVLW 0x9F
0DFC  0097     MOVWF UEIE
0DFD  307B     MOVLW 0x7B
0DFE  0092     MOVWF UIE
299:           
300:               //power up the module (if not already powered)
301:               USBPowerModule();
302:           
303:               //set the address of the BDT (if applicable)
304:               USBSetBDTAddress(BDT);
305:           
306:               //Clear all of the BDT entries
307:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
0DFF  01F6     CLRF 0xEF6
0E00  3014     MOVLW 0x14
0E01  0276     SUBWF 0xEF6, W
0E02  1803     BTFSC 0xE83, 0x0
0E03  2E1D     GOTO 0x61D
0E15  3001     MOVLW 0x1
0E16  00F2     MOVWF 0xEF2
0E17  0872     MOVF 0xEF2, W
0E18  07F6     ADDWF 0xEF6, F
0E19  3014     MOVLW 0x14
0E1A  0276     SUBWF 0xEF6, W
0E1B  1C03     BTFSS 0xE83, 0x0
0E1C  2E04     GOTO 0x604
308:               {
309:                   BDT[i].Val = 0x00;
0E04  0876     MOVF 0xEF6, W
0E05  00F2     MOVWF 0xEF2
0E06  3001     MOVLW 0x1
0E07  35F2     LSLF 0xEF2, F
0E08  3EFF     ADDLW 0xFF
0E09  1D03     BTFSS 0xE83, 0x2
0E0A  2E07     GOTO 0x607
0E0B  3572     LSLF 0xEF2, W
0E0C  3E20     ADDLW 0x20
0E0D  0086     MOVWF 0xE86
0E0E  0187     CLRF 0xE87
0E0F  3000     MOVLW 0x0
0E10  3FC0     MOVWI [0]FSR1
0E11  3000     MOVLW 0x0
0E12  3FC1     MOVWI [1]FSR1
0E13  3FC2     MOVWI [2]FSR1
0E14  3FC3     MOVWI [3]FSR1
310:               }
311:           
312:               // Assert reset request to all of the Ping Pong buffer pointers
313:               USBPingPongBufferReset = 1;                    
0E1D  003D     MOVLB 0x1D
0E1E  170E     BSF UCON, 0x6
314:           
315:               // Reset to default address
316:               U1ADDR = 0x00;                   
0E1F  0196     CLRF UADDR
317:           
318:               // Make sure packet processing is enabled
319:               USBPacketDisable = 0;           
0E20  120E     BCF UCON, 0x4
320:           
321:               //Stop trying to reset ping pong buffer pointers
322:               USBPingPongBufferReset = 0;
0E21  130E     BCF UCON, 0x6
323:           
324:               // Flush any pending transactions
325:               do
326:               {
327:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0E22  30F7     MOVLW 0xF7
0E23  00F2     MOVWF 0xEF2
0E24  0872     MOVF 0xEF2, W
0E25  0590     ANDWF UIR, F
328:                   //Initialize USB stack software state variables
329:                   inPipes[0].info.Val = 0;
0E26  0023     MOVLB 0x3
0E27  01B3     CLRF 0x1B3
330:                   outPipes[0].info.Val = 0;
0E28  01AC     CLRF 0x1AC
331:                   outPipes[0].wCount.Val = 0;
0E29  01AD     CLRF 0x1AD
0E2A  01AE     CLRF 0x1AE
332:               }while(USBTransactionCompleteIF == 1);
0E2B  003D     MOVLB 0x1D
0E2C  1990     BTFSC UIR, 0x3
0E2D  2E22     GOTO 0x622
333:           
334:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
335:               //try and arm a status stage, even before the first control transfer starts.
336:               USBStatusStageEnabledFlag1 = true;
0E2E  3001     MOVLW 0x1
0E2F  00F2     MOVWF 0xEF2
0E30  0872     MOVF 0xEF2, W
0E31  0023     MOVLB 0x3
0E32  00CD     MOVWF USBStatusStageEnabledFlag1
337:               USBStatusStageEnabledFlag2 = true;
0E33  3001     MOVLW 0x1
0E34  00F2     MOVWF 0x1F2
0E35  0872     MOVF 0x1F2, W
0E36  00CE     MOVWF USBStatusStageEnabledFlag2
338:               //Initialize other flags
339:               USBDeferINDataStagePackets = false;
0E37  01C9     CLRF USBDeferINDataStagePackets
340:               USBDeferOUTDataStagePackets = false;
0E38  01CA     CLRF USBDeferOUTDataStagePackets
341:               USBBusIsSuspended = false;
0E39  01C8     CLRF USBBusIsSuspended
342:           
343:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
344:               //pointers to NULL, so they don't get used inadvertently.
345:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0E3A  01F6     CLRF 0x1F6
0E3B  3005     MOVLW 0x5
0E3C  0276     SUBWF 0x1F6, W
0E3D  1803     BTFSC 0x183, 0x0
0E3E  2E63     GOTO 0x663
0E5B  3001     MOVLW 0x1
0E5C  00F2     MOVWF 0x1F2
0E5D  0872     MOVF 0x1F2, W
0E5E  07F6     ADDWF 0x1F6, F
0E5F  3005     MOVLW 0x5
0E60  0276     SUBWF 0x1F6, W
0E61  1C03     BTFSS 0x183, 0x0
0E62  2E3F     GOTO 0x63F
346:               {
347:                   pBDTEntryIn[i] = 0u;
0E3F  3576     LSLF 0x1F6, W
0E40  3EA0     ADDLW 0xA0
0E41  0086     MOVWF 0x186
0E42  3001     MOVLW 0x1
0E43  0087     MOVWF 0x187
0E44  3000     MOVLW 0x0
0E45  3FC0     MOVWI [0]FSR1
0E46  3FC1     MOVWI [1]FSR1
348:                   pBDTEntryOut[i] = 0u;
0E47  3576     LSLF 0x1F6, W
0E48  3E20     ADDLW 0x20
0E49  0086     MOVWF 0x186
0E4A  3002     MOVLW 0x2
0E4B  0087     MOVWF 0x187
0E4C  3000     MOVLW 0x0
0E4D  3FC0     MOVWI [0]FSR1
0E4E  3FC1     MOVWI [1]FSR1
349:                   ep_data_in[i].Val = 0u;
0E4F  0876     MOVF 0x1F6, W
0E50  3E2A     ADDLW 0x2A
0E51  0086     MOVWF 0x186
0E52  3002     MOVLW 0x2
0E53  0087     MOVWF 0x187
0E54  0181     CLRF 0x181
350:                   ep_data_out[i].Val = 0u;
0E55  0876     MOVF 0x1F6, W
0E56  3E2F     ADDLW 0x2F
0E57  0086     MOVWF 0x186
0E58  3002     MOVLW 0x2
0E59  0087     MOVWF 0x187
0E5A  0181     CLRF 0x181
351:               }
352:           
353:               //Get ready for the first packet
354:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0E63  3028     MOVLW 0x28
0E64  0023     MOVLB 0x3
0E65  00A0     MOVWF pBDTEntryIn
0E66  3000     MOVLW 0x0
0E67  00A1     MOVWF 0x1A1
355:               // Initialize EP0 as a Ctrl EP
356:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
0E68  3016     MOVLW 0x16
0E69  003D     MOVLB 0x1D
0E6A  0098     MOVWF UEP0
357:           	//Prepare for the first SETUP on EP0 OUT
358:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0E6B  3000     MOVLW 0x0
0E6C  0020     MOVLB 0x0
0E6D  00A3     MOVWF 0x23
0E6E  30A0     MOVLW 0xA0
0E6F  00A2     MOVWF 0x22
359:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0E70  3008     MOVLW 0x8
0E71  00A1     MOVWF 0x21
360:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
0E72  3004     MOVLW 0x4
0E73  00F2     MOVWF multiplier
0E74  0872     MOVF multiplier, W
0E75  00A0     MOVWF BDT
361:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
0E76  17A0     BSF BDT, 0x7
362:           
363:               // Clear active configuration
364:               USBActiveConfiguration = 0;     
0E77  0023     MOVLB 0x3
0E78  01E7     CLRF USBActiveConfiguration
365:           
366:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
0E79  3000     MOVLW 0x0
0E7A  0024     MOVLB 0x4
0E7B  00BF     MOVWF 0x23F
0E7C  3000     MOVLW 0x0
0E7D  00BE     MOVWF 0x23E
0E7E  3000     MOVLW 0x0
0E7F  00BD     MOVWF 0x23D
0E80  3000     MOVLW 0x0
0E81  00BC     MOVWF USB1msTickCount
367:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
0E82  0023     MOVLB 0x3
0E83  01D0     CLRF USBTicksSinceSuspendEnd
368:           
369:               //Indicate that we are now in the detached state
370:               USBDeviceState = DETACHED_STATE;
0E84  01CC     CLRF USBDeviceState
371:           }
0E85  0008     RETURN
372:           
373:           
374:           
375:           /**************************************************************************
376:             Function:
377:                   void USBDeviceTasks(void)
378:               
379:             Summary:
380:               This function is the main state machine/transaction handler of the USB 
381:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
382:               (usb_config.h user option) the USBDeviceTasks() function should be called 
383:               periodically to receive and transmit packets through the stack. This 
384:               function also takes care of control transfers associated with the USB 
385:               enumeration process, and detecting various USB events (such as suspend).  
386:               This function should be called at least once every 1.8ms during the USB 
387:               enumeration process. After the enumeration process is complete (which can 
388:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
389:               USBDeviceTasks() handler may be called the faster of: either once 
390:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
391:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
392:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
393:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
394:               near the top of usb_device.c for more details about minimum timing 
395:               requirements when calling USBDeviceTasks().
396:               
397:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
398:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
399:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
400:               interrupt occurs, and therefore only needs to be called from the interrupt 
401:               context.
402:           
403:             Description:
404:               This function is the main state machine/transaction handler of the USB 
405:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
406:               (usb_config.h user option) the USBDeviceTasks() function should be called 
407:               periodically to receive and transmit packets through the stack. This 
408:               function also takes care of control transfers associated with the USB 
409:               enumeration process, and detecting various USB events (such as suspend).  
410:               This function should be called at least once every 1.8ms during the USB 
411:               enumeration process. After the enumeration process is complete (which can 
412:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
413:               USBDeviceTasks() handler may be called the faster of: either once 
414:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
415:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
416:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
417:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
418:               near the top of usb_device.c for more details about minimum timing 
419:               requirements when calling USBDeviceTasks().
420:               
421:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
422:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
423:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
424:               interrupt occurs, and therefore only needs to be called from the interrupt 
425:               context.
426:           
427:               Typical usage:
428:               <code>
429:               void main(void)
430:               {
431:                   USBDeviceInit();
432:                   while(1)
433:                   {
434:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
435:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
436:                          (USBIsDeviceSuspended() == true))
437:                       {
438:                           //Either the device is not configured or we are suspended,
439:                           // so we don't want to execute any USB related application code
440:                           continue;   //go back to the top of the while loop
441:                       }
442:                       else
443:                       {
444:                           //Otherwise we are free to run USB and non-USB related user 
445:                           //application code.
446:                           UserApplication();
447:                       }
448:                   }
449:               }
450:               </code>
451:           
452:             Precondition:
453:               Make sure the USBDeviceInit() function has been called prior to calling
454:               USBDeviceTasks() for the first time.
455:             Remarks:
456:               USBDeviceTasks() does not need to be called while in the USB suspend mode, 
457:               if the user application firmware in the USBCBSuspend() callback function
458:               enables the ACTVIF USB interrupt source and put the microcontroller into 
459:               sleep mode.  If the application firmware decides not to sleep the 
460:               microcontroller core during USB suspend (ex: continues running at full 
461:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
462:               function must still be called periodically, at a rate frequent enough to 
463:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
464:               a worst case primary oscillator and PLL start up time of less than 5ms, then
465:               USBDeviceTasks() should be called once every 5ms in this scenario.
466:              
467:               When the USB cable is detached, or the USB host is not actively powering 
468:               the VBUS line to +5V nominal, the application firmware does not always have 
469:               to call USBDeviceTasks() frequently, as no USB activity will be taking 
470:               place.  However, if USBDeviceTasks() is not called regularly, some 
471:               alternative means of promptly detecting when VBUS is powered (indicating 
472:               host attachment), or not powered (host powered down or USB cable unplugged)
473:               is still needed.  For self or dual self/bus powered USB applications, see 
474:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
475:               considerations.
476:               ***************************************************************************/
477:           void USBDeviceTasks(void)
478:           {
479:               uint8_t i;
480:           
481:               #ifdef USB_SUPPORT_OTG
482:                   //SRP Time Out Check
483:                   if (USBOTGSRPIsReady())
484:                   {
485:                       if (USBT1MSECIF && USBT1MSECIE)
486:                       {
487:                           if (USBOTGGetSRPTimeOutFlag())
488:                           {
489:                               if (USBOTGIsSRPTimeOutExpired())
490:                               {
491:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
492:                               }
493:                           }
494:           
495:                           //Clear Interrupt Flag
496:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
497:                       }
498:                   }
499:               #endif
500:           
501:               #if defined(USB_POLLING)
502:               //If the interrupt option is selected then the customer is required
503:               //  to notify the stack when the device is attached or removed from the
504:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
505:               if (USB_BUS_SENSE != 1)
506:               {
507:                    // Disable module & detach from bus
508:                    U1CON = 0;             
509:           
510:                    // Mask all USB interrupts              
511:                    U1IE = 0;          
512:           
513:                    //Move to the detached state                  
514:                    USBDeviceState = DETACHED_STATE;
515:           
516:                    #ifdef  USB_SUPPORT_OTG    
517:                        //Disable D+ Pullup
518:                        U1OTGCONbits.DPPULUP = 0;
519:           
520:                        //Disable HNP
521:                        USBOTGDisableHnp();
522:           
523:                        //Deactivate HNP
524:                        USBOTGDeactivateHnp();
525:                        
526:                        //If ID Pin Changed State
527:                        if (USBIDIF && USBIDIE)
528:                        {  
529:                            //Re-detect & Initialize
530:                             USBOTGInitialize();
531:           
532:                             //Clear ID Interrupt Flag
533:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
534:                        }
535:                    #endif
536:           
537:                    #if defined __C30__ || defined __XC16__
538:                        //USBClearInterruptFlag(U1OTGIR, 3); 
539:                    #endif
540:                       //return so that we don't go through the rest of 
541:                       //the state machine
542:                    USBClearUSBInterrupt();
543:                    return;
544:               }
545:           
546:           	#ifdef USB_SUPPORT_OTG
547:               //If Session Is Started Then
548:               else
549:           	{
550:                   //If SRP Is Ready
551:                   if (USBOTGSRPIsReady())
552:                   {   
553:                       //Clear SRPReady
554:                       USBOTGClearSRPReady();
555:           
556:                       //Clear SRP Timeout Flag
557:                       USBOTGClearSRPTimeOutFlag();
558:           
559:                       //Indicate Session Started
560:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
561:                   }
562:               }
563:           	#endif	//#ifdef USB_SUPPORT_OTG
564:           
565:               //if we are in the detached state
566:               if(USBDeviceState == DETACHED_STATE)
066F  0023     MOVLB 0x3
0670  084C     MOVF USBDeviceState, W
0671  1D03     BTFSS 0x183, 0x2
0672  2E83     GOTO 0x683
567:               {
568:           	    //Initialize register to known value
569:                   U1CON = 0;                          
0673  003D     MOVLB 0x1D
0674  018E     CLRF UCON
570:           
571:                   // Mask all USB interrupts
572:                   U1IE = 0;                                
0675  0192     CLRF UIE
573:           
574:                   //Enable/set things like: pull ups, full/low-speed mode, 
575:                   //set the ping pong mode, and set internal transceiver
576:                   SetConfigurationOptions();
0676  3016     MOVLW 0x16
0677  0091     MOVWF UCFG
0678  309F     MOVLW 0x9F
0679  0097     MOVWF UEIE
067A  307B     MOVLW 0x7B
067B  0092     MOVWF UIE
577:           
578:                   // Enable module & attach to bus
579:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
067C  198E     BTFSC UCON, 0x3
067D  2E80     GOTO 0x680
067E  158E     BSF UCON, 0x3
067F  2E7C     GOTO 0x67C
580:           
581:                   //moved to the attached state
582:                   USBDeviceState = ATTACHED_STATE;
0680  0023     MOVLB 0x3
0681  01CC     CLRF USBDeviceState
0682  0ACC     INCF USBDeviceState, F
583:           
584:                   #ifdef  USB_SUPPORT_OTG
585:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
586:                   #endif
587:               }
588:           	#endif  //#if defined(USB_POLLING)
589:           
590:               if(USBDeviceState == ATTACHED_STATE)
0683  034C     DECF USBDeviceState, W
0684  1D03     BTFSS 0x183, 0x2
0685  2E92     GOTO 0x692
591:               {
592:                   /*
593:                    * After enabling the USB module, it takes some time for the
594:                    * voltage on the D+ or D- line to rise high enough to get out
595:                    * of the SE0 condition. The USB Reset interrupt should not be
596:                    * unmasked until the SE0 condition is cleared. This helps
597:                    * prevent the firmware from misinterpreting this unique event
598:                    * as a USB bus reset from the USB host.
599:                    */
600:           
601:                   if(!USBSE0Event)
0686  003D     MOVLB 0x1D
0687  1A8E     BTFSC UCON, 0x5
0688  2E92     GOTO 0x692
602:                   {
603:                       //We recently attached, make sure we are in a clean state
604:                       #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
605:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
606:                                           //during attach de-bounce interval
607:                       #else
608:                           USBClearInterruptRegister(U1IR);
0689  0190     CLRF UIR
609:                       #endif
610:           
611:                       #if defined(USB_POLLING)
612:                           U1IE=0;                        // Mask all USB interrupts
068A  0192     CLRF UIE
613:                       #endif
614:                       USBResetIE = 1;             // Unmask RESET interrupt
068B  1412     BSF UIE, 0x0
615:                       USBIdleIE = 1;             // Unmask IDLE interrupt
068C  1612     BSF UIE, 0x4
616:                       USBDeviceState = POWERED_STATE;
068D  3002     MOVLW 0x2
068E  0023     MOVLB 0x3
068F  00EE     MOVWF 0x1EE
0690  086E     MOVF 0x1EE, W
0691  00CC     MOVWF USBDeviceState
617:                   }
618:               }
619:           
620:               #ifdef  USB_SUPPORT_OTG
621:                   //If ID Pin Changed State
622:                   if (USBIDIF && USBIDIE)
623:                   {  
624:                       //Re-detect & Initialize
625:                       USBOTGInitialize();
626:           
627:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
628:                   }
629:               #endif
630:           
631:               /*
632:                * Task A: Service USB Activity Interrupt
633:                */
634:               if(USBActivityIF && USBActivityIE)
0692  003D     MOVLB 0x1D
0693  1910     BTFSC UIR, 0x2
0694  1D12     BTFSS UIE, 0x2
0695  2E9F     GOTO 0x69F
635:               {
636:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0696  30FB     MOVLW 0xFB
0697  0023     MOVLB 0x3
0698  00EE     MOVWF 0x1EE
0699  086E     MOVF 0x1EE, W
069A  003D     MOVLB 0x1D
069B  0590     ANDWF UIR, F
637:                   #if defined(USB_SUPPORT_OTG)
638:                       U1OTGIR = 0x10;        
639:                   #else
640:                       USBWakeFromSuspend();
069C  3192     MOVLP 0x12
069D  22F3     CALL 0x2F3
069E  3186     MOVLP 0x6
641:                   #endif
642:               }
643:           
644:               /*
645:                * Pointless to continue servicing if the device is in suspend mode.
646:                */
647:               if(USBSuspendControl==1)
069F  003D     MOVLB 0x1D
06A0  1C8E     BTFSS UCON, 0x1
06A1  2EA5     GOTO 0x6A5
648:               {
649:                   USBClearUSBInterrupt();
06A2  0020     MOVLB 0x0
06A3  1112     BCF PIR2, 0x2
650:                   return;
06A4  0008     RETURN
651:               }
652:           
653:               /*
654:                * Task B: Service USB Bus Reset Interrupt.
655:                * When bus reset is received during suspend, ACTVIF will be set first,
656:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
657:                * This is why URSTIF is checked after ACTVIF.
658:                *
659:                * The USB reset flag is masked when the USB state is in
660:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
661:                * cause a USB reset event during these two states.
662:                */
663:               if(USBResetIF && USBResetIE)
06A5  1810     BTFSC 0x10, 0x0
06A6  1C12     BTFSS PIR2, 0x0
06A7  2EB5     GOTO 0x6B5
664:               {
665:                   USBDeviceInit();
06A8  318D     MOVLP 0xD
06A9  25D8     CALL 0x5D8
06AA  3186     MOVLP 0x6
666:           
667:                   //Re-enable the interrupts since the USBDeviceInit() function will
668:                   //  disable them.  This will do nothing in a polling setup
669:                   USBUnmaskInterrupts();
670:           
671:                   USBDeviceState = DEFAULT_STATE;
06AB  3004     MOVLW 0x4
06AC  0023     MOVLB 0x3
06AD  00EE     MOVWF 0x1EE
06AE  086E     MOVF 0x1EE, W
06AF  00CC     MOVWF USBDeviceState
672:           
673:                   #ifdef USB_SUPPORT_OTG
674:                        //Disable HNP
675:                        USBOTGDisableHnp();
676:           
677:                        //Deactivate HNP
678:                        USBOTGDeactivateHnp();
679:                   #endif
680:           
681:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
06B0  30FE     MOVLW 0xFE
06B1  00EE     MOVWF 0x1EE
06B2  086E     MOVF 0x1EE, W
06B3  003D     MOVLB 0x1D
06B4  0590     ANDWF UIR, F
682:               }
683:           
684:               /*
685:                * Task C: Service other USB interrupts
686:                */
687:               if(USBIdleIF && USBIdleIE)
06B5  1A10     BTFSC UIR, 0x4
06B6  1E12     BTFSS UIE, 0x4
06B7  2EBB     GOTO 0x6BB
688:               { 
689:                   #ifdef  USB_SUPPORT_OTG 
690:                       //If Suspended, Try to switch to Host
691:                       USBOTGSelectRole(ROLE_HOST);
692:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
693:                   #else
694:                       USBSuspend();
06B8  3192     MOVLP 0x12
06B9  22D7     CALL 0x2D7
06BA  3186     MOVLP 0x6
695:                   #endif
696:               }
697:           
698:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
699:                   //Check if a 1ms interval has elapsed.	
700:                   if(USBT1MSECIF)
701:                   {
702:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
703:                       USBIncrement1msInternalTimers();
704:                   }
705:               #endif
706:           
707:               //Start-of-Frame Interrupt
708:               if(USBSOFIF)
06BB  003D     MOVLB 0x1D
06BC  1F10     BTFSS UIR, 0x6
06BD  2EE5     GOTO 0x6E5
709:               {
710:                   //Call the user SOF event callback if enabled.
711:                   if(USBSOFIE)
06BE  1F12     BTFSS UIE, 0x6
06BF  2ED0     GOTO 0x6D0
712:                   {
713:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
06C0  3073     MOVLW 0x73
06C1  0021     MOVLB 0x1
06C2  00E6     MOVWF buffer
06C3  3000     MOVLW 0x0
06C4  00E7     MOVWF 0xE7
06C5  3000     MOVLW 0x0
06C6  00E8     MOVWF dividend
06C7  3000     MOVLW 0x0
06C8  00E9     MOVWF 0xE9
06C9  3001     MOVLW 0x1
06CA  00EA     MOVWF strIncremet
06CB  3000     MOVLW 0x0
06CC  00EB     MOVWF str
06CD  3194     MOVLP 0x14
06CE  2481     CALL 0x481
06CF  3186     MOVLP 0x6
714:                   }    
715:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
06D0  30BF     MOVLW 0xBF
06D1  0023     MOVLB 0x3
06D2  00EE     MOVWF 0x1EE
06D3  086E     MOVF 0x1EE, W
06D4  003D     MOVLB 0x1D
06D5  0590     ANDWF UIR, F
716:           
717:                   #if defined(__XC8__) || defined(__C18__)
718:                       USBIncrement1msInternalTimers();
06D6  3192     MOVLP 0x12
06D7  2288     CALL 0x288
06D8  3186     MOVLP 0x6
719:                   #endif
720:           
721:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
722:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
723:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
724:                           #warning "Double click this message.  See inline code comments."
725:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
726:                           //not strictly needed in all applications (ex: those that never call 
727:                           //USBDeferStatusStage() and don't use host to device (OUT) control
728:                           //transfers with data stage).  
729:                           //However, if this feature is enabled and used in a low speed application,
730:                           //it is required for the application code to periodically call the
731:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
732:                       #endif
733:                       
734:                       //Decrement our status stage counter.
735:                       if(USBStatusStageTimeoutCounter != 0u)
06D9  0023     MOVLB 0x3
06DA  084F     MOVF USBStatusStageTimeoutCounter, W
06DB  1903     BTFSC 0x183, 0x2
06DC  2EDF     GOTO 0x6DF
736:                       {
737:                           USBStatusStageTimeoutCounter--;
06DD  3001     MOVLW 0x1
06DE  02CF     SUBWF USBStatusStageTimeoutCounter, F
738:                       }
739:                       //Check if too much time has elapsed since progress was made in 
740:                       //processing the control transfer, without arming the status stage.  
741:                       //If so, auto-arm the status stage to ensure that the control 
742:                       //transfer can [eventually] complete, within the timing limits
743:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
744:                       if(USBStatusStageTimeoutCounter == 0)
06DF  084F     MOVF USBStatusStageTimeoutCounter, W
06E0  1D03     BTFSS 0x183, 0x2
06E1  2EE5     GOTO 0x6E5
745:                       {
746:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
06E2  3189     MOVLP 0x9
06E3  213E     CALL 0x13E
06E4  3186     MOVLP 0x6
747:                       } 
748:                   #endif
749:               }
750:           
751:               if(USBStallIF && USBStallIE)
06E5  003D     MOVLB 0x1D
06E6  1A90     BTFSC UIR, 0x5
06E7  1E92     BTFSS UIE, 0x5
06E8  2EEC     GOTO 0x6EC
752:               {
753:                   USBStallHandler();
06E9  3193     MOVLP 0x13
06EA  235A     CALL 0x35A
06EB  3186     MOVLP 0x6
754:               }
755:           
756:               if(USBErrorIF && USBErrorIE)
06EC  003D     MOVLB 0x1D
06ED  1890     BTFSC UIR, 0x1
06EE  1C92     BTFSS UIE, 0x1
06EF  2F02     GOTO 0x702
757:               {
758:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
06F0  30FF     MOVLW 0xFF
06F1  0021     MOVLB 0x1
06F2  00E6     MOVWF buffer
06F3  307F     MOVLW 0x7F
06F4  00E7     MOVWF 0xE7
06F5  3000     MOVLW 0x0
06F6  00E8     MOVWF dividend
06F7  3000     MOVLW 0x0
06F8  00E9     MOVWF 0xE9
06F9  3001     MOVLW 0x1
06FA  00EA     MOVWF strIncremet
06FB  3000     MOVLW 0x0
06FC  00EB     MOVWF str
06FD  3194     MOVLP 0x14
06FE  2481     CALL 0x481
06FF  3186     MOVLP 0x6
759:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
0700  003D     MOVLB 0x1D
0701  0193     CLRF UEIR
760:           
761:                   //On PIC18, clearing the source of the error will automatically clear
762:                   //  the interrupt flag.  On other devices the interrupt flag must be 
763:                   //  manually cleared. 
764:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
765:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
766:                   #endif
767:               }
768:           
769:               /*
770:                * Pointless to continue servicing if the host has not sent a bus reset.
771:                * Once bus reset is received, the device transitions into the DEFAULT
772:                * state and is ready for communication.
773:                */
774:               if(USBDeviceState < DEFAULT_STATE)
0702  3004     MOVLW 0x4
0703  0023     MOVLB 0x3
0704  024C     SUBWF USBDeviceState, W
0705  1803     BTFSC 0x183, 0x0
0706  2F0A     GOTO 0x70A
775:               {
776:                   USBClearUSBInterrupt();
0707  0020     MOVLB 0x0
0708  1112     BCF PIR2, 0x2
777:                   return;
0709  0008     RETURN
778:               }  
779:           
780:               /*
781:                * Task D: Servicing USB Transaction Complete Interrupt
782:                */
783:               if(USBTransactionCompleteIE)
070A  003D     MOVLB 0x1D
070B  1D92     BTFSS UIE, 0x3
070C  2F5D     GOTO 0x75D
784:               {
785:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
070D  0022     MOVLB 0x2
070E  01EF     CLRF i
070F  3004     MOVLW 0x4
0710  026F     SUBWF i, W
0711  1803     BTFSC 0x103, 0x0
0712  2F5D     GOTO 0x75D
0753  3001     MOVLW 0x1
0754  0023     MOVLB 0x3
0755  00EE     MOVWF 0x1EE
0756  086E     MOVF 0x1EE, W
0757  0022     MOVLB 0x2
0758  07EF     ADDWF i, F
0759  3004     MOVLW 0x4
075A  026F     SUBWF i, W
075B  1C03     BTFSS 0x103, 0x0
075C  2F13     GOTO 0x713
786:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
787:                       if(USBTransactionCompleteIF)
0713  003D     MOVLB 0x1D
0714  1D90     BTFSS UIR, 0x3
0715  2F5D     GOTO 0x75D
788:                       {
789:                           //Save and extract USTAT register info.  Will use this info later.
790:                           USTATcopy.Val = U1STAT;
0716  080F     MOVF USTAT, W
0717  0023     MOVLB 0x3
0718  00EE     MOVWF 0x1EE
0719  086E     MOVF 0x1EE, W
071A  00E8     MOVWF USTATcopy
791:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
071B  0C68     RRF USTATcopy, W
071C  00EE     MOVWF 0x1EE
071D  0CEE     RRF 0x1EE, F
071E  0C6E     RRF 0x1EE, W
071F  390F     ANDLW 0xF
0720  00EF     MOVWF 0x1EF
0721  086F     MOVF 0x1EF, W
0722  00DB     MOVWF endpoint_number
792:           
793:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0723  30F7     MOVLW 0xF7
0724  00EE     MOVWF 0x1EE
0725  086E     MOVF 0x1EE, W
0726  003D     MOVLB 0x1D
0727  0590     ANDWF UIR, F
794:           
795:                           //Keep track of the hardware ping pong state for endpoints other
796:                           //than EP0, if ping pong buffering is enabled.
797:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
798:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
0728  0023     MOVLB 0x3
0729  1968     BTFSC USTATcopy, 0x2
072A  2F2E     GOTO 0x72E
799:                           {
800:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
072B  085B     MOVF endpoint_number, W
072C  3E2F     ADDLW 0x2F
072D  2F30     GOTO 0x730
801:                           }
802:                           else
803:                           {
804:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
072E  085B     MOVF endpoint_number, W
072F  3E2A     ADDLW 0x2A
0730  0086     MOVWF 0x186
0731  3002     MOVLW 0x2
0732  0087     MOVWF 0x187
0733  0801     MOVF 0x181, W
0734  3901     ANDLW 0x1
0735  00EE     MOVWF 0x1EE
0736  3001     MOVLW 0x1
0737  06EE     XORWF 0x1EE, F
0738  0801     MOVF 0x181, W
0739  066E     XORWF 0x1EE, W
073A  39FE     ANDLW 0xFE
073B  066E     XORWF 0x1EE, W
073C  0081     MOVWF 0x181
805:                           }
806:                           #endif
807:           
808:                           //USBCtrlEPService only services transactions over EP0.
809:                           //It ignores all other EP transactions.
810:                           if(endpoint_number == 0)
073D  085B     MOVF endpoint_number, W
073E  1D03     BTFSS 0x183, 0x2
073F  2F44     GOTO 0x744
811:                           {
812:                               USBCtrlEPService();
0740  3195     MOVLP 0x15
0741  2592     CALL 0x592
0742  3186     MOVLP 0x6
813:                           }
0743  2F53     GOTO 0x753
814:                           else
815:                           {
816:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
0744  3072     MOVLW 0x72
0745  0021     MOVLB 0x1
0746  00E6     MOVWF buffer
0747  3000     MOVLW 0x0
0748  00E7     MOVWF 0xE7
0749  30E8     MOVLW 0xE8
074A  00E8     MOVWF dividend
074B  3001     MOVLW 0x1
074C  00E9     MOVWF 0xE9
074D  3000     MOVLW 0x0
074E  00EA     MOVWF strIncremet
074F  00EB     MOVWF str
0750  3194     MOVLP 0x14
0751  2481     CALL 0x481
0752  3186     MOVLP 0x6
817:                           }
818:                       }//end if(USBTransactionCompleteIF)
819:                       else
820:                       {
821:                           break;	//USTAT FIFO must be empty.
822:                       }
823:                   }//end for()
824:               }//end if(USBTransactionCompleteIE)
825:           
826:               USBClearUSBInterrupt();
075D  0020     MOVLB 0x0
075E  1112     BCF PIR2, 0x2
827:           }//end of USBDeviceTasks()
075F  0008     RETURN
828:           
829:           /*******************************************************************************
830:             Function:
831:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
832:               
833:             Summary:
834:               This function will enable the specified endpoint with the specified
835:               options
836:             Description:
837:               This function will enable the specified endpoint with the specified
838:               options.
839:               
840:               Typical Usage:
841:               <code>
842:               void USBCBInitEP(void)
843:               {
844:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
845:                   USBMSDInit();
846:               }
847:               </code>
848:               
849:               In the above example endpoint number MSD_DATA_IN_EP is being configured
850:               for both IN and OUT traffic with handshaking enabled. Also since
851:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
852:               explicitly disable SETUP packets on this endpoint.
853:             Conditions:
854:               None
855:             Input:
856:               uint8_t ep -       the endpoint to be configured
857:               uint8_t options -  optional settings for the endpoint. The options should
858:                               be ORed together to form a single options string. The
859:                               available optional settings for the endpoint. The
860:                               options should be ORed together to form a single options
861:                               string. The available options are the following\:
862:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
863:                                 NAK)
864:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
865:                                 NAK)
866:                               * USB_OUT_ENABLED enables the out direction
867:                               * USB_OUT_DISABLED disables the out direction
868:                               * USB_IN_ENABLED enables the in direction
869:                               * USB_IN_DISABLED disables the in direction
870:                               * USB_ALLOW_SETUP enables control transfers
871:                               * USB_DISALLOW_SETUP disables control transfers
872:                               * USB_STALL_ENDPOINT STALLs this endpoint
873:             Return:
874:               None
875:             Remarks:
876:               None                                                                                                          
877:             *****************************************************************************/
878:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
1313  0021     MOVLB 0x1
1314  00E4     MOVWF ep
879:           {
880:               unsigned char* p;
881:                   
882:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
883:               //starting DTS state in the BDT entry.
884:               if(options & USB_OUT_ENABLED)
1315  1D79     BTFSS 0xF9, 0x2
1316  2B1C     GOTO 0x31C
885:               {
886:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
1317  01F2     CLRF 0xF2
1318  0864     MOVF ep, W
1319  3194     MOVLP 0x14
131A  24BD     CALL 0x4BD
131B  3193     MOVLP 0x13
887:               }
888:               if(options & USB_IN_ENABLED)
131C  1CF9     BTFSS 0xF9, 0x1
131D  2B24     GOTO 0x324
889:               {
890:                   USBConfigureEndpoint(ep, IN_TO_HOST);
131E  01F2     CLRF 0xF2
131F  0AF2     INCF 0xF2, F
1320  0021     MOVLB 0x1
1321  0864     MOVF ep, W
1322  3194     MOVLP 0x14
1323  24BD     CALL 0x4BD
891:               }
892:           
893:               //Update the relevant UEPx register to actually enable the endpoint with
894:               //the specified options (ex: handshaking enabled, control transfers allowed,
895:               //etc.)
896:               #if defined(__C32__)
897:                   p = (unsigned char*)(&U1EP0+(4*ep));
898:               #else
899:                   p = (unsigned char*)(&U1EP0+ep);
1324  0021     MOVLB 0x1
1325  0864     MOVF ep, W
1326  3E98     ADDLW 0x98
1327  00E0     MOVWF __pcstackBANK1
1328  01E1     CLRF handle
1329  300E     MOVLW 0xE
132A  3DE1     ADDWFC handle, F
132B  0860     MOVF __pcstackBANK1, W
132C  00E2     MOVWF p
132D  0861     MOVF handle, W
132E  00E3     MOVWF len
900:               #endif
901:               *p = options;
132F  0862     MOVF p, W
1330  0086     MOVWF 0x86
1331  0863     MOVF len, W
1332  0087     MOVWF 0x87
1333  0879     MOVF 0xF9, W
1334  0081     MOVWF 0x81
902:           }
1335  0008     RETURN
903:           
904:           
905:           /*************************************************************************
906:             Function:
907:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
908:               
909:             Summary:
910:               Transfers a single packet (one transaction) of data on the USB bus.
911:           
912:             Description:
913:               The USBTransferOnePacket() function prepares a USB endpoint
914:               so that it may send data to the host (an IN transaction), or 
915:               receive data from the host (an OUT transaction).  The 
916:               USBTransferOnePacket() function can be used both to receive	and 
917:               send data to the host.  This function is the primary API function 
918:               provided by the USB stack firmware for sending or receiving application 
919:               data over the USB port.  
920:           
921:               The USBTransferOnePacket() is intended for use with all application 
922:               endpoints.  It is not used for sending or receiving application data 
923:               through endpoint 0 by using control transfers.  Separate API 
924:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
925:               USBEP0SendROMPtr() are provided for this purpose.
926:           
927:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
928:               entry associated with an endpoint buffer, and sets the UOWN bit, which 
929:               prepares the USB hardware to allow the transaction to complete.  The 
930:               application firmware can use the USBHandleBusy() macro to check the 
931:               status of the transaction, to see if the data has been successfully 
932:               transmitted yet.
933:           
934:           
935:               Typical Usage
936:               <code>
937:               //make sure that the we are in the configured state
938:               if(USBGetDeviceState() == CONFIGURED_STATE)
939:               {
940:                   //make sure that the last transaction isn't busy by checking the handle
941:                   if(!USBHandleBusy(USBInHandle))
942:                   {
943:           	        //Write the new data that we wish to send to the host to the INPacket[] array
944:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
945:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
946:           	        //INPacket[2] = ... (fill in the rest of the packet data)
947:           	      
948:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
949:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
950:                   }
951:               }
952:               </code>
953:           
954:             Conditions:
955:               Before calling USBTransferOnePacket(), the following should be true.
956:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
957:               2.  A transaction is not already pending on the specified endpoint.  This
958:                   is done by checking the previous request using the USBHandleBusy() 
959:                   macro (see the typical usage example).
960:               3.  The host has already sent a set configuration request and the 
961:                   enumeration process is complete.
962:                   This can be checked by verifying that the USBGetDeviceState() 
963:                   macro returns "CONFIGURED_STATE", prior to calling 
964:                   USBTransferOnePacket().
965:            					
966:             Input:
967:               uint8_t ep - The endpoint number that the data will be transmitted or
968:           	          received on
969:               uint8_t dir - The direction of the transfer
970:                          This value is either OUT_FROM_HOST or IN_TO_HOST
971:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
972:                            the data to be sent to the host.  For OUT transactions: pointer
973:                            to the RAM buffer that the received data should get written to.
974:              uint8_t len - Length of the data needing to be sent (for IN transactions).
975:                         For OUT transactions, the len parameter should normally be set
976:                         to the endpoint size specified in the endpoint descriptor.    
977:           
978:             Return Values:
979:               USB_HANDLE - handle to the transfer.  The handle is a pointer to 
980:                            the BDT entry associated with this transaction.  The
981:                            status of the transaction (ex: if it is complete or still
982:                            pending) can be checked using the USBHandleBusy() macro
983:                            and supplying the USB_HANDLE provided by
984:                            USBTransferOnePacket().
985:           
986:             Remarks:
987:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
988:               callback function, the set configuration is still being processed and the
989:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
990:               the USBTransferOnePacket() may still be called, but make sure that the 
991:               endpoint has been enabled and initialized by the USBEnableEndpoint() 
992:               function first.  
993:               
994:             *************************************************************************/
995:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
0B15  0021     MOVLB 0x1
0B16  00E0     MOVWF __pcstackBANK1
996:           {
997:               volatile BDT_ENTRY* handle;
998:           
999:               //If the direction is IN
1000:              if(dir != 0)
0B17  0872     MOVF 0xF2, W
0B18  1903     BTFSC 0x83, 0x2
0B19  2B23     GOTO 0x323
1001:              {
1002:                  //point to the IN BDT of the specified endpoint
1003:                  handle = pBDTEntryIn[ep];
0B1A  3560     LSLF __pcstackBANK1, W
0B1B  3EA0     ADDLW 0xA0
0B1C  0086     MOVWF 0x86
0B1D  3001     MOVLW 0x1
0B1E  0087     MOVWF 0x87
0B1F  3F40     MOVIW [0]FSR1
0B20  00E1     MOVWF handle
0B21  3F41     MOVIW [1]FSR1
0B22  2B2B     GOTO 0x32B
1004:              }
1005:              else
1006:              {
1007:                  //else point to the OUT BDT of the specified endpoint
1008:                  handle = pBDTEntryOut[ep];
0B23  3560     LSLF __pcstackBANK1, W
0B24  3E20     ADDLW 0x20
0B25  0086     MOVWF 0x86
0B26  3002     MOVLW 0x2
0B27  0087     MOVWF 0x87
0B28  3F40     MOVIW [0]FSR1
0B29  00E1     MOVWF handle
0B2A  3F41     MOVIW [1]FSR1
0B2B  00E2     MOVWF p
1009:              }
1010:              
1011:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1012:              //pBDTEntryOut[ep]) is initialized before using it.
1013:              if(handle == 0)
0B2C  0861     MOVF handle, W
0B2D  0462     IORWF p, W
0B2E  1D03     BTFSS 0x83, 0x2
0B2F  2B33     GOTO 0x333
1014:              {
1015:                  return 0;
0B30  01F2     CLRF 0xF2
0B31  01F3     CLRF 0xF3
0B32  0008     RETURN
1016:              }
1017:          
1018:              //Toggle the DTS bit if required
1019:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1020:                  handle->STAT.Val ^= _DTSMASK;
1021:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1022:                  if(ep != 0)
1023:                  {
1024:                      handle->STAT.Val ^= _DTSMASK;
1025:                  }
1026:              #endif
1027:          
1028:              //Set the data pointer, data length, and enable the endpoint
1029:              handle->ADR = ConvertToPhysicalAddress(data);
0B33  30FF     MOVLW 0xFF
0B34  0573     ANDWF 0xF3, W
0B35  00F6     MOVWF 0xF6
0B36  307F     MOVLW 0x7F
0B37  0574     ANDWF 0xF4, W
0B38  00F7     MOVWF 0xF7
0B39  0861     MOVF handle, W
0B3A  0086     MOVWF 0x86
0B3B  0862     MOVF p, W
0B3C  0087     MOVWF 0x87
0B3D  3142     ADDFSR 1, 2
0B3E  0876     MOVF 0xF6, W
0B3F  3FC0     MOVWI [0]FSR1
0B40  0877     MOVF 0xF7, W
0B41  3FC1     MOVWI [1]FSR1
1030:              handle->CNT = len;
0B42  0861     MOVF handle, W
0B43  3E01     ADDLW 0x1
0B44  00F6     MOVWF 0xF6
0B45  3000     MOVLW 0x0
0B46  3D62     ADDWFC p, W
0B47  00F7     MOVWF 0xF7
0B48  0876     MOVF 0xF6, W
0B49  0086     MOVWF 0x86
0B4A  0877     MOVF 0xF7, W
0B4B  0087     MOVWF 0x87
0B4C  0875     MOVF 0xF5, W
0B4D  0081     MOVWF 0x81
1031:              handle->STAT.Val &= _DTSMASK;
0B4E  3040     MOVLW 0x40
0B4F  00F6     MOVWF 0xF6
0B50  0861     MOVF handle, W
0B51  0086     MOVWF 0x86
0B52  0862     MOVF p, W
0B53  0087     MOVWF 0x87
0B54  0876     MOVF 0xF6, W
0B55  0581     ANDWF 0x81, F
1032:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
0B56  0861     MOVF handle, W
0B57  0086     MOVWF 0x86
0B58  0862     MOVF p, W
0B59  0087     MOVWF 0x87
0B5A  1581     BSF 0x81, 0x3
1033:              handle->STAT.Val |= _USIE;
0B5B  0861     MOVF handle, W
0B5C  0086     MOVWF 0x86
0B5D  0862     MOVF p, W
0B5E  0087     MOVWF 0x87
0B5F  1781     BSF 0x81, 0x7
1034:          
1035:              //Point to the next buffer for ping pong purposes.
1036:              if(dir != OUT_FROM_HOST)
0B60  0872     MOVF 0xF2, W
0B61  1903     BTFSC 0x83, 0x2
0B62  2B7C     GOTO 0x37C
1037:              {
1038:                  //toggle over the to the next buffer for an IN endpoint
1039:                  pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
0B63  3560     LSLF __pcstackBANK1, W
0B64  3EA0     ADDLW 0xA0
0B65  0086     MOVWF 0x86
0B66  3001     MOVLW 0x1
0B67  0087     MOVWF 0x87
0B68  3F40     MOVIW [0]FSR1
0B69  00F6     MOVWF 0xF6
0B6A  3F41     MOVIW [1]FSR1
0B6B  00F7     MOVWF 0xF7
0B6C  3004     MOVLW 0x4
0B6D  0676     XORWF 0xF6, W
0B6E  00F8     MOVWF 0xF8
0B6F  3000     MOVLW 0x0
0B70  0677     XORWF 0xF7, W
0B71  00F9     MOVWF 0xF9
0B72  3560     LSLF __pcstackBANK1, W
0B73  3EA0     ADDLW 0xA0
0B74  0086     MOVWF 0x86
0B75  3001     MOVLW 0x1
0B76  0087     MOVWF 0x87
0B77  0878     MOVF 0xF8, W
0B78  3FC0     MOVWI [0]FSR1
0B79  0879     MOVF 0xF9, W
0B7A  3FC1     MOVWI [1]FSR1
1040:              }
0B7B  2B94     GOTO 0x394
1041:              else
1042:              {
1043:                  //toggle over the to the next buffer for an OUT endpoint
1044:                  pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
0B7C  3560     LSLF __pcstackBANK1, W
0B7D  3E20     ADDLW 0x20
0B7E  0086     MOVWF 0x86
0B7F  3002     MOVLW 0x2
0B80  0087     MOVWF 0x87
0B81  3F40     MOVIW [0]FSR1
0B82  00F6     MOVWF 0xF6
0B83  3F41     MOVIW [1]FSR1
0B84  00F7     MOVWF 0xF7
0B85  3004     MOVLW 0x4
0B86  0676     XORWF 0xF6, W
0B87  00F8     MOVWF 0xF8
0B88  3000     MOVLW 0x0
0B89  0677     XORWF 0xF7, W
0B8A  00F9     MOVWF 0xF9
0B8B  3560     LSLF __pcstackBANK1, W
0B8C  3E20     ADDLW 0x20
0B8D  0086     MOVWF 0x86
0B8E  3002     MOVLW 0x2
0B8F  0087     MOVWF 0x87
0B90  0878     MOVF 0xF8, W
0B91  3FC0     MOVWI [0]FSR1
0B92  0879     MOVF 0xF9, W
0B93  3FC1     MOVWI [1]FSR1
1045:              }
1046:              return (USB_HANDLE)handle;
0B94  0862     MOVF p, W
0B95  00F3     MOVWF 0xF3
0B96  0861     MOVF handle, W
0B97  00F2     MOVWF 0xF2
0B98  0008     RETURN
1047:          }
1048:          
1049:          
1050:          /********************************************************************
1051:              Function:
1052:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1053:                  
1054:              Summary:
1055:                   Configures the specified endpoint to send STALL to the host, the next
1056:                   time the host tries to access the endpoint.
1057:              
1058:              PreCondition:
1059:                  None
1060:                  
1061:              Parameters:
1062:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1063:                  uint8_t dir - The direction of the endpoint to STALL, either
1064:                             IN_TO_HOST or OUT_FROM_HOST.
1065:                  
1066:              Return Values:
1067:                  None
1068:                  
1069:              Remarks:
1070:                  None
1071:          
1072:           *******************************************************************/
1073:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
1074:          {
1075:              BDT_ENTRY *p;
1076:          
1077:              if(ep == 0)
1078:              {
1079:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1080:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1081:                  //packet that will arrive.
1082:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1083:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1084:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1085:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1086:                  pBDTEntryIn[0]->STAT.Val = _BSTALL; 
1087:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1088:                         
1089:              }
1090:              else
1091:              {
1092:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1093:                  p->STAT.Val |= _BSTALL;
1094:                  p->STAT.Val |= _USIE;
1095:              
1096:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1097:                  //then stall that entry as well
1098:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1099:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1100:                  p->STAT.Val |= _BSTALL;
1101:                  p->STAT.Val |= _USIE;
1102:                  #endif
1103:              }
1104:          }
1105:          
1106:          /**************************************************************************
1107:              Function:
1108:                  void USBCancelIO(uint8_t endpoint)
1109:              
1110:              Description:
1111:                  This function cancels the transfers pending on the specified endpoint.
1112:                  This function can only be used after a SETUP packet is received and 
1113:                  before that setup packet is handled.  This is the time period in which
1114:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1115:                  returns to the stack.
1116:          
1117:              Precondition:
1118:            
1119:              Parameters:
1120:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1121:               
1122:              Return Values:
1123:                  None
1124:                  
1125:              Remarks:
1126:                  None
1127:                                                                    
1128:            **************************************************************************/
1129:          void USBCancelIO(uint8_t endpoint)
1130:          {
1131:              if(USBPacketDisable == 1)
1132:              {
1133:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1134:              	//to mess with the BDT right now.
1135:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1136:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1137:              	
1138:              	//Need to do additional handling if ping-pong buffering is being used
1139:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1140:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1141:                  //(either due to SIE clearing it after a transaction, or the firmware
1142:                  //clearing it) makes hardware ping pong pointer advance.
1143:                  pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
1144:                  
1145:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1146:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1147:                  #endif
1148:              }
1149:          }
1150:          
1151:          /**************************************************************************
1152:              Function:
1153:                  void USBDeviceDetach(void)
1154:             
1155:              Summary:
1156:                  This function configures the USB module to "soft detach" itself from
1157:                  the USB host.
1158:                  
1159:              Description:
1160:                  This function configures the USB module to perform a "soft detach"
1161:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1162:                  lets the host know the device is present and attached.  This will make
1163:                  the host think that the device has been unplugged.  This is potentially
1164:                  useful, as it allows the USB device to force the host to re-enumerate
1165:                  the device (on the firmware has re-enabled the USB module/pull up, by
1166:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1167:                  
1168:              Precondition:
1169:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1170:                  section if USB_POLLING mode option is being used (usb_config.h option).
1171:          
1172:                  Additionally, this function should only be called from the main() loop 
1173:                  context.  Do not call this function from within an interrupt handler, as 
1174:                  this function may modify global interrupt enable bits and settings.
1175:                  
1176:              Parameters:
1177:                  None
1178:               
1179:              Return Values:
1180:                  None
1181:                  
1182:              Remarks:
1183:                  If the application firmware calls USBDeviceDetach(), it is strongly
1184:                  recommended that the firmware wait at least >= 80ms before calling
1185:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1186:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1187:                  hosts may interpret this as an unexpected "glitch" rather than as a
1188:                  physical removal/re-attachment of the USB device.  In this case the host
1189:                  may simply ignore the event without re-enumerating the device.  To 
1190:                  ensure that the host properly detects and processes the device soft
1191:                  detach/re-attach, it is recommended to make sure the device remains 
1192:                  detached long enough to mimic a real human controlled USB 
1193:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1194:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1195:                  
1196:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1197:                  or take long to execute.  It is the application firmwares 
1198:                  responsibility for adding the 80+ms delay, when using these API 
1199:                  functions.
1200:                  
1201:                  Note: The Windows plug and play event handler processing is fairly 
1202:                  slow, especially in certain versions of Windows, and for certain USB
1203:                  device classes.  It has been observed that some device classes need to
1204:                  provide even more USB detach dwell interval (before calling 
1205:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1206:                  If the USB device is a CDC class device, it is recommended to wait
1207:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1208:                  to provide the plug and play event handler enough time to finish 
1209:                  processing the removal event, before the re-attach occurs.
1210:                  
1211:                  If the application is using the USB_POLLING mode option, then the 
1212:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1213:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1214:                  and "#define USB_BUS_SENSE" options in the 
1215:                  HardwareProfile – [platform name].h file. 
1216:          
1217:                  When using the USB_POLLING mode option, and the 
1218:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1219:                  the USB stack assumes that it should always enable the USB module at 
1220:                  pretty much all times.  Basically, anytime the application firmware 
1221:                  calls USBDeviceTasks(), the firmware will automatically enable the USB 
1222:                  module.  This mode would typically be selected if the application was 
1223:                  designed to be a purely bus powered device.  In this case, the 
1224:                  application is powered from the +5V VBUS supply from the USB port, so 
1225:                  it is correct and sensible in this type of application to power up and 
1226:                  turn on the USB module, at anytime that the microcontroller is 
1227:                  powered (which implies the USB cable is attached and the host is also 
1228:                  powered).
1229:          
1230:                  In a self powered application, the USB stack is designed with the 
1231:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1232:                  option in the HardwareProfile – [platform name].h file.  When this 
1233:                  option is defined, then the USBDeviceTasks() function will automatically 
1234:                  check the I/O pin port value of the designated pin (based on the 
1235:                  #define USB_BUS_SENSE option in the HardwareProfile – [platform name].h 
1236:                  file), every time the application calls USBDeviceTasks().  If the 
1237:                  USBDeviceTasks() function is executed and finds that the pin defined by 
1238:                  the #define USB_BUS_SENSE is in a logic low state, then it will 
1239:                  automatically disable the USB module and tri-state the D+ and D- pins.  
1240:                  If however the USBDeviceTasks() function is executed and finds the pin 
1241:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1242:                  will automatically enable the USB module, if it has not already been 
1243:                  enabled.        
1244:                                                                    
1245:            **************************************************************************/
1246:          #if defined(USB_INTERRUPT)
1247:          void USBDeviceDetach(void)
1248:          {
1249:              //If the interrupt option is selected then the customer is required
1250:              //  to notify the stack when the device is attached or removed from the
1251:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1252:          #ifdef USB_SUPPORT_OTG
1253:              if (USB_BUS_SENSE != 1)
1254:          #endif
1255:              {
1256:                   // Disable module & detach from bus
1257:                   U1CON = 0;             
1258:          
1259:                   // Mask all USB interrupts              
1260:                   U1IE = 0;          
1261:          
1262:                   //Move to the detached state                  
1263:                   USBDeviceState = DETACHED_STATE;
1264:          
1265:                   #ifdef  USB_SUPPORT_OTG    
1266:                       //Disable D+ Pull-up
1267:                       U1OTGCONbits.DPPULUP = 0;
1268:          
1269:                       //Disable HNP
1270:                       USBOTGDisableHnp();
1271:          
1272:                       //Deactivate HNP
1273:                       USBOTGDeactivateHnp();
1274:                       
1275:                       //If ID Pin Changed State
1276:                       if (USBIDIF && USBIDIE)
1277:                       {  
1278:                           //Re-detect & Initialize
1279:                            USBOTGInitialize();
1280:          
1281:                            //Clear ID Interrupt Flag
1282:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1283:                       }
1284:                   #endif
1285:          
1286:                   #if defined __C30__ || defined __XC16__
1287:                       //USBClearInterruptFlag(U1OTGIR, 3); 
1288:                   #endif
1289:                      //return so that we don't go through the rest of 
1290:                      //the state machine
1291:                    return;
1292:              }
1293:          
1294:          #ifdef USB_SUPPORT_OTG
1295:              //If Session Is Started Then
1296:             else
1297:             {
1298:                  //If SRP Is Ready
1299:                  if (USBOTGSRPIsReady())
1300:                  {   
1301:                      //Clear SRPReady
1302:                      USBOTGClearSRPReady();
1303:          
1304:                      //Clear SRP Timeout Flag
1305:                      USBOTGClearSRPTimeOutFlag();
1306:          
1307:                      //Indicate Session Started
1308:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1309:                  }
1310:              }
1311:          #endif
1312:          }
1313:          #endif  //#if defined(USB_INTERRUPT)
1314:          /**************************************************************************
1315:              Function:
1316:                  void USBDeviceAttach(void)
1317:              
1318:              Summary:
1319:                  Checks if VBUS is present, and that the USB module is not already 
1320:                  initialized, and if so, enables the USB module so as to signal device 
1321:                  attachment to the USB host.   
1322:          
1323:              Description:
1324:                  This function indicates to the USB host that the USB device has been
1325:                  attached to the bus.  This function needs to be called in order for the
1326:                  device to start to enumerate on the bus.
1327:                          
1328:              Precondition:
1329:                  Should only be called when USB_INTERRUPT is defined.  Also, should only 
1330:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1331:                  from within an interrupt handler, as the USBDeviceAttach() function
1332:                  may modify global interrupt enable bits and settings.
1333:          
1334:                  For normal USB devices:
1335:                  Make sure that if the module was previously on, that it has been turned off 
1336:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1337:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1338:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1339:                  reject this event, since no human could ever unplug and re-attach a USB device in a 
1340:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1341:                  of glitch and ignore the event altogether.  
1342:              Parameters:
1343:                  None
1344:               
1345:              Return Values:
1346:                  None       
1347:              
1348:              Remarks: 
1349:          		See also the USBDeviceDetach() API function documentation.                                                 
1350:          ****************************************************************************/
1351:          #if defined(USB_INTERRUPT)
1352:          void USBDeviceAttach(void)
1353:          {
1354:              //if we are in the detached state
1355:              if(USBDeviceState == DETACHED_STATE)
1356:              {
1357:                  if(USB_BUS_SENSE == 1)
1358:                  {
1359:              	    //Initialize registers to known states.
1360:                      U1CON = 0;          
1361:              
1362:                      // Mask all USB interrupts
1363:                      U1IE = 0;                                
1364:              
1365:                      //Configure things like: pull ups, full/low-speed mode, 
1366:                      //set the ping pong mode, and set internal transceiver
1367:                      SetConfigurationOptions();
1368:              
1369:                      USBEnableInterrupts();  //Modifies global interrupt settings
1370:              
1371:                      // Enable module & attach to bus
1372:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1373:              
1374:                      //moved to the attached state
1375:                      USBDeviceState = ATTACHED_STATE;
1376:              
1377:                      #ifdef  USB_SUPPORT_OTG
1378:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1379:                      #endif
1380:                  }
1381:              }
1382:          }
1383:          #endif  //#if defined(USB_INTERRUPT)
1384:          
1385:          
1386:          /*******************************************************************************
1387:            Function: void USBCtrlEPAllowStatusStage(void);
1388:          
1389:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1390:                      (based on the controlTransferState) to allow the status stage packet
1391:                      of a control transfer to complete.  This function gets used
1392:                      internally by the USB stack itself, but it may also be called from
1393:                      the application firmware, IF the application firmware called
1394:                      the USBDeferStatusStage() function during the initial processing
1395:                      of the control transfer request.  In this case, the application
1396:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1397:                      completed processing and handling the data stage portion of the
1398:                      request.
1399:          
1400:                      If the application firmware has no need for delaying control
1401:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1402:                      application firmware should not call USBCtrlEPAllowStatusStage().
1403:          
1404:            Description:
1405:          
1406:            Conditions:
1407:              None
1408:          
1409:            Input:
1410:          
1411:            Return:
1412:          
1413:            Remarks:
1414:              None
1415:            *****************************************************************************/
1416:          void USBCtrlEPAllowStatusStage(void)
1417:          {
1418:              //Check and set two flags, prior to actually modifying any BDT entries.
1419:              //This double checking is necessary to make certain that 
1420:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1421:              //in main loop context, while simultaneously getting an interrupt which 
1422:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1423:              if(USBStatusStageEnabledFlag1 == false)
093E  0023     MOVLB 0x3
093F  084D     MOVF USBStatusStageEnabledFlag1, W
0940  1D03     BTFSS 0x183, 0x2
0941  0008     RETURN
1424:              {
1425:                  USBStatusStageEnabledFlag1 = true;
0942  3001     MOVLW 0x1
0943  00F2     MOVWF 0x1F2
0944  0872     MOVF 0x1F2, W
0945  00CD     MOVWF USBStatusStageEnabledFlag1
1426:                  if(USBStatusStageEnabledFlag2 == false)
0946  084E     MOVF USBStatusStageEnabledFlag2, W
0947  1D03     BTFSS 0x183, 0x2
0948  0008     RETURN
1427:                  {
1428:                      USBStatusStageEnabledFlag2 = true;
0949  3001     MOVLW 0x1
094A  00F2     MOVWF 0x1F2
094B  0872     MOVF 0x1F2, W
094C  00CE     MOVWF USBStatusStageEnabledFlag2
1429:                  
1430:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1431:                      //stage), based on the type of control transfer currently pending.
1432:                      if(controlTransferState == CTRL_TRF_RX)
094D  3002     MOVLW 0x2
094E  0659     XORWF controlTransferState, W
094F  1D03     BTFSS 0x183, 0x2
0950  2963     GOTO 0x163
1433:                      {
1434:                          pBDTEntryIn[0]->CNT = 0;
0951  0820     MOVF pBDTEntryIn, W
0952  0086     MOVWF 0x186
0953  0821     MOVF 0x1A1, W
0954  0087     MOVWF 0x187
0955  3141     ADDFSR 1, 1
0956  0181     CLRF 0x181
1435:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
0957  0820     MOVF pBDTEntryIn, W
0958  0086     MOVWF 0x186
0959  0821     MOVF 0x1A1, W
095A  0087     MOVWF 0x187
095B  3048     MOVLW 0x48
095C  0081     MOVWF 0x181
1436:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
095D  0820     MOVF pBDTEntryIn, W
095E  0086     MOVWF 0x186
095F  0821     MOVF 0x1A1, W
0960  0087     MOVWF 0x187
0961  1781     BSF 0x181, 0x7
1437:                      }
0962  0008     RETURN
1438:                      else if(controlTransferState == CTRL_TRF_TX)
0963  0359     DECF controlTransferState, W
0964  1D03     BTFSS 0x183, 0x2
0965  0008     RETURN
1439:                      {
1440:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
0966  01C0     CLRF BothEP0OutUOWNsSet
1441:          
1442:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1443:                          //next SETUP packet.
1444:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1445:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
0967  3008     MOVLW 0x8
0968  00F2     MOVWF 0x1F2
0969  0A5C     INCF pBDTEntryEP0OutCurrent, W
096A  0086     MOVWF 0x186
096B  0187     CLRF 0x187
096C  0872     MOVF 0x1F2, W
096D  0081     MOVWF 0x181
1446:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
096E  30A0     MOVLW 0xA0
096F  00F2     MOVWF 0x1F2
0970  3000     MOVLW 0x0
0971  00F3     MOVWF 0x1F3
0972  085C     MOVF pBDTEntryEP0OutCurrent, W
0973  3E02     ADDLW 0x2
0974  0086     MOVWF 0x186
0975  0187     CLRF 0x187
0976  0872     MOVF 0x1F2, W
0977  3FC0     MOVWI [0]FSR1
0978  0873     MOVF 0x1F3, W
0979  3FC1     MOVWI [1]FSR1
1447:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
097A  3004     MOVLW 0x4
097B  00F2     MOVWF 0x1F2
097C  085C     MOVF pBDTEntryEP0OutCurrent, W
097D  0086     MOVWF 0x186
097E  0187     CLRF 0x187
097F  0872     MOVF 0x1F2, W
0980  0081     MOVWF 0x181
1448:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0981  085C     MOVF pBDTEntryEP0OutCurrent, W
0982  0086     MOVWF 0x186
0983  0187     CLRF 0x187
0984  1781     BSF 0x181, 0x7
1449:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
0985  01C0     CLRF BothEP0OutUOWNsSet
0986  0AC0     INCF BothEP0OutUOWNsSet, F
1450:                          #endif
1451:          
1452:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1453:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0987  087A     MOVF 0x1FA, W
0988  3E01     ADDLW 0x1
0989  00F2     MOVWF 0x1F2
098A  3000     MOVLW 0x0
098B  3D7B     ADDWFC 0x1FB, W
098C  00F3     MOVWF 0x1F3
098D  0872     MOVF 0x1F2, W
098E  0086     MOVWF 0x186
098F  0873     MOVF 0x1F3, W
0990  0087     MOVWF 0x187
0991  3008     MOVLW 0x8
0992  0081     MOVWF 0x181
1454:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0993  30A0     MOVLW 0xA0
0994  00F2     MOVWF 0x1F2
0995  3000     MOVLW 0x0
0996  00F3     MOVWF 0x1F3
0997  087A     MOVF 0x1FA, W
0998  0086     MOVWF 0x186
0999  087B     MOVF 0x1FB, W
099A  0087     MOVWF 0x187
099B  3142     ADDFSR 1, 2
099C  0872     MOVF 0x1F2, W
099D  3FC0     MOVWI [0]FSR1
099E  0873     MOVF 0x1F3, W
099F  3FC1     MOVWI [1]FSR1
1455:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
09A0  087A     MOVF 0x1FA, W
09A1  0086     MOVWF 0x186
09A2  087B     MOVF 0x1FB, W
09A3  0087     MOVWF 0x187
09A4  3080     MOVLW 0x80
09A5  0081     MOVWF 0x181
1456:                      }
1457:                  }    
09A6  0008     RETURN
1458:              }
1459:          }   
1460:          
1461:          
1462:          /*******************************************************************************
1463:            Function: void USBCtrlEPAllowDataStage(void);
1464:              
1465:            Summary: This function allows the data stage of either a host-to-device or
1466:                      device-to-host control transfer (with data stage) to complete.
1467:                      This function is meant to be used in conjunction with either the
1468:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1469:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1470:                      then the firmware does not need to manually call 
1471:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1472:                      instead.
1473:               
1474:            Description:
1475:              
1476:            Conditions: A control transfer (with data stage) should already be pending, 
1477:                          if the firmware calls this function.  Additionally, the firmware
1478:                          should have called either USBDeferOUTDataStage() or 
1479:                          USBDeferINDataStage() at the start of the control transfer, if
1480:                          the firmware will be calling this function manually.
1481:          
1482:            Input:
1483:          
1484:            Return:
1485:          
1486:            Remarks: 
1487:            *****************************************************************************/
1488:          void USBCtrlEPAllowDataStage(void)
1489:          {
1490:              USBDeferINDataStagePackets = false;
16EB  0023     MOVLB 0x3
16EC  01C9     CLRF USBDeferINDataStagePackets
1491:              USBDeferOUTDataStagePackets = false;
16ED  01CA     CLRF USBDeferOUTDataStagePackets
1492:          
1493:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
16EE  3002     MOVLW 0x2
16EF  0659     XORWF controlTransferState, W
16F0  1D03     BTFSS 0x183, 0x2
16F1  2F17     GOTO 0x717
1494:              {
1495:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1496:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
16F2  087A     MOVF 0x1FA, W
16F3  3E01     ADDLW 0x1
16F4  00F5     MOVWF 0x1F5
16F5  3000     MOVLW 0x0
16F6  3D7B     ADDWFC 0x1FB, W
16F7  00F6     MOVWF 0x1F6
16F8  0875     MOVF 0x1F5, W
16F9  0086     MOVWF 0x186
16FA  0876     MOVF 0x1F6, W
16FB  0087     MOVWF 0x187
16FC  3008     MOVLW 0x8
16FD  0081     MOVWF 0x181
1497:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
16FE  30A8     MOVLW 0xA8
16FF  00F5     MOVWF 0x1F5
1700  3000     MOVLW 0x0
1701  00F6     MOVWF 0x1F6
1702  087A     MOVF 0x1FA, W
1703  0086     MOVWF 0x186
1704  087B     MOVF 0x1FB, W
1705  0087     MOVWF 0x187
1706  3142     ADDFSR 1, 2
1707  0875     MOVF 0x1F5, W
1708  3FC0     MOVWI [0]FSR1
1709  0876     MOVF 0x1F6, W
170A  3FC1     MOVWI [1]FSR1
1498:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
170B  087A     MOVF 0x1FA, W
170C  0086     MOVWF 0x186
170D  087B     MOVF 0x1FB, W
170E  0087     MOVWF 0x187
170F  3048     MOVLW 0x48
1710  0081     MOVWF 0x181
1499:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1711  087A     MOVF 0x1FA, W
1712  0086     MOVWF 0x186
1713  087B     MOVF 0x1FB, W
1714  0087     MOVWF 0x187
1715  1781     BSF 0x181, 0x7
1500:              }   
1716  0008     RETURN
1501:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1502:              {
1503:                  //Error check the data stage byte count.  Make sure the user specified
1504:                  //value was no greater than the number of bytes the host requested.
1505:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
1717  0835     MOVF 0x1B5, W
1718  0021     MOVLB 0x1
1719  0227     SUBWF 0xA7, W
171A  1D03     BTFSS 0x83, 0x2
171B  2F20     GOTO 0x720
171C  0023     MOVLB 0x3
171D  0834     MOVF 0x1B4, W
171E  0021     MOVLB 0x1
171F  0226     SUBWF 0xA6, W
1720  1803     BTFSC 0x83, 0x0
1721  2F29     GOTO 0x729
1506:          		{
1507:          			inPipes[0].wCount.Val = SetupPkt.wLength;
1722  0827     MOVF 0xA7, W
1723  0023     MOVLB 0x3
1724  00B5     MOVWF 0x1B5
1725  0021     MOVLB 0x1
1726  0826     MOVF 0xA6, W
1727  0023     MOVLB 0x3
1728  00B4     MOVWF 0x1B4
1508:          		}
1509:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
1729  3188     MOVLP 0x8
172A  20D5     CALL 0xD5
1510:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1511:          
1512:          	    //Cnt should have been initialized by responsible request owner (ex: by
1513:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1514:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
172B  30A8     MOVLW 0xA8
172C  00F5     MOVWF 0x1F5
172D  3000     MOVLW 0x0
172E  00F6     MOVWF 0x1F6
172F  0023     MOVLB 0x3
1730  0820     MOVF pBDTEntryIn, W
1731  0086     MOVWF 0x186
1732  0821     MOVF 0x1A1, W
1733  0087     MOVWF 0x187
1734  3142     ADDFSR 1, 2
1735  0875     MOVF 0x1F5, W
1736  3FC0     MOVWI [0]FSR1
1737  0876     MOVF 0x1F6, W
1738  3FC1     MOVWI [1]FSR1
1515:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
1739  0820     MOVF pBDTEntryIn, W
173A  0086     MOVWF 0x186
173B  0821     MOVF 0x1A1, W
173C  0087     MOVWF 0x187
173D  3048     MOVLW 0x48
173E  0081     MOVWF 0x181
1516:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
173F  0820     MOVF pBDTEntryIn, W
1517:              }     
1518:          }    
1519:          
1520:          
1521:          /******************************************************************************/
1522:          /** Internal Functions *********************************************************/
1523:          /******************************************************************************/
1524:          
1525:          /********************************************************************
1526:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1527:           *
1528:           * PreCondition:    None
1529:           *
1530:           * Input:           uint8_t EPNum - the endpoint to be configured
1531:           *                  uint8_t direction - the direction to be configured
1532:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1533:           *
1534:           * Output:          None
1535:           *
1536:           * Side Effects:    None
1537:           *
1538:           * Overview:        This function will configure the specified 
1539:           *                  endpoint
1540:           *
1541:           * Note:            None
1542:           *******************************************************************/
1543:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
14BD  00F7     MOVWF 0x1F7
1544:          {
1545:              volatile BDT_ENTRY* handle;
1546:          
1547:              //Compute a pointer to the even BDT entry corresponding to the
1548:              //EPNum and direction values passed to this function.
1549:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
14BE  3020     MOVLW 0x20
14BF  00F3     MOVWF 0x1F3
14C0  0873     MOVF 0x1F3, W
14C1  00F8     MOVWF 0x1F8
1550:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
14C2  0872     MOVF 0x1F2, W
14C3  00F3     MOVWF 0x1F3
14C4  3001     MOVLW 0x1
14C5  35F3     LSLF 0x1F3, F
14C6  0B89     DECFSZ 0x189, F
14C7  2CC5     GOTO 0x4C5
14C8  0877     MOVF 0x1F7, W
14C9  00F4     MOVWF 0x1F4
14CA  3001     MOVLW 0x1
14CB  35F4     LSLF 0x1F4, F
14CC  3EFF     ADDLW 0xFF
14CD  1D03     BTFSS 0x183, 0x2
14CE  2CCB     GOTO 0x4CB
14CF  3574     LSLF 0x1F4, W
14D0  0773     ADDWF 0x1F3, W
14D1  00F5     MOVWF 0x1F5
14D2  3001     MOVLW 0x1
14D3  35F5     LSLF 0x1F5, F
14D4  3EFF     ADDLW 0xFF
14D5  1D03     BTFSS 0x183, 0x2
14D6  2CD3     GOTO 0x4D3
14D7  3575     LSLF 0x1F5, W
14D8  00F6     MOVWF 0x1F6
14D9  0876     MOVF 0x1F6, W
14DA  07F8     ADDWF 0x1F8, F
1551:              
1552:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
14DB  0878     MOVF 0x1F8, W
14DC  0086     MOVWF 0x186
14DD  0187     CLRF 0x187
14DE  1381     BCF 0x181, 0x7
1553:              //already cleared the entire BDT table
1554:          
1555:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1556:              //for USBTransferOnePacket() API calls.
1557:              if(direction == OUT_FROM_HOST)
14DF  0872     MOVF 0x1F2, W
14E0  1D03     BTFSS 0x183, 0x2
14E1  2CEC     GOTO 0x4EC
1558:              {
1559:                  pBDTEntryOut[EPNum] = handle;
14E2  3577     LSLF 0x1F7, W
14E3  3E20     ADDLW 0x20
14E4  0086     MOVWF 0x186
14E5  3002     MOVLW 0x2
14E6  0087     MOVWF 0x187
14E7  0878     MOVF 0x1F8, W
14E8  3FC0     MOVWI [0]FSR1
14E9  3000     MOVLW 0x0
14EA  3FC1     MOVWI [1]FSR1
1560:              }
14EB  2CF5     GOTO 0x4F5
1561:              else
1562:              {
1563:                  pBDTEntryIn[EPNum] = handle;
14EC  3577     LSLF 0x1F7, W
14ED  3EA0     ADDLW 0xA0
14EE  0086     MOVWF 0x186
14EF  3001     MOVLW 0x1
14F0  0087     MOVWF 0x187
14F1  0878     MOVF 0x1F8, W
14F2  3FC0     MOVWI [0]FSR1
14F3  3000     MOVLW 0x0
14F4  3FC1     MOVWI [1]FSR1
1564:              }
1565:          
1566:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1567:                  handle->STAT.DTS = 0;
14F5  0878     MOVF 0x1F8, W
14F6  0086     MOVWF 0x186
14F7  0187     CLRF 0x187
14F8  1301     BCF 0x181, 0x6
1568:                  (handle+1)->STAT.DTS = 1;
14F9  0878     MOVF 0x1F8, W
14FA  3E04     ADDLW 0x4
14FB  0086     MOVWF 0x186
14FC  0187     CLRF 0x187
14FD  1701     BSF 0x181, 0x6
1569:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1570:                  //Set DTS to one because the first thing we will do
1571:                  //when transmitting is toggle the bit
1572:                  handle->STAT.DTS = 1;
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1574:                  if(EPNum != 0)
1575:                  {
1576:                      handle->STAT.DTS = 1;
1577:                  }
1578:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1579:                  if(EPNum != 0)
1580:                  {
1581:                      handle->STAT.DTS = 0;
1582:                      (handle+1)->STAT.DTS = 1;
1583:                  }
1584:              #endif
1585:          }
14FE  0008     RETURN
1586:          
1587:          
1588:          /******************************************************************************
1589:           * Function:        void USBCtrlEPServiceComplete(void)
1590:           *
1591:           * PreCondition:    None
1592:           *
1593:           * Input:           None
1594:           *
1595:           * Output:          None
1596:           *
1597:           * Side Effects:    None
1598:           *
1599:           * Overview:        This routine wrap up the remaining tasks in servicing
1600:           *                  a Setup Request. Its main task is to set the endpoint
1601:           *                  controls appropriately for a given situation. See code
1602:           *                  below.
1603:           *                  There are three main scenarios:
1604:           *                  a) There was no handler for the Request, in this case
1605:           *                     a STALL should be sent out.
1606:           *                  b) The host has requested a read control transfer,
1607:           *                     endpoints are required to be setup in a specific way.
1608:           *                  c) The host has requested a write control transfer, or
1609:           *                     a control data stage is not required, endpoints are
1610:           *                     required to be setup in a specific way.
1611:           *
1612:           *                  Packet processing is resumed by clearing PKTDIS bit.
1613:           *
1614:           * Note:            None
1615:           *****************************************************************************/
1616:          static void USBCtrlEPServiceComplete(void)
1617:          {
1618:              /*
1619:               * PKTDIS bit is set when a Setup Transaction is received.
1620:               * Clear to resume packet processing.
1621:               */
1622:              USBPacketDisable = 0;
0B99  003D     MOVLB 0x1D
0B9A  120E     BCF UCON, 0x4
1623:          
1624:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1625:          	//control transfer is currently in progress.  We need to know the type of control
1626:          	//transfer that is currently pending, in order to know how to properly arm the 
1627:          	//EP0 IN and EP0 OUT endpoints.
1628:              if(inPipes[0].info.bits.busy == 0)
0B9B  0023     MOVLB 0x3
0B9C  1BB3     BTFSC 0x1B3, 0x7
0B9D  2BDD     GOTO 0x3DD
1629:              {
1630:                  if(outPipes[0].info.bits.busy == 1)
0B9E  1FAC     BTFSS 0x1AC, 0x7
0B9F  2BAD     GOTO 0x3AD
1631:                  {
1632:                      controlTransferState = CTRL_TRF_RX;
0BA0  3002     MOVLW 0x2
0BA1  00F7     MOVWF 0x1F7
0BA2  0877     MOVF 0x1F7, W
0BA3  00D9     MOVWF controlTransferState
1633:                      /*
1634:                       * Control Write:
1635:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1636:                       */
1637:          
1638:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1639:                      //   function decided to defer the data stage (ex: because the intended
1640:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1641:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1642:                      //   once it is ready to begin receiving the data.
1643:                      if(USBDeferOUTDataStagePackets == false)
0BA4  084A     MOVF USBDeferOUTDataStagePackets, W
0BA5  1D03     BTFSS 0x183, 0x2
0BA6  2BA9     GOTO 0x3A9
1644:                      {
1645:                          USBCtrlEPAllowDataStage();
0BA7  3196     MOVLP 0x16
0BA8  26EB     CALL 0x6EB
1646:                      }
1647:                      
1648:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1649:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1650:                      USBStatusStageEnabledFlag2 = false;
0BA9  0023     MOVLB 0x3
0BAA  01CE     CLRF USBStatusStageEnabledFlag2
1651:                      USBStatusStageEnabledFlag1 = false;
0BAB  01CD     CLRF USBStatusStageEnabledFlag1
1652:                  }
0BAC  0008     RETURN
1653:                  else
1654:                  {
1655:                      /*
1656:                       * If no one knows how to service this request then stall.
1657:                       * Must also prepare EP0 to receive the next SETUP transaction.
1658:                       */
1659:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0BAD  087A     MOVF 0x1FA, W
0BAE  3E01     ADDLW 0x1
0BAF  00F7     MOVWF 0x1F7
0BB0  3000     MOVLW 0x0
0BB1  3D7B     ADDWFC 0x1FB, W
0BB2  00F8     MOVWF 0x1F8
0BB3  0877     MOVF 0x1F7, W
0BB4  0086     MOVWF 0x186
0BB5  0878     MOVF 0x1F8, W
0BB6  0087     MOVWF 0x187
0BB7  3008     MOVLW 0x8
0BB8  0081     MOVWF 0x181
1660:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0BB9  30A0     MOVLW 0xA0
0BBA  00F7     MOVWF 0x1F7
0BBB  3000     MOVLW 0x0
0BBC  00F8     MOVWF 0x1F8
0BBD  087A     MOVF 0x1FA, W
0BBE  0086     MOVWF 0x186
0BBF  087B     MOVF 0x1FB, W
0BC0  0087     MOVWF 0x187
0BC1  3142     ADDFSR 1, 2
0BC2  0877     MOVF 0x1F7, W
0BC3  3FC0     MOVWI [0]FSR1
0BC4  0878     MOVF 0x1F8, W
0BC5  3FC1     MOVWI [1]FSR1
1661:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0BC6  087A     MOVF 0x1FA, W
0BC7  0086     MOVWF 0x186
0BC8  087B     MOVF 0x1FB, W
0BC9  0087     MOVWF 0x187
0BCA  300C     MOVLW 0xC
0BCB  0081     MOVWF 0x181
1662:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0BCC  087A     MOVF 0x1FA, W
0BCD  0086     MOVWF 0x186
0BCE  087B     MOVF 0x1FB, W
0BCF  0087     MOVWF 0x187
0BD0  1781     BSF 0x181, 0x7
1663:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0BD1  0820     MOVF pBDTEntryIn, W
0BD2  0086     MOVWF 0x186
0BD3  0821     MOVF 0x1A1, W
0BD4  0087     MOVWF 0x187
0BD5  3004     MOVLW 0x4
0BD6  0081     MOVWF 0x181
1664:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0BD7  0820     MOVF pBDTEntryIn, W
0BD8  0086     MOVWF 0x186
0BD9  0821     MOVF 0x1A1, W
0BDA  0087     MOVWF 0x187
0BDB  1781     BSF 0x181, 0x7
1665:                  }
1666:              }
0BDC  0008     RETURN
1667:              else    // A module has claimed ownership of the control transfer session.
1668:              {
1669:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0BDD  0021     MOVLB 0x1
0BDE  1FA0     BTFSS SetupPkt, 0x7
0BDF  2BF2     GOTO 0x3F2
1670:          		{
1671:          			controlTransferState = CTRL_TRF_TX;
0BE0  0023     MOVLB 0x3
0BE1  01D9     CLRF controlTransferState
0BE2  0AD9     INCF controlTransferState, F
1672:          			/*
1673:          			 * Control Read:
1674:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1675:          			 *
1676:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1677:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1678:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1679:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1680:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1681:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1682:          			 *    is ready to begin sending the data, it should then call the 
1683:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1684:          			 */
1685:          			if(USBDeferINDataStagePackets == false)
0BE3  0849     MOVF USBDeferINDataStagePackets, W
0BE4  1D03     BTFSS 0x183, 0x2
0BE5  2BE9     GOTO 0x3E9
1686:                      {
1687:                          USBCtrlEPAllowDataStage();
0BE6  3196     MOVLP 0x16
0BE7  26EB     CALL 0x6EB
0BE8  318B     MOVLP 0xB
1688:          			}
1689:          
1690:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1691:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1692:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1693:                      //    is ready.  If the class request handler does this, it needs to be careful to
1694:                      //    be written so that it can handle the early termination scenario.
1695:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1696:                      //    1.  The desired total number of bytes were sent to the host.
1697:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1698:                      //        started the control transfer) has been reached.
1699:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1700:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1701:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1702:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1703:                      //        option can take care of this for you.
1704:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1705:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1706:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1707:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1708:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1709:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1710:                      USBStatusStageEnabledFlag2 = false;
0BE9  0023     MOVLB 0x3
0BEA  01CE     CLRF USBStatusStageEnabledFlag2
1711:                      USBStatusStageEnabledFlag1 = false;
0BEB  01CD     CLRF USBStatusStageEnabledFlag1
1712:                      if(USBDeferStatusStagePacket == false)
0BEC  084B     MOVF USBDeferStatusStagePacket, W
0BED  1D03     BTFSS 0x183, 0x2
0BEE  0008     RETURN
1713:                      {
1714:                          USBCtrlEPAllowStatusStage();
0BEF  3189     MOVLP 0x9
0BF0  213E     CALL 0x13E
1715:                      } 
1716:          		}
0BF1  0008     RETURN
1717:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1718:          		{
1719:          			//This situation occurs for special types of control transfers,
1720:          			//such as that which occurs when the host sends a SET_ADDRESS
1721:          			//control transfer.  Ex:
1722:          			//
1723:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1724:          				
1725:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1726:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1727:          			//an IN status stage.
1728:          
1729:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
0BF2  3002     MOVLW 0x2
0BF3  00F7     MOVWF 0x1F7
0BF4  0877     MOVF 0x1F7, W
0BF5  0023     MOVLB 0x3
0BF6  00D9     MOVWF controlTransferState
1730:          			
1731:          			//1. Prepare OUT EP to receive the next SETUP packet.
1732:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0BF7  087A     MOVF 0x1FA, W
0BF8  3E01     ADDLW 0x1
0BF9  00F7     MOVWF 0x1F7
0BFA  3000     MOVLW 0x0
0BFB  3D7B     ADDWFC 0x1FB, W
0BFC  00F8     MOVWF 0x1F8
0BFD  0877     MOVF 0x1F7, W
0BFE  0086     MOVWF 0x186
0BFF  0878     MOVF 0x1F8, W
0C00  0087     MOVWF 0x187
0C01  3008     MOVLW 0x8
0C02  0081     MOVWF 0x181
1733:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0C03  30A0     MOVLW 0xA0
0C04  00F7     MOVWF 0x1F7
0C05  3000     MOVLW 0x0
0C06  00F8     MOVWF 0x1F8
0C07  087A     MOVF 0x1FA, W
0C08  0086     MOVWF 0x186
0C09  087B     MOVF 0x1FB, W
0C0A  0087     MOVWF 0x187
0C0B  3142     ADDFSR 1, 2
0C0C  0877     MOVF 0x1F7, W
0C0D  3FC0     MOVWI [0]FSR1
0C0E  0878     MOVF 0x1F8, W
0C0F  3FC1     MOVWI [1]FSR1
1734:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0C10  087A     MOVF 0x1FA, W
0C11  0086     MOVWF 0x186
0C12  087B     MOVF 0x1FB, W
0C13  0087     MOVWF 0x187
0C14  3004     MOVLW 0x4
0C15  0081     MOVWF 0x181
1735:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0C16  087A     MOVF 0x1FA, W
0C17  0086     MOVWF 0x186
0C18  087B     MOVF 0x1FB, W
0C19  0087     MOVWF 0x187
0C1A  1781     BSF 0x181, 0x7
1736:          				
1737:          			//2. Prepare for IN status stage of the control transfer
1738:                      USBStatusStageEnabledFlag2 = false;
0C1B  01CE     CLRF USBStatusStageEnabledFlag2
1739:                      USBStatusStageEnabledFlag1 = false;
0C1C  01CD     CLRF USBStatusStageEnabledFlag1
1740:          			if(USBDeferStatusStagePacket == false)
0C1D  084B     MOVF USBDeferStatusStagePacket, W
0C1E  1D03     BTFSS 0x183, 0x2
0C1F  0008     RETURN
1741:                      {
1742:                          USBCtrlEPAllowStatusStage();
0C20  3189     MOVLP 0x9
0C21  213E     CALL 0x13E
1743:                      } 
1744:          		}
0C22  0008     RETURN
1745:          
1746:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1747:          
1748:          }//end USBCtrlEPServiceComplete
1749:          
1750:          
1751:          /******************************************************************************
1752:           * Function:        void USBCtrlTrfTxService(void)
1753:           *
1754:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1755:           *
1756:           * Input:           None
1757:           *
1758:           * Output:          None
1759:           *
1760:           * Side Effects:    None
1761:           *
1762:           * Overview:        This routine is used for device to host control transfers 
1763:           *					(IN transactions).  This function takes care of managing a
1764:           *                  transfer over multiple USB transactions.
1765:           *					This routine should be called from only two places.
1766:           *                  One from USBCtrlEPServiceComplete() and one from
1767:           *                  USBCtrlTrfInHandler().
1768:           *
1769:           * Note:            
1770:           *****************************************************************************/
1771:          static void USBCtrlTrfTxService(void)
1772:          {
1773:              uint8_t byteToSend;
1774:          
1775:              //Figure out how many bytes of data to send in the next IN transaction.
1776:              //Assume a full size packet, unless otherwise determined below.
1777:              byteToSend = USB_EP0_BUFF_SIZE;         
08D5  3008     MOVLW 0x8
08D6  00F2     MOVWF 0x1F2
08D7  0872     MOVF 0x1F2, W
08D8  00F4     MOVWF 0x1F4
1778:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
08D9  3000     MOVLW 0x0
08DA  0023     MOVLB 0x3
08DB  0235     SUBWF 0x1B5, W
08DC  3008     MOVLW 0x8
08DD  1903     BTFSC 0x183, 0x2
08DE  0234     SUBWF 0x1B4, W
08DF  1803     BTFSC 0x183, 0x0
08E0  28F2     GOTO 0xF2
1779:              {
1780:                  byteToSend = inPipes[0].wCount.Val;
08E1  0834     MOVF 0x1B4, W
08E2  00F2     MOVWF 0x1F2
08E3  0872     MOVF 0x1F2, W
08E4  00F4     MOVWF 0x1F4
1781:          
1782:                  //Keep track of whether or not we have sent a "short packet" yet.
1783:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1784:                  //after we have sent all of the intended data.  This makes sure the
1785:                  //hardware STALLs if the host erroneously tries to send more IN token 
1786:                  //packets, requesting more data than intended in the control transfer.
1787:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
08E5  085F     MOVF shortPacketStatus, W
08E6  1D03     BTFSS 0x183, 0x2
08E7  28EB     GOTO 0xEB
1788:                  {
1789:                      shortPacketStatus = SHORT_PKT_PENDING;
08E8  01DF     CLRF shortPacketStatus
08E9  0ADF     INCF shortPacketStatus, F
1790:                  }
08EA  28F2     GOTO 0xF2
1791:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
08EB  035F     DECF shortPacketStatus, W
08EC  1D03     BTFSS 0x183, 0x2
08ED  28F2     GOTO 0xF2
1792:                  {
1793:                      shortPacketStatus = SHORT_PKT_SENT;
08EE  3002     MOVLW 0x2
08EF  00F2     MOVWF 0x1F2
08F0  0872     MOVF 0x1F2, W
08F1  00DF     MOVWF shortPacketStatus
1794:                  }
1795:              }
1796:          
1797:              //Keep track of how many bytes remain to be sent in the transfer, by
1798:              //subtracting the number of bytes about to be sent from the total.
1799:              inPipes[0].wCount.Val -= byteToSend;
08F2  0874     MOVF 0x1F4, W
08F3  00F2     MOVWF 0x1F2
08F4  01F3     CLRF 0x1F3
08F5  0872     MOVF 0x1F2, W
08F6  02B4     SUBWF 0x1B4, F
08F7  0873     MOVF 0x1F3, W
08F8  3BB5     SUBWFB 0x1B5, F
1800:              
1801:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1802:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1803:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1804:              pBDTEntryIn[0]->CNT = byteToSend;
08F9  0820     MOVF pBDTEntryIn, W
08FA  3E01     ADDLW 0x1
08FB  00F2     MOVWF 0x1F2
08FC  3000     MOVLW 0x0
08FD  3D21     ADDWFC 0x1A1, W
08FE  00F3     MOVWF 0x1F3
08FF  0872     MOVF 0x1F2, W
0900  0086     MOVWF 0x186
0901  0873     MOVF 0x1F3, W
0902  0087     MOVWF 0x187
0903  0874     MOVF 0x1F4, W
0904  0081     MOVWF 0x181
1805:          
1806:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1807:              //which we will send to the host.
1808:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
0905  30A8     MOVLW 0xA8
0906  00F2     MOVWF 0x1F2
0907  0872     MOVF 0x1F2, W
0908  00DD     MOVWF pDst
1809:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
0909  1C33     BTFSS 0x1B3, 0x0
090A  2921     GOTO 0x121
090B  293A     GOTO 0x13A
1810:              {
1811:                  while(byteToSend)
0921  0874     MOVF 0x1F4, W
0922  1903     BTFSC 0x183, 0x2
0923  0008     RETURN
0924  290C     GOTO 0x10C
1812:                  {
1813:                      *pDst++ = *inPipes[0].pSrc.bRom++;
090C  0831     MOVF inPipes, W
090D  0084     MOVWF 0x184
090E  0832     MOVF 0x1B2, W
090F  0085     MOVWF 0x185
0910  0800     MOVF 0x180, W
0911  00F2     MOVWF 0x1F2
0912  085D     MOVF pDst, W
0913  0086     MOVWF 0x186
0914  0187     CLRF 0x187
0915  0872     MOVF 0x1F2, W
0916  0081     MOVWF 0x181
0917  3001     MOVLW 0x1
0918  07B1     ADDWF inPipes, F
0919  3000     MOVLW 0x0
091A  3DB2     ADDWFC 0x1B2, F
091B  3001     MOVLW 0x1
091C  00F2     MOVWF 0x1F2
091D  0872     MOVF 0x1F2, W
091E  07DD     ADDWF pDst, F
1814:                      byteToSend--;
091F  3001     MOVLW 0x1
0920  02F4     SUBWF 0x1F4, F
1815:                  }//end while(byte_to_send.Val)
1816:              }
1817:              else  // RAM
1818:              {
1819:                  while(byteToSend)
093A  0874     MOVF 0x1F4, W
093B  1903     BTFSC 0x183, 0x2
093C  0008     RETURN
093D  2925     GOTO 0x125
1820:                  {
1821:                      *pDst++ = *inPipes[0].pSrc.bRam++;
0925  0831     MOVF inPipes, W
0926  0084     MOVWF 0x184
0927  0832     MOVF 0x1B2, W
0928  0085     MOVWF 0x185
0929  0800     MOVF 0x180, W
092A  00F2     MOVWF 0x1F2
092B  085D     MOVF pDst, W
092C  0086     MOVWF 0x186
092D  0187     CLRF 0x187
092E  0872     MOVF 0x1F2, W
092F  0081     MOVWF 0x181
0930  3001     MOVLW 0x1
0931  07B1     ADDWF inPipes, F
0932  3000     MOVLW 0x0
0933  3DB2     ADDWFC 0x1B2, F
0934  3001     MOVLW 0x1
0935  00F2     MOVWF 0x1F2
0936  0872     MOVF 0x1F2, W
0937  07DD     ADDWF pDst, F
1822:                      byteToSend--;
0938  3001     MOVLW 0x1
0939  02F4     SUBWF 0x1F4, F
1823:                  }//end while(byte_to_send.Val)
1824:              }//end if(usb_stat.ctrl_trf_mem == _const)
1825:          }//end USBCtrlTrfTxService
1826:          
1827:          /******************************************************************************
1828:           * Function:        void USBCtrlTrfRxService(void)
1829:           *
1830:           * PreCondition:    pDst and wCount are setup properly.
1831:           *                  pSrc is always &CtrlTrfData
1832:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1833:           *                  wCount should be set to 0 at the start of each control
1834:           *                  transfer.
1835:           *
1836:           * Input:           None
1837:           *
1838:           * Output:          None
1839:           *
1840:           * Side Effects:    None
1841:           *
1842:           * Overview:        This routine is used for host to device control transfers
1843:           *					(uses OUT transactions).  This function receives the data that arrives
1844:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1845:           *					buffer.  Once the host has sent all the data it was intending
1846:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1847:           *					handler (unless it is NULL), so that it can be used by the
1848:           *					intended target firmware.
1849:           *
1850:           * Note:            None
1851:           *****************************************************************************/
1852:          static void USBCtrlTrfRxService(void)
1853:          {
1854:              uint8_t byteToRead;
1855:              uint8_t i;
1856:          
1857:              //Load byteToRead with the number of bytes the host just sent us in the 
1858:              //last OUT transaction.
1859:              byteToRead = pBDTEntryEP0OutCurrent->CNT;   
0F3E  0023     MOVLB 0x3
0F3F  085C     MOVF pBDTEntryEP0OutCurrent, W
0F40  0086     MOVWF 0x186
0F41  0187     CLRF 0x187
0F42  3F41     MOVIW [1]FSR1
0F43  0022     MOVLB 0x2
0F44  00EE     MOVWF byteToRead
1860:          
1861:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1862:              //of remaining bytes expected to be received from the host, in the control
1863:              //transfer.  First check to see if the host sent us more bytes than the
1864:              //application firmware was expecting to receive.
1865:              if(byteToRead > outPipes[0].wCount.Val)
0F45  086E     MOVF byteToRead, W
0F46  0021     MOVLB 0x1
0F47  00ED     MOVWF ziffer
0F48  01EE     CLRF pI_mA
0F49  086E     MOVF pI_mA, W
0F4A  0023     MOVLB 0x3
0F4B  022E     SUBWF 0x1AE, W
0F4C  1D03     BTFSS 0x183, 0x2
0F4D  2F52     GOTO 0x752
0F4E  0021     MOVLB 0x1
0F4F  086D     MOVF ziffer, W
0F50  0023     MOVLB 0x3
0F51  022D     SUBWF 0x1AD, W
0F52  1803     BTFSC 0x183, 0x0
0F53  2F5A     GOTO 0x75A
1866:              {
1867:                  byteToRead = outPipes[0].wCount.Val;
0F54  082D     MOVF 0x1AD, W
0F55  0021     MOVLB 0x1
0F56  00ED     MOVWF ziffer
0F57  086D     MOVF ziffer, W
0F58  0022     MOVLB 0x2
0F59  00EE     MOVWF byteToRead
1868:              }	
1869:              //Reduce the number of remaining bytes by the number we just received.
1870:              outPipes[0].wCount.Val -= byteToRead;
0F5A  0022     MOVLB 0x2
0F5B  086E     MOVF byteToRead, W
0F5C  0021     MOVLB 0x1
0F5D  00ED     MOVWF ziffer
0F5E  01EE     CLRF pI_mA
0F5F  086D     MOVF ziffer, W
0F60  0023     MOVLB 0x3
0F61  02AD     SUBWF 0x1AD, F
0F62  0021     MOVLB 0x1
0F63  086E     MOVF pI_mA, W
0F64  0023     MOVLB 0x3
0F65  3BAE     SUBWFB 0x1AE, F
1871:          
1872:              //Copy the OUT DATAx packet bytes that we just received from the host,
1873:              //into the user application buffer space.
1874:              for(i=0;i<byteToRead;i++)
0F66  0022     MOVLB 0x2
0F67  01ED     CLRF i
0F68  086E     MOVF byteToRead, W
0F69  026D     SUBWF i, W
0F6A  1803     BTFSC 0x103, 0x0
0F6B  2F87     GOTO 0x787
0F80  3001     MOVLW 0x1
0F81  0021     MOVLB 0x1
0F82  00ED     MOVWF ziffer
0F83  086D     MOVF ziffer, W
0F84  0022     MOVLB 0x2
0F85  07ED     ADDWF i, F
0F86  2F68     GOTO 0x768
1875:              {
1876:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
0F6C  086D     MOVF i, W
0F6D  3EA8     ADDLW 0xA8
0F6E  0086     MOVWF 0x106
0F6F  0187     CLRF 0x107
0F70  0801     MOVF 0x101, W
0F71  0021     MOVLB 0x1
0F72  00ED     MOVWF ziffer
0F73  0023     MOVLB 0x3
0F74  082A     MOVF outPipes, W
0F75  0086     MOVWF 0x186
0F76  3002     MOVLW 0x2
0F77  0087     MOVWF 0x187
0F78  0021     MOVLB 0x1
0F79  086D     MOVF ziffer, W
0F7A  0081     MOVWF 0x81
0F7B  3001     MOVLW 0x1
0F7C  00ED     MOVWF ziffer
0F7D  086D     MOVF ziffer, W
0F7E  0023     MOVLB 0x3
0F7F  07AA     ADDWF outPipes, F
1877:              }//end while(byteToRead.Val)
1878:          
1879:              //If there is more data to receive, prepare EP0 OUT so that it can receive 
1880:          	//the next packet in the sequence.
1881:              if(outPipes[0].wCount.Val > 0)
0F87  0023     MOVLB 0x3
0F88  082D     MOVF 0x1AD, W
0F89  042E     IORWF 0x1AE, W
0F8A  1903     BTFSC 0x183, 0x2
0F8B  2FC4     GOTO 0x7C4
1882:              {
1883:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0F8C  087A     MOVF 0x1FA, W
0F8D  3E01     ADDLW 0x1
0F8E  0021     MOVLB 0x1
0F8F  00ED     MOVWF ziffer
0F90  3000     MOVLW 0x0
0F91  3D7B     ADDWFC 0xFB, W
0F92  00EE     MOVWF pI_mA
0F93  086D     MOVF ziffer, W
0F94  0086     MOVWF 0x86
0F95  086E     MOVF pI_mA, W
0F96  0087     MOVWF 0x87
0F97  3008     MOVLW 0x8
0F98  0081     MOVWF 0x81
1884:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0F99  30A8     MOVLW 0xA8
0F9A  00ED     MOVWF ziffer
0F9B  3000     MOVLW 0x0
0F9C  00EE     MOVWF pI_mA
0F9D  087A     MOVF 0xFA, W
0F9E  0086     MOVWF 0x86
0F9F  087B     MOVF 0xFB, W
0FA0  0087     MOVWF 0x87
0FA1  3142     ADDFSR 1, 2
0FA2  086D     MOVF ziffer, W
0FA3  3FC0     MOVWI [0]FSR1
0FA4  086E     MOVF pI_mA, W
0FA5  3FC1     MOVWI [1]FSR1
1885:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
0FA6  0023     MOVLB 0x3
0FA7  085C     MOVF pBDTEntryEP0OutCurrent, W
0FA8  0086     MOVWF 0x186
0FA9  0187     CLRF 0x187
0FAA  1B01     BTFSC 0x181, 0x6
0FAB  2FB8     GOTO 0x7B8
1886:                  {
1887:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0FAC  087A     MOVF 0x1FA, W
0FAD  0086     MOVWF 0x186
0FAE  087B     MOVF 0x1FB, W
0FAF  0087     MOVWF 0x187
0FB0  3048     MOVLW 0x48
0FB1  0081     MOVWF 0x181
1888:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FB2  087A     MOVF 0x1FA, W
0FB3  0086     MOVWF 0x186
0FB4  087B     MOVF 0x1FB, W
0FB5  0087     MOVWF 0x187
0FB6  1781     BSF 0x181, 0x7
1889:                  }
0FB7  0008     RETURN
1890:                  else
1891:                  {
1892:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0FB8  087A     MOVF 0x1FA, W
0FB9  0086     MOVWF 0x186
0FBA  087B     MOVF 0x1FB, W
0FBB  0087     MOVWF 0x187
0FBC  3008     MOVLW 0x8
0FBD  0081     MOVWF 0x181
1893:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FBE  087A     MOVF 0x1FA, W
0FBF  0086     MOVWF 0x186
0FC0  087B     MOVF 0x1FB, W
0FC1  0087     MOVWF 0x187
0FC2  1781     BSF 0x181, 0x7
1894:                  }
1895:              }
0FC3  0008     RETURN
1896:              else
1897:              {
1898:          	    //We have received all OUT packets that we were expecting to
1899:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1900:          		//the next SETUP transaction that may arrive.
1901:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0FC4  087A     MOVF 0x1FA, W
0FC5  3E01     ADDLW 0x1
0FC6  0021     MOVLB 0x1
0FC7  00ED     MOVWF ziffer
0FC8  3000     MOVLW 0x0
0FC9  3D7B     ADDWFC 0xFB, W
0FCA  00EE     MOVWF pI_mA
0FCB  086D     MOVF ziffer, W
0FCC  0086     MOVWF 0x86
0FCD  086E     MOVF pI_mA, W
0FCE  0087     MOVWF 0x87
0FCF  3008     MOVLW 0x8
0FD0  0081     MOVWF 0x81
1902:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0FD1  30A0     MOVLW 0xA0
0FD2  00ED     MOVWF ziffer
0FD3  3000     MOVLW 0x0
0FD4  00EE     MOVWF pI_mA
0FD5  087A     MOVF 0xFA, W
0FD6  0086     MOVWF 0x86
0FD7  087B     MOVF 0xFB, W
0FD8  0087     MOVWF 0x87
0FD9  3142     ADDFSR 1, 2
0FDA  086D     MOVF ziffer, W
0FDB  3FC0     MOVWI [0]FSR1
0FDC  086E     MOVF pI_mA, W
0FDD  3FC1     MOVWI [1]FSR1
1903:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1904:                  //control transfers.  However, set BSTALL in case the host tries to send
1905:                  //more data than it claims it was going to send.
1906:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0FDE  087A     MOVF 0xFA, W
0FDF  0086     MOVWF 0x86
0FE0  087B     MOVF 0xFB, W
0FE1  0087     MOVWF 0x87
0FE2  3004     MOVLW 0x4
0FE3  0081     MOVWF 0x81
1907:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FE4  087A     MOVF 0xFA, W
0FE5  0086     MOVWF 0x86
0FE6  087B     MOVF 0xFB, W
0FE7  0087     MOVWF 0x87
0FE8  1781     BSF 0x81, 0x7
1908:          
1909:          		//All data bytes for the host to device control write (OUT) have now been
1910:          		//received successfully.
1911:          		//Go ahead and call the user specified callback function, to use/consume
1912:          		//the control transfer data (ex: if the "void (*function)" parameter 
1913:          		//was non-NULL when USBEP0Receive() was called).
1914:                  if(outPipes[0].pFunc != NULL)
0FE9  0023     MOVLB 0x3
0FEA  082F     MOVF 0x1AF, W
0FEB  0430     IORWF 0x1B0, W
0FEC  1903     BTFSC 0x183, 0x2
0FED  2FF8     GOTO 0x7F8
1915:                  {
1916:                      #if defined(__XC8)
1917:                          //Special pragmas to suppress an expected/harmless warning
1918:                          //message when building with the XC8 compiler
1919:                          #pragma warning push
1920:                          #pragma warning disable 1088
1921:                          outPipes[0].pFunc();    //Call the user's callback function
0FEE  3005     MOVLW 0x5
0FEF  3EAA     ADDLW 0xAA
0FF0  0086     MOVWF 0x186
0FF1  3001     MOVLW 0x1
0FF2  0087     MOVWF 0x187
0FF3  3F41     MOVIW [1]FSR1
0FF4  008A     MOVWF 0x18A
0FF5  3F40     MOVIW [0]FSR1
0FF6  000A     CALLW
0FF7  318F     MOVLP 0xF
1922:                          #pragma warning pop
1923:                      #else
1924:                          outPipes[0].pFunc();    //Call the user's callback function
1925:                      #endif
1926:                  }
1927:                  outPipes[0].info.bits.busy = 0;    
0FF8  0023     MOVLB 0x3
0FF9  13AC     BCF 0x1AC, 0x7
1928:          
1929:                  //Ready to arm status stage IN transaction now, if the application
1930:                  //firmware has completed processing the request.  If it is still busy
1931:                  //and needs more time to finish handling the request, then the user
1932:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1933:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1934:                  //this case, it is the application's firmware responsibility to call 
1935:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1936:                  //Note: The application firmware must process the request and call
1937:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1938:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1939:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1940:                  //more details.
1941:                  if(USBDeferStatusStagePacket == false)
0FFA  084B     MOVF USBDeferStatusStagePacket, W
0FFB  1D03     BTFSS 0x183, 0x2
0FFC  0008     RETURN
1942:                  {
1943:                      USBCtrlEPAllowStatusStage();
0FFD  3189     MOVLP 0x9
0FFE  213E     CALL 0x13E
1944:                  }            
0FFF  0008     RETURN
1945:              }    
1946:          
1947:          }//end USBCtrlTrfRxService
1948:          
1949:          
1950:          /********************************************************************
1951:           * Function:        void USBStdSetCfgHandler(void)
1952:           *
1953:           * PreCondition:    None
1954:           *
1955:           * Input:           None
1956:           *
1957:           * Output:          None
1958:           *
1959:           * Side Effects:    None
1960:           *
1961:           * Overview:        This routine first disables all endpoints by
1962:           *                  clearing UEP registers. It then configures
1963:           *                  (initializes) endpoints by calling the callback
1964:           *                  function USBCBInitEP().
1965:           *
1966:           * Note:            None
1967:           *******************************************************************/
1968:          static void USBStdSetCfgHandler(void)
1969:          {
1970:              uint8_t i;
1971:          
1972:              // This will generate a zero length packet
1973:              inPipes[0].info.bits.busy = 1;            
0CB4  0023     MOVLB 0x3
0CB5  17B3     BSF 0x1B3, 0x7
1974:          
1975:              //Clear all of the endpoint control registers
1976:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0CB6  300E     MOVLW 0xE
0CB7  0022     MOVLB 0x2
0CB8  00E1     MOVWF sign
0CB9  3099     MOVLW 0x99
0CBA  00E0     MOVWF __pcstackBANK2
0CBB  01E2     CLRF i
0CBC  3004     MOVLW 0x4
0CBD  0262     SUBWF i, W
0CBE  1803     BTFSC 0x103, 0x0
0CBF  2CD3     GOTO 0x4D3
0CC0  0860     MOVF __pcstackBANK2, W
0CC1  0086     MOVWF 0x106
0CC2  0861     MOVF sign, W
0CC3  0087     MOVWF 0x107
0CC4  0181     CLRF 0x101
0CC5  3001     MOVLW 0x1
0CC6  07E0     ADDWF __pcstackBANK2, F
0CC7  3000     MOVLW 0x0
0CC8  3DE1     ADDWFC sign, F
0CC9  3001     MOVLW 0x1
0CCA  0021     MOVLB 0x1
0CCB  00EC     MOVWF powerOfTen
0CCC  086C     MOVF powerOfTen, W
0CCD  0022     MOVLB 0x2
0CCE  07E2     ADDWF i, F
0CCF  3004     MOVLW 0x4
0CD0  0262     SUBWF i, W
0CD1  1C03     BTFSS 0x103, 0x0
0CD2  2CC0     GOTO 0x4C0
1977:          
1978:              //Clear all of the BDT entries
1979:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
0CD3  3020     MOVLW 0x20
0CD4  00F2     MOVWF 0x172
0CD5  3000     MOVLW 0x0
0CD6  00F3     MOVWF 0x173
0CD7  3000     MOVLW 0x0
0CD8  00F4     MOVWF 0x174
0CD9  00F5     MOVWF 0x175
0CDA  3050     MOVLW 0x50
0CDB  00F6     MOVWF 0x176
0CDC  3000     MOVLW 0x0
0CDD  00F7     MOVWF 0x177
0CDE  3192     MOVLP 0x12
0CDF  2270     CALL 0x270
0CE0  318C     MOVLP 0xC
1980:          
1981:              // Assert reset request to all of the Ping Pong buffer pointers
1982:              USBPingPongBufferReset = 1;                                   
0CE1  003D     MOVLB 0x1D
0CE2  170E     BSF UCON, 0x6
1983:          
1984:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1985:          	//the EVEN buffer being the next one that will be used), since we are also 
1986:          	//doing a hardware ping pong pointer reset above.
1987:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0CE3  0022     MOVLB 0x2
0CE4  01E3     CLRF i
0CE5  3005     MOVLW 0x5
0CE6  0263     SUBWF i, W
0CE7  1803     BTFSC 0x103, 0x0
0CE8  2CFF     GOTO 0x4FF
0CF5  3001     MOVLW 0x1
0CF6  0021     MOVLB 0x1
0CF7  00EC     MOVWF powerOfTen
0CF8  086C     MOVF powerOfTen, W
0CF9  0022     MOVLB 0x2
0CFA  07E3     ADDWF i, F
0CFB  3005     MOVLW 0x5
0CFC  0263     SUBWF i, W
0CFD  1C03     BTFSS 0x103, 0x0
0CFE  2CE9     GOTO 0x4E9
1988:          	{
1989:          		ep_data_in[i].Val = 0u;
0CE9  0863     MOVF i, W
0CEA  3E2A     ADDLW 0x2A
0CEB  0086     MOVWF 0x106
0CEC  3002     MOVLW 0x2
0CED  0087     MOVWF 0x107
0CEE  0181     CLRF 0x101
1990:                  ep_data_out[i].Val = 0u;
0CEF  0863     MOVF i, W
0CF0  3E2F     ADDLW 0x2F
0CF1  0086     MOVWF 0x106
0CF2  3002     MOVLW 0x2
0CF3  0087     MOVWF 0x107
0CF4  0181     CLRF 0x101
1991:          	}
1992:          
1993:              //clear the alternate interface settings
1994:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0CFF  3065     MOVLW 0x65
0D00  00F2     MOVWF 0x172
0D01  3002     MOVLW 0x2
0D02  00F3     MOVWF 0x173
0D03  3000     MOVLW 0x0
0D04  00F4     MOVWF 0x174
0D05  00F5     MOVWF 0x175
0D06  3002     MOVLW 0x2
0D07  00F6     MOVWF 0x176
0D08  3000     MOVLW 0x0
0D09  00F7     MOVWF 0x177
0D0A  3192     MOVLP 0x12
0D0B  2270     CALL 0x270
0D0C  318C     MOVLP 0xC
1995:          
1996:              //Stop trying to reset ping pong buffer pointers
1997:              USBPingPongBufferReset = 0;
0D0D  003D     MOVLB 0x1D
0D0E  130E     BCF UCON, 0x6
1998:          
1999:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0D0F  3028     MOVLW 0x28
0D10  0023     MOVLB 0x3
0D11  00A0     MOVWF pBDTEntryIn
0D12  3000     MOVLW 0x0
0D13  00A1     MOVWF 0x1A1
2000:          
2001:          	//Set the next out to the current out packet
2002:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0D14  3020     MOVLW 0x20
0D15  0021     MOVLB 0x1
0D16  00EC     MOVWF powerOfTen
0D17  086C     MOVF powerOfTen, W
0D18  0023     MOVLB 0x3
0D19  00DC     MOVWF pBDTEntryEP0OutCurrent
2003:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0D1A  085C     MOVF pBDTEntryEP0OutCurrent, W
0D1B  00FA     MOVWF 0x1FA
0D1C  39FF     ANDLW 0xFF
0D1D  1D03     BTFSS 0x183, 0x2
0D1E  3000     MOVLW 0x0
0D1F  00FB     MOVWF 0x1FB
2004:          
2005:              //set the current configuration
2006:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0D20  0021     MOVLB 0x1
0D21  0822     MOVF 0xA2, W
0D22  00EC     MOVWF powerOfTen
0D23  086C     MOVF powerOfTen, W
0D24  0023     MOVLB 0x3
0D25  00E7     MOVWF USBActiveConfiguration
2007:          
2008:              //if the configuration value == 0
2009:              if(USBActiveConfiguration == 0)
0D26  0867     MOVF USBActiveConfiguration, W
0D27  1D03     BTFSS 0x183, 0x2
0D28  2D30     GOTO 0x530
2010:              {
2011:                  //Go back to the addressed state
2012:                  USBDeviceState = ADDRESS_STATE;
0D29  3010     MOVLW 0x10
0D2A  0021     MOVLB 0x1
0D2B  00EC     MOVWF powerOfTen
0D2C  086C     MOVF powerOfTen, W
0D2D  0023     MOVLB 0x3
0D2E  00CC     MOVWF USBDeviceState
2013:              }
0D2F  0008     RETURN
2014:              else
2015:              {
2016:                  //initialize the required endpoints
2017:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0D30  3000     MOVLW 0x0
0D31  0021     MOVLB 0x1
0D32  00E7     MOVWF 0xE7
0D33  3001     MOVLW 0x1
0D34  00E6     MOVWF buffer
0D35  30E7     MOVLW 0xE7
0D36  00E8     MOVWF dividend
0D37  3001     MOVLW 0x1
0D38  00E9     MOVWF 0xE9
0D39  3001     MOVLW 0x1
0D3A  00EA     MOVWF strIncremet
0D3B  3000     MOVLW 0x0
0D3C  00EB     MOVWF str
0D3D  3194     MOVLP 0x14
0D3E  2481     CALL 0x481
2018:          
2019:                  //Otherwise go to the configured state.  Update the state variable last,
2020:                  //after performing all of the set configuration related initialization
2021:                  //tasks.
2022:                  USBDeviceState = CONFIGURED_STATE;		
0D3F  3020     MOVLW 0x20
2023:              }//end if(SetupPkt.bConfigurationValue == 0)
2024:          }//end USBStdSetCfgHandler
2025:          
2026:          
2027:          /********************************************************************
2028:           * Function:        void USBStdGetDscHandler(void)
2029:           *
2030:           * PreCondition:    None
2031:           *
2032:           * Input:           None
2033:           *
2034:           * Output:          None
2035:           *
2036:           * Side Effects:    None
2037:           *
2038:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2039:           *                  request.
2040:           *
2041:           * Note:            None
2042:           *******************************************************************/
2043:          static void USBStdGetDscHandler(void)
2044:          {
2045:              if(SetupPkt.bmRequestType == 0x80)
0A96  3080     MOVLW 0x80
0A97  0021     MOVLB 0x1
0A98  0620     XORWF SetupPkt, W
0A99  1D03     BTFSS 0x83, 0x2
0A9A  0008     RETURN
2046:              {
2047:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0A9B  30C0     MOVLW 0xC0
0A9C  00F2     MOVWF 0xF2
0A9D  0872     MOVF 0xF2, W
0A9E  0023     MOVLB 0x3
0A9F  00B3     MOVWF 0x1B3
2048:          
2049:                  switch(SetupPkt.bDescriptorType)
0AA0  2B08     GOTO 0x308
0B08  0021     MOVLB 0x1
0B09  0823     MOVF 0xA3, W
0B0A  3A01     XORLW 0x1
0B0B  1903     BTFSC 0x83, 0x2
0B0C  2AA1     GOTO 0x2A1
0B0D  3A03     XORLW 0x3
0B0E  1903     BTFSC 0x83, 0x2
0B0F  2AAB     GOTO 0x2AB
0B10  3A01     XORLW 0x1
0B11  1903     BTFSC 0x83, 0x2
0B12  2AE1     GOTO 0x2E1
0B13  2B05     GOTO 0x305
2050:                  {
2051:                      case USB_DESCRIPTOR_DEVICE:
2052:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2053:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2054:                          #else
2055:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0AA1  3040     MOVLW 0x40
0AA2  0023     MOVLB 0x3
0AA3  00B1     MOVWF inPipes
0AA4  3082     MOVLW 0x82
0AA5  00B2     MOVWF 0x1B2
2056:                          #endif
2057:                          inPipes[0].wCount.Val = sizeof(device_dsc);
0AA6  3012     MOVLW 0x12
0AA7  00B4     MOVWF 0x1B4
0AA8  3000     MOVLW 0x0
0AA9  00B5     MOVWF 0x1B5
2058:                          break;
0AAA  0008     RETURN
2059:                      case USB_DESCRIPTOR_CONFIGURATION:
2060:                          //First perform error case check, to make sure the host is requesting a 
2061:                          //legal descriptor index.  If the request index is illegal, don't do 
2062:                          //anything (so that the default STALL response will be sent).
2063:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0AAB  0021     MOVLB 0x1
0AAC  0822     MOVF 0xA2, W
0AAD  1D03     BTFSS 0x83, 0x2
0AAE  2ADE     GOTO 0x2DE
2064:                          {
2065:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2066:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2067:                              #else
2068:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0AAF  0822     MOVF 0xA2, W
0AB0  00F2     MOVWF 0xF2
0AB1  01F3     CLRF 0xF3
0AB2  35F2     LSLF 0xF2, F
0AB3  0DF3     RLF 0xF3, F
0AB4  3001     MOVLW 0x1
0AB5  0772     ADDWF 0xF2, W
0AB6  0084     MOVWF 0x84
0AB7  3081     MOVLW 0x81
0AB8  3D73     ADDWFC 0xF3, W
0AB9  0085     MOVWF 0x85
0ABA  3F00     MOVIW [0]FSR0
0ABB  0023     MOVLB 0x3
0ABC  00B1     MOVWF inPipes
0ABD  3F01     MOVIW [1]FSR0
0ABE  00B2     MOVWF 0x1B2
2069:                              #endif
2070:          
2071:                              //This must be loaded using byte addressing.  The source pointer
2072:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2073:                              //  in an address error on the dereference.
2074:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0ABF  0832     MOVF 0x1B2, W
0AC0  00F3     MOVWF 0x1F3
0AC1  0831     MOVF inPipes, W
0AC2  00F2     MOVWF 0x1F2
0AC3  3002     MOVLW 0x2
0AC4  0772     ADDWF 0x1F2, W
0AC5  0084     MOVWF 0x184
0AC6  0873     MOVF 0x1F3, W
0AC7  1803     BTFSC 0x183, 0x0
0AC8  0A73     INCF 0x1F3, W
0AC9  0085     MOVWF 0x185
0ACA  0800     MOVF 0x180, W
0ACB  00F4     MOVWF 0x1F4
0ACC  0874     MOVF 0x1F4, W
0ACD  00B4     MOVWF 0x1B4
2075:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0ACE  0832     MOVF 0x1B2, W
0ACF  00F3     MOVWF 0x1F3
0AD0  0831     MOVF inPipes, W
0AD1  00F2     MOVWF 0x1F2
0AD2  3003     MOVLW 0x3
0AD3  0772     ADDWF 0x1F2, W
0AD4  0084     MOVWF 0x184
0AD5  0873     MOVF 0x1F3, W
0AD6  1803     BTFSC 0x183, 0x0
0AD7  0A73     INCF 0x1F3, W
0AD8  0085     MOVWF 0x185
0AD9  0800     MOVF 0x180, W
0ADA  00F4     MOVWF 0x1F4
0ADB  0874     MOVF 0x1F4, W
0ADC  00B5     MOVWF 0x1B5
2076:                          }
0ADD  0008     RETURN
2077:          				else
2078:          				{
2079:          					inPipes[0].info.Val = 0;
0ADE  0023     MOVLB 0x3
0ADF  01B3     CLRF 0x1B3
2080:          				}
2081:                          break;
0AE0  0008     RETURN
2082:                      case USB_DESCRIPTOR_STRING:
2083:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2084:                          //  later it is now mandatory.  This should be defined in usb_config.h and should
2085:                          //  indicate the number of string descriptors.
2086:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0AE1  3005     MOVLW 0x5
0AE2  0021     MOVLB 0x1
0AE3  0222     SUBWF 0xA2, W
0AE4  1803     BTFSC 0x83, 0x0
0AE5  2B02     GOTO 0x302
2087:                          {
2088:                              //Get a pointer to the String descriptor requested
2089:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0AE6  0822     MOVF 0xA2, W
0AE7  00F2     MOVWF 0xF2
0AE8  01F3     CLRF 0xF3
0AE9  35F2     LSLF 0xF2, F
0AEA  0DF3     RLF 0xF3, F
0AEB  30F2     MOVLW 0xF2
0AEC  0772     ADDWF 0xF2, W
0AED  0084     MOVWF 0x84
0AEE  3080     MOVLW 0x80
0AEF  3D73     ADDWFC 0xF3, W
0AF0  0085     MOVWF 0x85
0AF1  3F00     MOVIW [0]FSR0
0AF2  0023     MOVLB 0x3
0AF3  00B1     MOVWF inPipes
0AF4  3F01     MOVIW [1]FSR0
0AF5  00B2     MOVWF 0x1B2
2090:                              // Set data count
2091:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
0AF6  0831     MOVF inPipes, W
0AF7  0084     MOVWF 0x184
0AF8  0832     MOVF 0x1B2, W
0AF9  0085     MOVWF 0x185
0AFA  0800     MOVF 0x180, W
0AFB  00F2     MOVWF 0x1F2
0AFC  01F3     CLRF 0x1F3
0AFD  0872     MOVF 0x1F2, W
0AFE  00B4     MOVWF 0x1B4
0AFF  0873     MOVF 0x1F3, W
0B00  00B5     MOVWF 0x1B5
2092:                          }
0B01  0008     RETURN
2093:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2094:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2095:                          {
2096:                              //Get a pointer to the special MS OS string descriptor requested
2097:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2098:                              // Set data count
2099:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2100:                          }    
2101:                          #endif
2102:                          else
2103:                          {
2104:                              inPipes[0].info.Val = 0;
0B02  0023     MOVLB 0x3
0B03  01B3     CLRF 0x1B3
2105:                          }
2106:                          break;
0B04  0008     RETURN
2107:                      default:
2108:                          inPipes[0].info.Val = 0;
0B05  0023     MOVLB 0x3
0B06  01B3     CLRF 0x1B3
2109:                          break;
2110:                  }//end switch
0B07  0008     RETURN
0B14  0008     RETURN
2111:              }//end if
2112:          }//end USBStdGetDscHandler
2113:          
2114:          /********************************************************************
2115:           * Function:        void USBStdGetStatusHandler(void)
2116:           *
2117:           * PreCondition:    None
2118:           *
2119:           * Input:           None
2120:           *
2121:           * Output:          None
2122:           *
2123:           * Side Effects:    None
2124:           *
2125:           * Overview:        This routine handles the standard GET_STATUS request
2126:           *
2127:           * Note:            None
2128:           *******************************************************************/
2129:          static void USBStdGetStatusHandler(void)
2130:          {
2131:              CtrlTrfData[0] = 0;                 // Initialize content
15E4  0021     MOVLB 0x1
15E5  01A8     CLRF CtrlTrfData
2132:              CtrlTrfData[1] = 0;
15E6  01A9     CLRF 0xA9
2133:          
2134:              switch(SetupPkt.Recipient)
15E7  2E20     GOTO 0x620
1620  0820     MOVF SetupPkt, W
1621  391F     ANDLW 0x1F
1622  3A00     XORLW 0x0
1623  1903     BTFSC 0x83, 0x2
1624  2DE8     GOTO 0x5E8
1625  3A01     XORLW 0x1
1626  1903     BTFSC 0x83, 0x2
1627  2DF1     GOTO 0x5F1
1628  3A03     XORLW 0x3
1629  1903     BTFSC 0x83, 0x2
162A  2DF4     GOTO 0x5F4
162B  2E2C     GOTO 0x62C
2135:              {
2136:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2137:                      inPipes[0].info.bits.busy = 1;
15E8  0023     MOVLB 0x3
15E9  17B3     BSF 0x1B3, 0x7
2138:                      /*
2139:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2140:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2141:                       */
2142:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2143:                      {
2144:                          CtrlTrfData[0]|=0x01;
2145:                      }
2146:          
2147:                      if(RemoteWakeup == true)
15EA  0023     MOVLB 0x3
15EB  0347     DECF RemoteWakeup, W
15EC  1D03     BTFSS 0x183, 0x2
15ED  2E2C     GOTO 0x62C
2148:                      {
2149:                          CtrlTrfData[0]|=0x02;
15EE  0021     MOVLB 0x1
15EF  14A8     BSF CtrlTrfData, 0x1
2150:                      }
2151:                      break;
15F0  2E2C     GOTO 0x62C
2152:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2153:                      inPipes[0].info.bits.busy = 1;     // No data to update
15F1  0023     MOVLB 0x3
15F2  17B3     BSF 0x1B3, 0x7
2154:                      break;
15F3  2E2C     GOTO 0x62C
2155:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2156:                      inPipes[0].info.bits.busy = 1;
15F4  0023     MOVLB 0x3
15F5  17B3     BSF 0x1B3, 0x7
2157:                      /*
2158:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2159:                       */
2160:                      {
2161:                          BDT_ENTRY *p;
2162:          
2163:                          if(SetupPkt.EPDir == 0)
15F6  0021     MOVLB 0x1
15F7  1BA4     BTFSC 0xA4, 0x7
15F8  2E04     GOTO 0x604
2164:                          {
2165:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
15F9  0824     MOVF 0xA4, W
15FA  390F     ANDLW 0xF
15FB  0709     ADDWF 0x89, W
15FC  3E20     ADDLW 0x20
15FD  0086     MOVWF 0x86
15FE  3002     MOVLW 0x2
15FF  0087     MOVWF 0x87
1600  3F40     MOVIW [0]FSR1
1601  00F3     MOVWF 0xF3
1602  3F41     MOVIW [1]FSR1
1603  2E0E     GOTO 0x60E
2166:                          }
2167:                          else
2168:                          {
2169:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
1604  0824     MOVF 0xA4, W
1605  390F     ANDLW 0xF
1606  0709     ADDWF 0x89, W
1607  3EA0     ADDLW 0xA0
1608  0086     MOVWF 0x86
1609  3001     MOVLW 0x1
160A  0087     MOVWF 0x87
160B  3F40     MOVIW [0]FSR1
160C  00F3     MOVWF 0xF3
160D  3F41     MOVIW [1]FSR1
160E  00F4     MOVWF 0xF4
2170:                          }
2171:          
2172:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
160F  0873     MOVF 0xF3, W
1610  0086     MOVWF 0x86
1611  0874     MOVF 0xF4, W
1612  0087     MOVWF 0x87
1613  1F81     BTFSS 0x81, 0x7
1614  2E2C     GOTO 0x62C
1615  0873     MOVF 0xF3, W
1616  0086     MOVWF 0x86
1617  0874     MOVF 0xF4, W
1618  0087     MOVWF 0x87
1619  1D01     BTFSS 0x81, 0x2
161A  2E2C     GOTO 0x62C
2173:                              CtrlTrfData[0]=0x01;    // Set bit0
161B  3001     MOVLW 0x1
161C  00F2     MOVWF 0xF2
161D  0872     MOVF 0xF2, W
161E  00A8     MOVWF CtrlTrfData
2174:                          break;
2175:                      }
2176:              }//end switch
161F  2E2C     GOTO 0x62C
2177:          
2178:              if(inPipes[0].info.bits.busy == 1)
162C  0023     MOVLB 0x3
162D  1FB3     BTFSS 0x1B3, 0x7
162E  0008     RETURN
2179:              {
2180:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
162F  30A8     MOVLW 0xA8
1630  00B1     MOVWF inPipes
1631  3000     MOVLW 0x0
1632  00B2     MOVWF 0x1B2
2181:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
1633  1433     BSF 0x1B3, 0x0
2182:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
1634  3002     MOVLW 0x2
2183:              }//end if(...)
2184:          }//end USBStdGetStatusHandler
2185:          
2186:          /********************************************************************
2187:           * Function:        void USBStallHandler(void)
2188:           *
2189:           * PreCondition:    None
2190:           *
2191:           * Input:           None
2192:           *
2193:           * Output:          None
2194:           *
2195:           * Side Effects:    
2196:           *
2197:           * Overview:        This function handles the event of a STALL 
2198:           *                  occurring on the bus
2199:           *
2200:           * Note:            None
2201:           *******************************************************************/
2202:          static void USBStallHandler(void)
2203:          {
2204:              /*
2205:               * Does not really have to do anything here,
2206:               * even for the control endpoint.
2207:               * All BDs of Endpoint 0 are owned by SIE right now,
2208:               * but once a Setup Transaction is received, the ownership
2209:               * for EP0_OUT will be returned to CPU.
2210:               * When the Setup Transaction is serviced, the ownership
2211:               * for EP0_IN will then be forced back to CPU by firmware.
2212:               */
2213:          
2214:              if(U1EP0bits.EPSTALL == 1)
135A  003D     MOVLB 0x1D
135B  1C18     BTFSS UEP0, 0x0
135C  2B7A     GOTO 0x37A
2215:              {
2216:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2217:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
135D  0023     MOVLB 0x3
135E  085C     MOVF pBDTEntryEP0OutCurrent, W
135F  0086     MOVWF 0x186
1360  0187     CLRF 0x187
1361  3080     MOVLW 0x80
1362  0601     XORWF 0x181, W
1363  1D03     BTFSS 0x183, 0x2
1364  2B78     GOTO 0x378
1365  0820     MOVF pBDTEntryIn, W
1366  0086     MOVWF 0x186
1367  0821     MOVF 0x1A1, W
1368  0087     MOVWF 0x187
1369  3084     MOVLW 0x84
136A  0601     XORWF 0x181, W
136B  1D03     BTFSS 0x183, 0x2
136C  2B78     GOTO 0x378
2218:                  {
2219:                      // Set ep0Bo to stall also
2220:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
136D  300C     MOVLW 0xC
136E  00F2     MOVWF 0x1F2
136F  085C     MOVF pBDTEntryEP0OutCurrent, W
1370  0086     MOVWF 0x186
1371  0187     CLRF 0x187
1372  0872     MOVF 0x1F2, W
1373  0081     MOVWF 0x181
2221:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
1374  085C     MOVF pBDTEntryEP0OutCurrent, W
1375  0086     MOVWF 0x186
1376  0187     CLRF 0x187
1377  1781     BSF 0x181, 0x7
2222:                  }//end if
2223:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
1378  003D     MOVLB 0x1D
1379  1018     BCF UEP0, 0x0
2224:              }//end if
2225:          
2226:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
137A  30DF     MOVLW 0xDF
137B  00F2     MOVWF 0xEF2
137C  0872     MOVF 0xEF2, W
137D  0590     ANDWF UIR, F
2227:          }
137E  0008     RETURN
2228:          
2229:          /********************************************************************
2230:           * Function:        void USBSuspend(void)
2231:           *
2232:           * PreCondition:    None
2233:           *
2234:           * Input:           None
2235:           *
2236:           * Output:          None
2237:           *
2238:           * Side Effects:    
2239:           *
2240:           * Overview:        This function handles if the host tries to 
2241:           *                  suspend the device
2242:           *
2243:           * Note:            None
2244:           *******************************************************************/
2245:          static void USBSuspend(void)
2246:          {
2247:              /*
2248:               * NOTE: Do not clear UIRbits.ACTVIF here!
2249:               * Reason:
2250:               * ACTVIF is only generated once an IDLEIF has been generated.
2251:               * This is a 1:1 ratio interrupt generation.
2252:               * For every IDLEIF, there will be only one ACTVIF regardless of
2253:               * the number of subsequent bus transitions.
2254:               *
2255:               * If the ACTIF is cleared here, a problem could occur when:
2256:               * [       IDLE       ][bus activity ->
2257:               * <--- 3 ms ----->     ^
2258:               *                ^     ACTVIF=1
2259:               *                IDLEIF=1
2260:               *  #           #           #           #   (#=Program polling flags)
2261:               *                          ^
2262:               *                          This polling loop will see both
2263:               *                          IDLEIF=1 and ACTVIF=1.
2264:               *                          However, the program services IDLEIF first
2265:               *                          because ACTIVIE=0.
2266:               *                          If this routine clears the only ACTIVIF,
2267:               *                          then it can never get out of the suspend
2268:               *                          mode.
2269:               */
2270:              USBActivityIE = 1;                     // Enable bus activity interrupt
12D7  003D     MOVLB 0x1D
12D8  1512     BSF UIE, 0x2
2271:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
12D9  30EF     MOVLW 0xEF
12DA  0021     MOVLB 0x1
12DB  00EC     MOVWF powerOfTen
12DC  086C     MOVF powerOfTen, W
12DD  003D     MOVLB 0x1D
12DE  0590     ANDWF UIR, F
2272:          
2273:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2274:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
12DF  148E     BSF UCON, 0x1
2275:                                                          // mode, SIE clock inactive
2276:              #endif
2277:              USBBusIsSuspended = true;
12E0  0023     MOVLB 0x3
12E1  01C8     CLRF USBBusIsSuspended
12E2  0AC8     INCF USBBusIsSuspended, F
2278:              USBTicksSinceSuspendEnd = 0;
12E3  01D0     CLRF USBTicksSinceSuspendEnd
2279:           
2280:              /*
2281:               * At this point the PIC can go into sleep,idle, or
2282:               * switch to a slower clock, etc.  This should be done in the
2283:               * USBCBSuspend() if necessary.
2284:               */
2285:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
12E4  3075     MOVLW 0x75
12E5  0021     MOVLB 0x1
12E6  00E6     MOVWF buffer
12E7  3000     MOVLW 0x0
12E8  00E7     MOVWF 0xE7
12E9  3000     MOVLW 0x0
12EA  00E8     MOVWF dividend
12EB  3000     MOVLW 0x0
12EC  00E9     MOVWF 0xE9
12ED  3000     MOVLW 0x0
12EE  00EA     MOVWF strIncremet
12EF  00EB     MOVWF str
12F0  3194     MOVLP 0x14
12F1  2481     CALL 0x481
2286:          }
12F2  0008     RETURN
2287:          
2288:          /********************************************************************
2289:           * Function:        void USBWakeFromSuspend(void)
2290:           *
2291:           * PreCondition:    None
2292:           *
2293:           * Input:           None
2294:           *
2295:           * Output:          None
2296:           *
2297:           * Side Effects:    None
2298:           *
2299:           * Overview:
2300:           *
2301:           * Note:            None
2302:           *******************************************************************/
2303:          static void USBWakeFromSuspend(void)
2304:          {
2305:              USBBusIsSuspended = false;
12F3  0023     MOVLB 0x3
12F4  01C8     CLRF USBBusIsSuspended
2306:          
2307:              /*
2308:               * If using clock switching, the place to restore the original
2309:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2310:               */
2311:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
12F5  3074     MOVLW 0x74
12F6  0021     MOVLB 0x1
12F7  00E6     MOVWF buffer
12F8  3000     MOVLW 0x0
12F9  00E7     MOVWF 0xE7
12FA  3000     MOVLW 0x0
12FB  00E8     MOVWF dividend
12FC  3000     MOVLW 0x0
12FD  00E9     MOVWF 0xE9
12FE  3000     MOVLW 0x0
12FF  00EA     MOVWF strIncremet
1300  00EB     MOVWF str
1301  3194     MOVLP 0x14
1302  2481     CALL 0x481
1303  3192     MOVLP 0x12
2312:          
2313:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2314:                  //To avoid improperly clocking the USB module, make sure the oscillator
2315:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2316:                  //Make sure the correct oscillator settings are selected in the 
2317:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2318:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
1304  003D     MOVLB 0x1D
1305  108E     BCF UCON, 0x1
2319:                                          // mode.
2320:              #endif
2321:          
2322:          
2323:              USBActivityIE = 0;
1306  1112     BCF UIE, 0x2
2324:          
2325:              /********************************************************************
2326:              Bug Fix: Feb 26, 2007 v2.1
2327:              *********************************************************************
2328:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2329:              up from Suspend or while the USB module is suspended. A few clock cycles
2330:              are required to synchronize the internal hardware state machine before
2331:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2332:              before the internal hardware is synchronized may not have an effect on
2333:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2334:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2335:              module may not be immediately operational while waiting for the 96 MHz
2336:              PLL to lock.
2337:              ********************************************************************/
2338:          
2339:              // UIRbits.ACTVIF = 0;                      // Removed
2340:              #if defined(__18CXX) || defined(__XC8)
2341:              while(USBActivityIF)
1307  1D10     BTFSS UIR, 0x2
1308  2B10     GOTO 0x310
130F  2B07     GOTO 0x307
2342:              #endif
2343:              {
2344:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
1309  30FB     MOVLW 0xFB
130A  0021     MOVLB 0x1
130B  00EC     MOVWF powerOfTen
130C  086C     MOVF powerOfTen, W
130D  003D     MOVLB 0x1D
130E  0590     ANDWF UIR, F
2345:              }  // Added
2346:          
2347:              USBTicksSinceSuspendEnd = 0;
1310  0023     MOVLB 0x3
1311  01D0     CLRF USBTicksSinceSuspendEnd
2348:          
2349:          }//end USBWakeFromSuspend
1312  0008     RETURN
2350:          
2351:          /********************************************************************
2352:           * Function:        void USBCtrlEPService(void)
2353:           *
2354:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2355:           *
2356:           * Input:           None
2357:           *
2358:           * Output:          None
2359:           *
2360:           * Side Effects:    None
2361:           *
2362:           * Overview:        USBCtrlEPService checks for three transaction
2363:           *                  types that it knows how to service and services
2364:           *                  them:
2365:           *                  1. EP0 SETUP
2366:           *                  2. EP0 OUT
2367:           *                  3. EP0 IN
2368:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2369:           *
2370:           * Note:            None
2371:           *******************************************************************/
2372:          static void USBCtrlEPService(void)
2373:          {
2374:              //If we get to here, that means a successful transaction has just occurred 
2375:              //on EP0.  This means "progress" has occurred in the currently pending 
2376:              //control transfer, so we should re-initialize our timeout counter.
2377:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2378:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
1592  302D     MOVLW 0x2D
1593  0023     MOVLB 0x3
1594  00EB     MOVWF 0x1EB
1595  086B     MOVF 0x1EB, W
1596  00CF     MOVWF USBStatusStageTimeoutCounter
2379:              #endif
2380:          	
2381:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2382:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
1597  0868     MOVF USTATcopy, W
1598  39FD     ANDLW 0xFD
1599  1D03     BTFSS 0x183, 0x2
159A  2DD9     GOTO 0x5D9
2383:              {
2384:          		//Point to the EP0 OUT buffer of the buffer that arrived
2385:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2386:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
159B  3668     LSRF USTATcopy, W
159C  393F     ANDLW 0x3F
159D  00EB     MOVWF 0x1EB
159E  3001     MOVLW 0x1
159F  35EB     LSLF 0x1EB, F
15A0  3EFF     ADDLW 0xFF
15A1  1D03     BTFSS 0x183, 0x2
15A2  2D9F     GOTO 0x59F
15A3  356B     LSLF 0x1EB, W
15A4  3E20     ADDLW 0x20
15A5  00EC     MOVWF 0x1EC
15A6  086C     MOVF 0x1EC, W
15A7  00DC     MOVWF pBDTEntryEP0OutCurrent
2387:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2388:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2389:                  #else
2390:                      #error "unimplemented"
2391:                  #endif
2392:          
2393:          		//Set the next out to the current out packet
2394:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
15A8  085C     MOVF pBDTEntryEP0OutCurrent, W
15A9  00FA     MOVWF 0x1FA
15AA  39FF     ANDLW 0xFF
15AB  1D03     BTFSS 0x183, 0x2
15AC  3000     MOVLW 0x0
15AD  00FB     MOVWF 0x1FB
2395:          		//Toggle it to the next ping pong buffer (if applicable)
2396:                  pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
15AE  3004     MOVLW 0x4
15AF  067A     XORWF 0x1FA, W
15B0  00FA     MOVWF 0x1FA
15B1  3000     MOVLW 0x0
15B2  067B     XORWF 0x1FB, W
15B3  00FB     MOVWF 0x1FB
2397:          
2398:          		//If the current EP0 OUT buffer has a SETUP packet
2399:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
15B4  085C     MOVF pBDTEntryEP0OutCurrent, W
15B5  0086     MOVWF 0x186
15B6  0187     CLRF 0x187
15B7  0C01     RRF 0x181, W
15B8  0C89     RRF 0x189, F
15B9  390F     ANDLW 0xF
15BA  3A0D     XORLW 0xD
15BB  1D03     BTFSS 0x183, 0x2
15BC  2DD6     GOTO 0x5D6
2400:                  {
2401:          	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2402:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2403:          	        //before the transaction.  Therefore, we should copy the data to the 
2404:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2405:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
15BD  30A0     MOVLW 0xA0
15BE  0086     MOVWF 0x186
15BF  0187     CLRF 0x187
15C0  0023     MOVLB 0x3
15C1  085C     MOVF pBDTEntryEP0OutCurrent, W
15C2  3E02     ADDLW 0x2
15C3  0084     MOVWF 0x184
15C4  0185     CLRF 0x185
15C5  3F00     MOVIW [0]FSR0
15C6  00EB     MOVWF 0x1EB
15C7  3F01     MOVIW [1]FSR0
15C8  00EC     MOVWF 0x1EC
15C9  086B     MOVF 0x1EB, W
15CA  0084     MOVWF 0x184
15CB  086C     MOVF 0x1EC, W
15CC  0085     MOVWF 0x185
15CD  3008     MOVLW 0x8
15CE  00ED     MOVWF 0x1ED
15CF  0012     MOVIW FSR0++
15D0  001E     MOVWI FSR1++
15D1  0BED     DECFSZ 0x1ED, F
15D2  2DCF     GOTO 0x5CF
2406:          
2407:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2408:                      USBCtrlTrfSetupHandler();
15D3  3195     MOVLP 0x15
15D4  2542     CALL 0x542
2409:                  }
15D5  0008     RETURN
2410:                  else
2411:                  {
2412:          			//Handle the DATA transfer
2413:                      USBCtrlTrfOutHandler();
15D6  3193     MOVLP 0x13
15D7  23D7     CALL 0x3D7
2414:                  }
2415:              }
15D8  0008     RETURN
2416:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
15D9  30FD     MOVLW 0xFD
15DA  0023     MOVLB 0x3
15DB  0568     ANDWF USTATcopy, W
15DC  00EB     MOVWF 0x1EB
15DD  3004     MOVLW 0x4
15DE  066B     XORWF 0x1EB, W
15DF  1D03     BTFSS 0x183, 0x2
15E0  0008     RETURN
2417:              {
2418:          		//Otherwise the transmission was and EP0 IN
2419:          		//  so take care of the IN transfer
2420:                  USBCtrlTrfInHandler();
15E1  318A     MOVLP 0xA
15E2  2218     CALL 0x218
2421:              }
15E3  0008     RETURN
2422:          
2423:          }//end USBCtrlEPService
2424:          
2425:          /********************************************************************
2426:           * Function:        void USBCtrlTrfSetupHandler(void)
2427:           *
2428:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2429:           *
2430:           * Input:           None
2431:           *
2432:           * Output:          None
2433:           *
2434:           * Side Effects:    None
2435:           *
2436:           * Overview:        This routine is a task dispatcher and has 3 stages.
2437:           *                  1. It initializes the control transfer state machine.
2438:           *                  2. It calls on each of the module that may know how to
2439:           *                     service the Setup Request from the host.
2440:           *                     Module Example: USBD, HID, CDC, MSD, ...
2441:           *                     A callback function, USBCBCheckOtherReq(),
2442:           *                     is required to call other module handlers.
2443:           *                  3. Once each of the modules has had a chance to check if
2444:           *                     it is responsible for servicing the request, stage 3
2445:           *                     then checks direction of the transfer to determine how
2446:           *                     to prepare EP0 for the control transfer.
2447:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2448:           *
2449:           * Note:            Microchip USB Firmware has three different states for
2450:           *                  the control transfer state machine:
2451:           *                  1. WAIT_SETUP
2452:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2453:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2454:           *                  Refer to firmware manual to find out how one state
2455:           *                  is transitioned to another.
2456:           *
2457:           *                  A Control Transfer is composed of many USB transactions.
2458:           *                  When transferring data over multiple transactions,
2459:           *                  it is important to keep track of data source, data
2460:           *                  destination, and data count. These three parameters are
2461:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2462:           *                  note if the data source is from const or RAM.
2463:           *
2464:           *******************************************************************/
2465:          static void USBCtrlTrfSetupHandler(void)
2466:          {
2467:              //--------------------------------------------------------------------------
2468:              //1. Re-initialize state tracking variables related to control transfers.
2469:              //--------------------------------------------------------------------------
2470:              shortPacketStatus = SHORT_PKT_NOT_USED;  
1542  0023     MOVLB 0x3
1543  01DF     CLRF shortPacketStatus
2471:              USBDeferStatusStagePacket = false;
1544  01CB     CLRF USBDeferStatusStagePacket
2472:              USBDeferINDataStagePackets = false;
1545  01C9     CLRF USBDeferINDataStagePackets
2473:              USBDeferOUTDataStagePackets = false;
1546  01CA     CLRF USBDeferOUTDataStagePackets
2474:              BothEP0OutUOWNsSet = false;
1547  01C0     CLRF BothEP0OutUOWNsSet
2475:              controlTransferState = WAIT_SETUP;
1548  01D9     CLRF controlTransferState
2476:          
2477:              //Abandon any previous control transfers that might have been using EP0.
2478:              //Ordinarily, nothing actually needs abandoning, since the previous control
2479:              //transfer would have completed successfully prior to the host sending the next
2480:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2481:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2482:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2483:              //by the class request handler that will be called next.
2484:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);  
1549  307F     MOVLW 0x7F
154A  0021     MOVLB 0x1
154B  00EF     MOVWF lastDTS
154C  0023     MOVLB 0x3
154D  0820     MOVF pBDTEntryIn, W
154E  0086     MOVWF 0x186
154F  0821     MOVF 0x1A1, W
1550  0087     MOVWF 0x187
1551  0021     MOVLB 0x1
1552  086F     MOVF lastDTS, W
1553  0581     ANDWF 0x81, F
2485:              
2486:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
1554  3004     MOVLW 0x4
1555  0023     MOVLB 0x3
1556  0620     XORWF pBDTEntryIn, W
1557  00A0     MOVWF pBDTEntryIn
1558  3000     MOVLW 0x0
1559  0621     XORWF 0x1A1, W
155A  00A1     MOVWF 0x1A1
2487:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
155B  307F     MOVLW 0x7F
155C  0021     MOVLB 0x1
155D  00EF     MOVWF lastDTS
155E  0023     MOVLB 0x3
155F  0820     MOVF pBDTEntryIn, W
1560  0086     MOVWF 0x186
1561  0821     MOVF 0x1A1, W
1562  0087     MOVWF 0x187
1563  0021     MOVLB 0x1
1564  086F     MOVF lastDTS, W
1565  0581     ANDWF 0x81, F
2488:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
1566  3004     MOVLW 0x4
1567  0023     MOVLB 0x3
1568  0620     XORWF pBDTEntryIn, W
1569  00A0     MOVWF pBDTEntryIn
156A  3000     MOVLW 0x0
156B  0621     XORWF 0x1A1, W
156C  00A1     MOVWF 0x1A1
2489:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
156D  307F     MOVLW 0x7F
156E  0021     MOVLB 0x1
156F  00EF     MOVWF lastDTS
1570  087A     MOVF 0xFA, W
1571  0086     MOVWF 0x86
1572  087B     MOVF 0xFB, W
1573  0087     MOVWF 0x87
1574  086F     MOVF lastDTS, W
1575  0581     ANDWF 0x81, F
2490:          
2491:              inPipes[0].info.Val = 0;
1576  0023     MOVLB 0x3
1577  01B3     CLRF 0x1B3
2492:              inPipes[0].wCount.Val = 0;
1578  01B4     CLRF 0x1B4
1579  01B5     CLRF 0x1B5
2493:              outPipes[0].info.Val = 0;
157A  01AC     CLRF 0x1AC
2494:              outPipes[0].wCount.Val = 0;
157B  01AD     CLRF 0x1AD
157C  01AE     CLRF 0x1AE
2495:              
2496:          
2497:              //--------------------------------------------------------------------------
2498:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2499:              //--------------------------------------------------------------------------
2500:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
157D  3196     MOVLP 0x16
157E  2691     CALL 0x691
157F  3195     MOVLP 0x15
2501:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
1580  3000     MOVLW 0x0
1581  0021     MOVLB 0x1
1582  00E7     MOVWF 0xE7
1583  3003     MOVLW 0x3
1584  00E6     MOVWF buffer
1585  3000     MOVLW 0x0
1586  00E8     MOVWF dividend
1587  3000     MOVLW 0x0
1588  00E9     MOVWF 0xE9
1589  3000     MOVLW 0x0
158A  00EA     MOVWF strIncremet
158B  00EB     MOVWF str
158C  3194     MOVLP 0x14
158D  2481     CALL 0x481
158E  3195     MOVLP 0x15
2502:          
2503:          
2504:              //--------------------------------------------------------------------------
2505:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2506:              //   progress.  If one of the above handlers (in step 2) knew how to process
2507:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2508:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2509:              //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2510:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2511:              //   process the request.  In this case, the default behavior will be to
2512:              //   perform protocol STALL on EP0.
2513:              //-------------------------------------------------------------------------- 
2514:              USBCtrlEPServiceComplete();
158F  318B     MOVLP 0xB
1590  2399     CALL 0x399
2515:          }//end USBCtrlTrfSetupHandler
1591  0008     RETURN
2516:          
2517:          
2518:          /******************************************************************************
2519:           * Function:        void USBCtrlTrfOutHandler(void)
2520:           *
2521:           * PreCondition:    None
2522:           *
2523:           * Input:           None
2524:           *
2525:           * Output:          None
2526:           *
2527:           * Side Effects:    None
2528:           *
2529:           * Overview:        This routine handles an OUT transaction according to
2530:           *                  which control transfer state is currently active.
2531:           *
2532:           * Note:            Note that if the the control transfer was from
2533:           *                  host to device, the session owner should be notified
2534:           *                  at the end of each OUT transaction to service the
2535:           *                  received data.
2536:           *
2537:           *****************************************************************************/
2538:          static void USBCtrlTrfOutHandler(void)
2539:          {
2540:              if(controlTransferState == CTRL_TRF_RX)
13D7  3002     MOVLW 0x2
13D8  0023     MOVLB 0x3
13D9  0659     XORWF controlTransferState, W
13DA  1D03     BTFSS 0x183, 0x2
13DB  2BDF     GOTO 0x3DF
2541:              {
2542:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
13DC  318F     MOVLP 0xF
13DD  273E     CALL 0x73E
2543:              }
13DE  0008     RETURN
2544:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2545:              {
2546:                  //If the status stage is complete, this means we are done with the 
2547:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2548:                  controlTransferState = WAIT_SETUP;
13DF  0023     MOVLB 0x3
13E0  01D9     CLRF controlTransferState
2549:          
2550:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2551:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2552:                  //and the last control transfer was of direction: device to host, see
2553:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2554:                  //to do anything to the BDT.
2555:                  if(BothEP0OutUOWNsSet == false)
13E1  0840     MOVF BothEP0OutUOWNsSet, W
13E2  1D03     BTFSS 0x183, 0x2
13E3  2C09     GOTO 0x409
2556:                  {
2557:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
13E4  087A     MOVF 0x1FA, W
13E5  3E01     ADDLW 0x1
13E6  00E9     MOVWF __pcstackBANK3
13E7  3000     MOVLW 0x0
13E8  3D7B     ADDWFC 0x1FB, W
13E9  00EA     MOVWF i
13EA  0869     MOVF __pcstackBANK3, W
13EB  0086     MOVWF 0x186
13EC  086A     MOVF i, W
13ED  0087     MOVWF 0x187
13EE  3008     MOVLW 0x8
13EF  0081     MOVWF 0x181
2558:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
13F0  30A0     MOVLW 0xA0
13F1  00E9     MOVWF __pcstackBANK3
13F2  3000     MOVLW 0x0
13F3  00EA     MOVWF i
13F4  087A     MOVF 0x1FA, W
13F5  0086     MOVWF 0x186
13F6  087B     MOVF 0x1FB, W
13F7  0087     MOVWF 0x187
13F8  3142     ADDFSR 1, 2
13F9  0869     MOVF __pcstackBANK3, W
13FA  3FC0     MOVWI [0]FSR1
13FB  086A     MOVF i, W
13FC  3FC1     MOVWI [1]FSR1
2559:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
13FD  087A     MOVF 0x1FA, W
13FE  0086     MOVWF 0x186
13FF  087B     MOVF 0x1FB, W
1400  0087     MOVWF 0x187
1401  300C     MOVLW 0xC
1402  0081     MOVWF 0x181
2560:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1403  087A     MOVF 0x1FA, W
1404  0086     MOVWF 0x186
1405  087B     MOVF 0x1FB, W
1406  0087     MOVWF 0x187
1407  1781     BSF 0x181, 0x7
2561:                  }
1408  0008     RETURN
2562:                  else
2563:                  {
2564:                          BothEP0OutUOWNsSet = false;
1409  01C0     CLRF BothEP0OutUOWNsSet
2565:                  }
140A  0008     RETURN
2566:              }
2567:          }
2568:          
2569:          /******************************************************************************
2570:           * Function:        void USBCtrlTrfInHandler(void)
2571:           *
2572:           * PreCondition:    None
2573:           *
2574:           * Input:           None
2575:           *
2576:           * Output:          None
2577:           *
2578:           * Side Effects:    None
2579:           *
2580:           * Overview:        This routine handles an IN transaction according to
2581:           *                  which control transfer state is currently active.
2582:           *
2583:           * Note:            A Set Address Request must not change the actual address
2584:           *                  of the device until the completion of the control
2585:           *                  transfer. The end of the control transfer for Set Address
2586:           *                  Request is an IN transaction. Therefore it is necessary
2587:           *                  to service this unique situation when the condition is
2588:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2589:           *                  usb9.h and its function is to specifically service this
2590:           *                  event.
2591:           *****************************************************************************/
2592:          static void USBCtrlTrfInHandler(void)
2593:          {
2594:              uint8_t lastDTS;
2595:          
2596:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
0A18  0023     MOVLB 0x3
0A19  0820     MOVF pBDTEntryIn, W
0A1A  0086     MOVWF 0x186
0A1B  0821     MOVF 0x1A1, W
0A1C  0087     MOVWF 0x187
0A1D  3000     MOVLW 0x0
0A1E  1B01     BTFSC 0x181, 0x6
0A1F  3001     MOVLW 0x1
0A20  0021     MOVLB 0x1
0A21  00EF     MOVWF lastDTS
2597:          
2598:              //switch to the next ping pong buffer
2599:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0A22  3004     MOVLW 0x4
0A23  0023     MOVLB 0x3
0A24  0620     XORWF pBDTEntryIn, W
0A25  00A0     MOVWF pBDTEntryIn
0A26  3000     MOVLW 0x0
0A27  0621     XORWF 0x1A1, W
0A28  00A1     MOVWF 0x1A1
2600:          
2601:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2602:              //now, since the IN status stage of the (set address) control transfer has 
2603:              //evidently completed successfully.
2604:              if(USBDeviceState == ADR_PENDING_STATE)
0A29  3008     MOVLW 0x8
0A2A  064C     XORWF USBDeviceState, W
0A2B  1D03     BTFSS 0x183, 0x2
0A2C  2A3D     GOTO 0x23D
2605:              {
2606:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
0A2D  0021     MOVLB 0x1
0A2E  0822     MOVF 0xA2, W
0A2F  397F     ANDLW 0x7F
0A30  003D     MOVLB 0x1D
0A31  0096     MOVWF UADDR
2607:                  if(U1ADDR != 0u)
0A32  0816     MOVF UADDR, W
0A33  1903     BTFSC 0xE83, 0x2
0A34  2A37     GOTO 0x237
2608:                  {
2609:                      USBDeviceState=ADDRESS_STATE;
0A35  3010     MOVLW 0x10
0A36  2A38     GOTO 0x238
2610:                  }
2611:                  else
2612:                  {
2613:                      USBDeviceState=DEFAULT_STATE;
0A37  3004     MOVLW 0x4
0A38  0021     MOVLB 0x1
0A39  00ED     MOVWF ziffer
0A3A  086D     MOVF ziffer, W
0A3B  0023     MOVLB 0x3
0A3C  00CC     MOVWF USBDeviceState
2614:                  }
2615:              }//end if
2616:          
2617:          
2618:              if(controlTransferState == CTRL_TRF_TX)
0A3D  0359     DECF controlTransferState, W
0A3E  1D03     BTFSS 0x183, 0x2
0A3F  2A82     GOTO 0x282
2619:              {
2620:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0A40  30A8     MOVLW 0xA8
0A41  0021     MOVLB 0x1
0A42  00ED     MOVWF ziffer
0A43  3000     MOVLW 0x0
0A44  00EE     MOVWF pI_mA
0A45  0023     MOVLB 0x3
0A46  0820     MOVF pBDTEntryIn, W
0A47  0086     MOVWF 0x186
0A48  0821     MOVF 0x1A1, W
0A49  0087     MOVWF 0x187
0A4A  3142     ADDFSR 1, 2
0A4B  0021     MOVLB 0x1
0A4C  086D     MOVF ziffer, W
0A4D  3FC0     MOVWI [0]FSR1
0A4E  086E     MOVF pI_mA, W
0A4F  3FC1     MOVWI [1]FSR1
2621:                  USBCtrlTrfTxService();
0A50  3188     MOVLP 0x8
0A51  20D5     CALL 0xD5
0A52  318A     MOVLP 0xA
2622:          
2623:                  //Check if we have already sent a short packet.  If so, configure
2624:                  //the endpoint to STALL in response to any further IN tokens (in the
2625:                  //case that the host erroneously tries to receive more data than it
2626:                  //should).
2627:                  if(shortPacketStatus == SHORT_PKT_SENT)
0A53  3002     MOVLW 0x2
0A54  0023     MOVLB 0x3
0A55  065F     XORWF shortPacketStatus, W
0A56  1D03     BTFSS 0x183, 0x2
0A57  2A64     GOTO 0x264
2628:                  {
2629:                      // If a short packet has been sent, don't want to send any more,
2630:                      // stall next time if host is still trying to read.
2631:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0A58  0820     MOVF pBDTEntryIn, W
0A59  0086     MOVWF 0x186
0A5A  0821     MOVF 0x1A1, W
0A5B  0087     MOVWF 0x187
0A5C  3004     MOVLW 0x4
0A5D  0081     MOVWF 0x181
2632:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0A5E  0820     MOVF pBDTEntryIn, W
0A5F  0086     MOVWF 0x186
0A60  0821     MOVF 0x1A1, W
0A61  0087     MOVWF 0x187
0A62  1781     BSF 0x181, 0x7
2633:                  }
0A63  0008     RETURN
2634:                  else
2635:                  {
2636:                      if(lastDTS == 0)
0A64  0021     MOVLB 0x1
0A65  086F     MOVF lastDTS, W
0A66  1D03     BTFSS 0x83, 0x2
0A67  2A75     GOTO 0x275
2637:                      {
2638:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0A68  0023     MOVLB 0x3
0A69  0820     MOVF pBDTEntryIn, W
0A6A  0086     MOVWF 0x186
0A6B  0821     MOVF 0x1A1, W
0A6C  0087     MOVWF 0x187
0A6D  3048     MOVLW 0x48
0A6E  0081     MOVWF 0x181
2639:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0A6F  0820     MOVF pBDTEntryIn, W
0A70  0086     MOVWF 0x186
0A71  0821     MOVF 0x1A1, W
0A72  0087     MOVWF 0x187
0A73  1781     BSF 0x181, 0x7
2640:                      }
0A74  0008     RETURN
2641:                      else
2642:                      {
2643:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0A75  0023     MOVLB 0x3
0A76  0820     MOVF pBDTEntryIn, W
0A77  0086     MOVWF 0x186
0A78  0821     MOVF 0x1A1, W
0A79  0087     MOVWF 0x187
0A7A  3008     MOVLW 0x8
0A7B  0081     MOVWF 0x181
2644:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0A7C  0820     MOVF pBDTEntryIn, W
0A7D  0086     MOVWF 0x186
0A7E  0821     MOVF 0x1A1, W
0A7F  0087     MOVWF 0x187
0A80  1781     BSF 0x181, 0x7
2645:                      }
2646:                  }//end if(...)else
2647:              }
0A81  0008     RETURN
2648:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2649:          	{
2650:                  //if someone is still expecting data from the control transfer
2651:                  //  then make sure to terminate that request and let them know that
2652:                  //  they are done
2653:                  if(outPipes[0].info.bits.busy == 1)
0A82  1FAC     BTFSS 0x1AC, 0x7
0A83  2A94     GOTO 0x294
2654:                  {
2655:                      if(outPipes[0].pFunc != NULL)
0A84  082F     MOVF 0x1AF, W
0A85  0430     IORWF 0x1B0, W
0A86  1903     BTFSC 0x183, 0x2
0A87  2A92     GOTO 0x292
2656:                      {
2657:                          outPipes[0].pFunc();
0A88  3005     MOVLW 0x5
0A89  3EAA     ADDLW 0xAA
0A8A  0086     MOVWF 0x186
0A8B  3001     MOVLW 0x1
0A8C  0087     MOVWF 0x187
0A8D  3F41     MOVIW [1]FSR1
0A8E  008A     MOVWF 0x18A
0A8F  3F40     MOVIW [0]FSR1
0A90  000A     CALLW
0A91  318A     MOVLP 0xA
2658:                      }
2659:                      outPipes[0].info.bits.busy = 0;
0A92  0023     MOVLB 0x3
0A93  13AC     BCF 0x1AC, 0x7
2660:                  }
2661:              	
2662:                  controlTransferState = WAIT_SETUP;
0A94  01D9     CLRF controlTransferState
0A95  0008     RETURN
2663:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2664:                  //got processed by the USBCtrlTrfRxService() handler.
2665:          	}	
2666:          
2667:          }
2668:          
2669:          
2670:          /********************************************************************
2671:           * Function:        void USBCheckStdRequest(void)
2672:           *
2673:           * PreCondition:    None
2674:           *
2675:           * Input:           None
2676:           *
2677:           * Output:          None
2678:           *
2679:           * Side Effects:    None
2680:           *
2681:           * Overview:        This routine checks the setup data packet to see
2682:           *                  if it knows how to handle it
2683:           *
2684:           * Note:            None
2685:           *******************************************************************/
2686:          static void USBCheckStdRequest(void)
2687:          {
2688:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
1691  0021     MOVLB 0x1
1692  0E20     SWAPF SetupPkt, W
1693  0C89     RRF 0x89, F
1694  3903     ANDLW 0x3
1695  3A00     XORLW 0x0
1696  1D03     BTFSS 0x83, 0x2
1697  0008     RETURN
1698  2EDF     GOTO 0x6DF
2689:          
2690:              switch(SetupPkt.bRequest)
1000  3196     MOVLP 0x16
16DF  0021     MOVLB 0x1
16E0  0821     MOVF 0xA1, W
16E1  0084     MOVWF 0x84
16E2  300D     MOVLW 0xD
16E3  0204     SUBWF 0x84, W
16E4  1803     BTFSC 0x83, 0x0
16E5  0008     RETURN
16E6  3190     MOVLP 0x10
16E7  3504     LSLF 0x84, W
16E8  3E00     ADDLW 0x0
16E9  0082     MOVWF 0x82
2691:              {
2692:                  case USB_REQUEST_SET_ADDRESS:
2693:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
1699  0023     MOVLB 0x3
169A  17B3     BSF 0x1B3, 0x7
2694:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
169B  3008     MOVLW 0x8
169C  0021     MOVLB 0x1
169D  00EE     MOVWF pI_mA
169E  086E     MOVF pI_mA, W
169F  0023     MOVLB 0x3
16A0  00CC     MOVWF USBDeviceState
2695:                      /* See USBCtrlTrfInHandler() for the next step */
2696:                      break;
16A1  0008     RETURN
2697:                  case USB_REQUEST_GET_DESCRIPTOR:
2698:                      USBStdGetDscHandler();
16A2  318A     MOVLP 0xA
16A3  2296     CALL 0x296
2699:                      break;
16A4  0008     RETURN
2700:                  case USB_REQUEST_SET_CONFIGURATION:
2701:                      USBStdSetCfgHandler();
16A5  318C     MOVLP 0xC
16A6  24B4     CALL 0x4B4
2702:                      break;
16A7  0008     RETURN
2703:                  case USB_REQUEST_GET_CONFIGURATION:
2704:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
16A8  30E7     MOVLW 0xE7
16A9  0023     MOVLB 0x3
16AA  00B1     MOVWF inPipes
16AB  3001     MOVLW 0x1
16AC  00B2     MOVWF 0x1B2
2705:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
16AD  1433     BSF 0x1B3, 0x0
2706:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
16AE  01B4     CLRF 0x1B4
16AF  0AB4     INCF 0x1B4, F
2707:                      inPipes[0].info.bits.busy = 1;
16B0  17B3     BSF 0x1B3, 0x7
2708:                      break;
16B1  0008     RETURN
2709:                  case USB_REQUEST_GET_STATUS:
2710:                      USBStdGetStatusHandler();
16B2  3195     MOVLP 0x15
16B3  25E4     CALL 0x5E4
2711:                      break;
16B4  0008     RETURN
2712:                  case USB_REQUEST_CLEAR_FEATURE:
2713:                  case USB_REQUEST_SET_FEATURE:
2714:                      USBStdFeatureReqHandler();
16B5  3183     MOVLP 0x3
16B6  23E6     CALL 0x3E6
2715:                      break;
16B7  0008     RETURN
2716:                  case USB_REQUEST_GET_INTERFACE:
2717:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
16B8  0021     MOVLB 0x1
16B9  0824     MOVF 0xA4, W
16BA  3E65     ADDLW 0x65
16BB  0023     MOVLB 0x3
16BC  00B1     MOVWF inPipes
16BD  3002     MOVLW 0x2
16BE  00B2     MOVWF 0x1B2
2718:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
16BF  1433     BSF 0x1B3, 0x0
2719:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
16C0  01B4     CLRF 0x1B4
16C1  0AB4     INCF 0x1B4, F
2720:                      inPipes[0].info.bits.busy = 1;
16C2  17B3     BSF 0x1B3, 0x7
2721:                      break;
16C3  0008     RETURN
2722:                  case USB_REQUEST_SET_INTERFACE:
2723:                      inPipes[0].info.bits.busy = 1;
16C4  0023     MOVLB 0x3
16C5  17B3     BSF 0x1B3, 0x7
2724:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
16C6  0021     MOVLB 0x1
16C7  0822     MOVF 0xA2, W
16C8  00EE     MOVWF pI_mA
16C9  0824     MOVF 0xA4, W
16CA  3E65     ADDLW 0x65
16CB  0086     MOVWF 0x86
16CC  3002     MOVLW 0x2
16CD  0087     MOVWF 0x87
16CE  086E     MOVF pI_mA, W
16CF  0081     MOVWF 0x81
2725:                      break;
16D0  0008     RETURN
2726:                  case USB_REQUEST_SET_DESCRIPTOR:
2727:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
16D1  3000     MOVLW 0x0
16D2  00E7     MOVWF 0xE7
16D3  3002     MOVLW 0x2
16D4  00E6     MOVWF buffer
16D5  3000     MOVLW 0x0
16D6  00E8     MOVWF dividend
16D7  3000     MOVLW 0x0
16D8  00E9     MOVWF 0xE9
16D9  3000     MOVLW 0x0
16DA  00EA     MOVWF strIncremet
16DB  00EB     MOVWF str
16DC  3194     MOVLP 0x14
16DD  2481     CALL 0x481
2728:                      break;
2729:                  case USB_REQUEST_SYNCH_FRAME:
2730:                  default:
2731:                      break;
2732:              }//end switch
16DE  0008     RETURN
2733:          }//end USBCheckStdRequest
16EA  0008     RETURN
2734:          
2735:          /********************************************************************
2736:           * Function:        void USBStdFeatureReqHandler(void)
2737:           *
2738:           * PreCondition:    None
2739:           *
2740:           * Input:           None
2741:           *
2742:           * Output:          Can alter BDT entries.  Can also modify USB stack
2743:           *                  Maintained variables.
2744:           *
2745:           * Side Effects:    None
2746:           *
2747:           * Overview:        This routine handles the standard SET & CLEAR
2748:           *                  FEATURES requests
2749:           *
2750:           * Note:            This is a private function, intended for internal 
2751:           *                  use by the USB stack, when processing SET/CLEAR
2752:           *                  feature requests.  
2753:           *******************************************************************/
2754:          static void USBStdFeatureReqHandler(void)
2755:          {
2756:              BDT_ENTRY *p;
2757:              EP_STATUS current_ep_data;
2758:              #if defined(__C32__)
2759:                  uint32_t* pUEP;
2760:              #else
2761:                  unsigned char* pUEP;             
2762:              #endif
2763:              
2764:          
2765:              #ifdef	USB_SUPPORT_OTG
2766:              //Check for USB On-The-Go (OTG) specific requests
2767:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2768:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2769:              {  
2770:                  inPipes[0].info.bits.busy = 1;
2771:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2772:                      USBOTGEnableHnp();
2773:                  else
2774:                      USBOTGDisableHnp();
2775:              }
2776:          
2777:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2778:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2779:              {
2780:                  inPipes[0].info.bits.busy = 1;
2781:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2782:                      USBOTGEnableSupportHnp();
2783:                  else
2784:                      USBOTGDisableSupportHnp();
2785:              }
2786:          
2787:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2788:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2789:              {
2790:                  inPipes[0].info.bits.busy = 1;
2791:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2792:                      USBOTGEnableAltHnp();
2793:                  else
2794:                      USBOTGDisableAltHnp();
2795:              }
2796:              #endif   //#ifdef USB_SUPPORT_OTG 
2797:          
2798:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2799:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
2800:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
03E6  0021     MOVLB 0x1
03E7  0322     DECF 0xA2, W
03E8  1D03     BTFSS 0x83, 0x2
03E9  2BFC     GOTO 0x3FC
03EA  0820     MOVF SetupPkt, W
03EB  391F     ANDLW 0x1F
03EC  3A00     XORLW 0x0
03ED  1D03     BTFSS 0x83, 0x2
03EE  2BFC     GOTO 0x3FC
2801:              {
2802:                  inPipes[0].info.bits.busy = 1;
03EF  0023     MOVLB 0x3
03F0  17B3     BSF 0x1B3, 0x7
2803:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
03F1  3003     MOVLW 0x3
03F2  0021     MOVLB 0x1
03F3  0621     XORWF 0xA1, W
03F4  1D03     BTFSS 0x83, 0x2
03F5  2BFA     GOTO 0x3FA
2804:                      RemoteWakeup = true;
03F6  0023     MOVLB 0x3
03F7  01C7     CLRF RemoteWakeup
03F8  0AC7     INCF RemoteWakeup, F
03F9  2BFC     GOTO 0x3FC
2805:                  else
2806:                      RemoteWakeup = false;
03FA  0023     MOVLB 0x3
03FB  01C7     CLRF RemoteWakeup
2807:              }//end if
2808:          
2809:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2810:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
2811:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2812:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2813:                 (USBDeviceState == CONFIGURED_STATE))
03FC  0021     MOVLB 0x1
03FD  0822     MOVF 0xA2, W
03FE  1D03     BTFSS 0x83, 0x2
03FF  0008     RETURN
0400  0820     MOVF SetupPkt, W
0401  391F     ANDLW 0x1F
0402  3A02     XORLW 0x2
0403  1D03     BTFSS 0x83, 0x2
0404  0008     RETURN
0405  0824     MOVF 0xA4, W
0406  390F     ANDLW 0xF
0407  3A00     XORLW 0x0
0408  1903     BTFSC 0x83, 0x2
0409  0008     RETURN
040A  0824     MOVF 0xA4, W
040B  390F     ANDLW 0xF
040C  00EC     MOVWF powerOfTen
040D  3005     MOVLW 0x5
040E  026C     SUBWF powerOfTen, W
040F  1803     BTFSC 0x83, 0x0
0410  0008     RETURN
0411  3020     MOVLW 0x20
0412  0023     MOVLB 0x3
0413  064C     XORWF USBDeviceState, W
0414  1D03     BTFSS 0x183, 0x2
0415  0008     RETURN
2814:              {
2815:          		//The request was valid.  Take control of the control transfer and
2816:          		//perform the host requested action.
2817:          		inPipes[0].info.bits.busy = 1;
0416  17B3     BSF 0x1B3, 0x7
2818:          
2819:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2820:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0417  0021     MOVLB 0x1
0418  1BA4     BTFSC 0xA4, 0x7
0419  2C2B     GOTO 0x42B
2821:                  {
2822:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
041A  0824     MOVF 0xA4, W
041B  390F     ANDLW 0xF
041C  0709     ADDWF 0x89, W
041D  3E20     ADDLW 0x20
041E  0086     MOVWF 0x86
041F  3002     MOVLW 0x2
0420  0087     MOVWF 0x87
0421  3F40     MOVIW [0]FSR1
0422  0022     MOVLB 0x2
0423  00E3     MOVWF i
0424  3F41     MOVIW [1]FSR1
0425  00E4     MOVWF counter
2823:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0426  0021     MOVLB 0x1
0427  0824     MOVF 0xA4, W
0428  390F     ANDLW 0xF
0429  3E2F     ADDLW 0x2F
042A  2C3C     GOTO 0x43C
2824:                  }
2825:                  else
2826:                  {
2827:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
042B  0021     MOVLB 0x1
042C  0824     MOVF 0xA4, W
042D  390F     ANDLW 0xF
042E  0709     ADDWF 0x89, W
042F  3EA0     ADDLW 0xA0
0430  0086     MOVWF 0x86
0431  3001     MOVLW 0x1
0432  0087     MOVWF 0x87
0433  3F40     MOVIW [0]FSR1
0434  0022     MOVLB 0x2
0435  00E3     MOVWF i
0436  3F41     MOVIW [1]FSR1
0437  00E4     MOVWF counter
2828:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
0438  0021     MOVLB 0x1
0439  0824     MOVF 0xA4, W
043A  390F     ANDLW 0xF
043B  3E2A     ADDLW 0x2A
043C  0086     MOVWF 0x86
043D  3002     MOVLW 0x2
043E  0087     MOVWF 0x87
043F  0801     MOVF 0x81, W
0440  00EC     MOVWF powerOfTen
0441  086C     MOVF powerOfTen, W
0442  0022     MOVLB 0x2
0443  00E2     MOVWF i
2829:                  }
2830:          
2831:                  //If ping pong buffering is enabled on the requested endpoint, need 
2832:                  //to point to the one that is the active BDT entry which the SIE will 
2833:                  //use for the next attempted transaction on that EP number.
2834:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2835:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
0444  1862     BTFSC i, 0x0
0445  2C56     GOTO 0x456
2836:                      {
2837:                          p = (BDT_ENTRY*)(((uintptr_t)p) & (~USB_NEXT_PING_PONG));
0446  30FB     MOVLW 0xFB
0447  0021     MOVLB 0x1
0448  00EC     MOVWF powerOfTen
0449  30FF     MOVLW 0xFF
044A  00ED     MOVWF ziffer
044B  0022     MOVLB 0x2
044C  0863     MOVF i, W
044D  0021     MOVLB 0x1
044E  056C     ANDWF powerOfTen, W
044F  0022     MOVLB 0x2
0450  00E3     MOVWF i
0451  0864     MOVF counter, W
0452  0021     MOVLB 0x1
0453  056D     ANDWF ziffer, W
0454  0022     MOVLB 0x2
0455  2C5B     GOTO 0x45B
2838:                      }
2839:                      else //else must have been odd
2840:                      {
2841:                          p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
0456  3004     MOVLW 0x4
0457  0463     IORWF i, W
0458  00E3     MOVWF i
0459  3000     MOVLW 0x0
045A  0464     IORWF counter, W
045B  00E4     MOVWF counter
2842:                      }
2843:                  #endif
2844:                  
2845:                  //Update the BDT pointers with the new, next entry based on the feature
2846:                  //  request
2847:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
045C  0021     MOVLB 0x1
045D  1BA4     BTFSC 0xA4, 0x7
045E  2C6C     GOTO 0x46C
2848:                  {
2849:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
045F  0824     MOVF 0xA4, W
0460  390F     ANDLW 0xF
0461  0709     ADDWF 0x89, W
0462  3E20     ADDLW 0x20
0463  0086     MOVWF 0x86
0464  3002     MOVLW 0x2
0465  0087     MOVWF 0x87
0466  0022     MOVLB 0x2
0467  0863     MOVF i, W
0468  3FC0     MOVWI [0]FSR1
0469  0864     MOVF counter, W
046A  3FC1     MOVWI [1]FSR1
2850:                  }
046B  2C79     GOTO 0x479
2851:                  else
2852:                  {
2853:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
046C  0021     MOVLB 0x1
046D  0824     MOVF 0xA4, W
046E  390F     ANDLW 0xF
046F  0709     ADDWF 0x89, W
0470  3EA0     ADDLW 0xA0
0471  0086     MOVWF 0x86
0472  3001     MOVLW 0x1
0473  0087     MOVWF 0x87
0474  0022     MOVLB 0x2
0475  0863     MOVF i, W
0476  3FC0     MOVWI [0]FSR1
0477  0864     MOVF counter, W
0478  3FC1     MOVWI [1]FSR1
2854:                  }
2855:          
2856:          		//Check if it was a SET_FEATURE endpoint halt request
2857:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0479  3003     MOVLW 0x3
047A  0021     MOVLB 0x1
047B  0621     XORWF 0xA1, W
047C  1D03     BTFSS 0x83, 0x2
047D  2C9F     GOTO 0x49F
2858:                  {
2859:                      if(p->STAT.UOWN == 1)
047E  0022     MOVLB 0x2
047F  0863     MOVF i, W
0480  0086     MOVWF 0x106
0481  0864     MOVF counter, W
0482  0087     MOVWF 0x107
0483  1F81     BTFSS 0x101, 0x7
0484  2C93     GOTO 0x493
2860:                      {
2861:                          //Mark that we are terminating this transfer and that the user
2862:                          //  needs to be notified later
2863:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
0485  0021     MOVLB 0x1
0486  1BA4     BTFSC 0xA4, 0x7
0487  2C8C     GOTO 0x48C
2864:                          {
2865:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0488  0824     MOVF 0xA4, W
0489  390F     ANDLW 0xF
048A  3E2F     ADDLW 0x2F
048B  2C8F     GOTO 0x48F
2866:                          }
2867:                          else
2868:                          {
2869:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
048C  0824     MOVF 0xA4, W
048D  390F     ANDLW 0xF
048E  3E2A     ADDLW 0x2A
048F  0086     MOVWF 0x86
0490  3002     MOVLW 0x2
0491  0087     MOVWF 0x87
0492  1481     BSF 0x81, 0x1
2870:                          }
2871:                      }
2872:          
2873:          			//Then STALL the endpoint
2874:                      p->STAT.Val |= _BSTALL;
0493  0022     MOVLB 0x2
0494  0863     MOVF i, W
0495  0086     MOVWF 0x106
0496  0864     MOVF counter, W
0497  0087     MOVWF 0x107
0498  1501     BSF 0x101, 0x2
2875:                      p->STAT.Val |= _USIE;
0499  0863     MOVF i, W
049A  0086     MOVWF 0x106
049B  0864     MOVF counter, W
049C  0087     MOVWF 0x107
049D  1781     BSF 0x101, 0x7
2876:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
049E  0008     RETURN
2877:                  else
2878:                  {
2879:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2880:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2881:                          //toggle over the to the non-active BDT
2882:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);  
049F  3004     MOVLW 0x4
04A0  0022     MOVLB 0x2
04A1  0663     XORWF i, W
04A2  00E3     MOVWF i
04A3  3000     MOVLW 0x0
04A4  0664     XORWF counter, W
04A5  00E4     MOVWF counter
2883:          
2884:                          if(p->STAT.UOWN == 1)
04A6  0863     MOVF i, W
04A7  0086     MOVWF 0x106
04A8  0864     MOVF counter, W
04A9  0087     MOVWF 0x107
04AA  1F81     BTFSS 0x101, 0x7
04AB  2CD2     GOTO 0x4D2
2885:                          {
2886:                              //Clear UOWN and set DTS state so it will be correct the next time
2887:                              //the application firmware uses USBTransferOnePacket() on the EP.
2888:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
04AC  307F     MOVLW 0x7F
04AD  0021     MOVLB 0x1
04AE  00EC     MOVWF powerOfTen
04AF  0022     MOVLB 0x2
04B0  0863     MOVF i, W
04B1  0086     MOVWF 0x106
04B2  0864     MOVF counter, W
04B3  0087     MOVWF 0x107
04B4  0021     MOVLB 0x1
04B5  086C     MOVF powerOfTen, W
04B6  0581     ANDWF 0x81, F
2889:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
04B7  0022     MOVLB 0x2
04B8  0863     MOVF i, W
04B9  0086     MOVWF 0x106
04BA  0864     MOVF counter, W
04BB  0087     MOVWF 0x107
04BC  1701     BSF 0x101, 0x6
2890:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
04BD  3000     MOVLW 0x0
04BE  0021     MOVLB 0x1
04BF  00E7     MOVWF 0xE7
04C0  3005     MOVLW 0x5
04C1  00E6     MOVWF buffer
04C2  0022     MOVLB 0x2
04C3  0864     MOVF counter, W
04C4  0021     MOVLB 0x1
04C5  00E9     MOVWF 0xE9
04C6  0022     MOVLB 0x2
04C7  0863     MOVF i, W
04C8  0021     MOVLB 0x1
04C9  00E8     MOVWF dividend
04CA  3002     MOVLW 0x2
04CB  00EA     MOVWF strIncremet
04CC  3000     MOVLW 0x0
04CD  00EB     MOVWF str
04CE  3194     MOVLP 0x14
04CF  2481     CALL 0x481
04D0  3183     MOVLP 0x3
2891:                          }
04D1  2CD8     GOTO 0x4D8
2892:                          else
2893:                          {
2894:                              //UOWN already clear, but still need to set DTS to DATA1     
2895:          					p->STAT.Val |= _DAT1;
04D2  0022     MOVLB 0x2
04D3  0863     MOVF i, W
04D4  0086     MOVWF 0x106
04D5  0864     MOVF counter, W
04D6  0087     MOVWF 0x107
04D7  1701     BSF 0x101, 0x6
2896:                          }
2897:          
2898:                          //toggle back to the active BDT (the one the SIE is currently looking at
2899:                          //and will use for the next successful transaction to take place on the EP
2900:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
04D8  3004     MOVLW 0x4
04D9  0022     MOVLB 0x2
04DA  0663     XORWF i, W
04DB  00E3     MOVWF i
04DC  3000     MOVLW 0x0
04DD  0664     XORWF counter, W
04DE  00E4     MOVWF counter
2901:                          
2902:                          //Check if we are currently terminating, or have previously terminated
2903:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2904:                          //set DTS to the proper state, and call the application callback
2905:                          //function.
2906:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
04DF  18E2     BTFSC i, 0x1
04E0  2CE7     GOTO 0x4E7
04E1  0863     MOVF i, W
04E2  0086     MOVWF 0x106
04E3  0864     MOVF counter, W
04E4  0087     MOVWF 0x107
04E5  1F81     BTFSS 0x101, 0x7
04E6  2D13     GOTO 0x513
2907:                          {
2908:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
04E7  0021     MOVLB 0x1
04E8  1BA4     BTFSC 0xA4, 0x7
04E9  2CEE     GOTO 0x4EE
2909:                              {
2910:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
04EA  0824     MOVF 0xA4, W
04EB  390F     ANDLW 0xF
04EC  3E2F     ADDLW 0x2F
04ED  2CF1     GOTO 0x4F1
2911:                              }
2912:                              else
2913:                              {
2914:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
04EE  0824     MOVF 0xA4, W
04EF  390F     ANDLW 0xF
04F0  3E2A     ADDLW 0x2A
04F1  0086     MOVWF 0x86
04F2  3002     MOVLW 0x2
04F3  0087     MOVWF 0x87
04F4  1081     BCF 0x81, 0x1
2915:                              }
2916:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2917:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
04F5  303B     MOVLW 0x3B
04F6  00EC     MOVWF powerOfTen
04F7  0022     MOVLB 0x2
04F8  0863     MOVF i, W
04F9  0086     MOVWF 0x106
04FA  0864     MOVF counter, W
04FB  0087     MOVWF 0x107
04FC  0021     MOVLB 0x1
04FD  086C     MOVF powerOfTen, W
04FE  0581     ANDWF 0x81, F
2918:                              //Call the application event handler callback function, so it can 
2919:          					//decide if the endpoint should get re-armed again or not.
2920:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
04FF  3000     MOVLW 0x0
0500  00E7     MOVWF 0xE7
0501  3005     MOVLW 0x5
0502  00E6     MOVWF buffer
0503  0022     MOVLB 0x2
0504  0864     MOVF counter, W
0505  0021     MOVLB 0x1
0506  00E9     MOVWF 0xE9
0507  0022     MOVLB 0x2
0508  0863     MOVF i, W
0509  0021     MOVLB 0x1
050A  00E8     MOVWF dividend
050B  3002     MOVLW 0x2
050C  00EA     MOVWF strIncremet
050D  3000     MOVLW 0x0
050E  00EB     MOVWF str
050F  3194     MOVLP 0x14
0510  2481     CALL 0x481
0511  3183     MOVLP 0x3
2921:                          }
0512  2D1E     GOTO 0x51E
2922:                          else
2923:                          {
2924:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2925:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
0513  303B     MOVLW 0x3B
0514  0021     MOVLB 0x1
0515  00EC     MOVWF powerOfTen
0516  0022     MOVLB 0x2
0517  0863     MOVF i, W
0518  0086     MOVWF 0x106
0519  0864     MOVF counter, W
051A  0087     MOVWF 0x107
051B  0021     MOVLB 0x1
051C  086C     MOVF powerOfTen, W
051D  0581     ANDWF 0x81, F
2926:                          } 
2927:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2928:                          //Check if we need to call the user transfer terminated event callback function.
2929:                          //We should call the callback, if the endpoint was previously terminated,
2930:                          //or the endpoint is currently armed, and the host is performing clear
2931:                          //endpoint halt, even though the endpoint wasn't stalled.
2932:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2933:                          {
2934:                              //We are going to call the user transfer terminated callback.
2935:                              //Clear the flag so we know we took care of it and don't need
2936:                              //to call it again later.
2937:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2938:                              {
2939:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2940:                              }
2941:                              else
2942:                              {
2943:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2944:                              }
2945:           
2946:                              //Clear UOWN and remove the STALL condition.   
2947:                              //  In this case we also need to set the DTS bit to 1 so that
2948:                              //  it toggles to DATA0 the next time the application firmware
2949:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2950:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2951:                              p->STAT.Val |= _DAT1;
2952:                              //Let the application firmware know a transaction just
2953:                              //got terminated by the host, and that it is now free to
2954:                              //re-arm the endpoint or do other tasks if desired.                                        
2955:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2956:                          }
2957:                          else
2958:                          {
2959:                              //Clear UOWN and remove the STALL condition.   
2960:                              //  In this case we also need to set the DTS bit to 1 so that
2961:                              //  it toggles to DATA0 the next time the application firmware
2962:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2963:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2964:                              p->STAT.Val |= _DAT1;
2965:                          } 
2966:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2967:                      
2968:          			//Get a pointer to the appropriate UEPn register
2969:                      #if defined(__C32__)
2970:                          pUEP = (uint32_t*)(&U1EP0);
2971:                          pUEP += (SetupPkt.EPNum*4);
2972:                      #else
2973:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
051E  0021     MOVLB 0x1
051F  0824     MOVF 0xA4, W
0520  390F     ANDLW 0xF
0521  3E98     ADDLW 0x98
0522  00EC     MOVWF powerOfTen
0523  01ED     CLRF ziffer
0524  300E     MOVLW 0xE
0525  3DED     ADDWFC ziffer, F
0526  086C     MOVF powerOfTen, W
0527  0022     MOVLB 0x2
0528  00E0     MOVWF __pcstackBANK2
0529  0021     MOVLB 0x1
052A  086D     MOVF ziffer, W
052B  0022     MOVLB 0x2
052C  00E1     MOVWF sign
2974:                      #endif
2975:          
2976:          			//Clear the STALL bit in the UEP register
2977:                      *pUEP &= ~UEP_STALL;            
052D  30FE     MOVLW 0xFE
052E  0021     MOVLB 0x1
052F  00EC     MOVWF powerOfTen
0530  0022     MOVLB 0x2
0531  0860     MOVF __pcstackBANK2, W
0532  0086     MOVWF 0x106
0533  0861     MOVF sign, W
0534  0087     MOVWF 0x107
0535  0021     MOVLB 0x1
0536  086C     MOVF powerOfTen, W
0537  0581     ANDWF 0x81, F
2978:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0538  0008     RETURN
2979:              }//end if (lots of checks for set/clear endpoint halt)
2980:          }//end USBStdFeatureReqHandler
2981:          
2982:          
2983:          
2984:          
2985:          /**************************************************************************
2986:              Function:
2987:                  void USBIncrement1msInternalTimers(void)
2988:          
2989:              Description:
2990:                  This function increments internal 1ms time base counters, which are
2991:                  useful for application code (that can use a 1ms time base/counter), and
2992:                  for certain USB event timing specific purposes.
2993:          
2994:                  In USB full speed applications, the application code does not need to (and should
2995:                  not) explicitly call this function, as the USBDeviceTasks() function will
2996:                  automatically call this function whenever a 1ms time interval has elapsed
2997:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2998:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
2999:                  in USB_INTERRUPT mode).
3000:          
3001:                  In USB low speed applications, the application firmware is responsible for
3002:                  periodically calling this function at a ~1ms rate.  This can be done using
3003:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
3004:                  If the low speed application code does not call this function, the internal timers
3005:                  will not increment, and the USBGet1msTickCount() API function will not be available.
3006:                  Additionally, certain USB stack operations (like control transfer timeouts)
3007:                  may be unavailable.
3008:          
3009:              Precondition:
3010:                  This function should be called only after USBDeviceInit() has been
3011:                  called (at least once at the start of the application).  Ordinarily,
3012:                  application code should never call this function, unless it is a low speed
3013:                  USB device.
3014:          
3015:              Parameters:
3016:                  None
3017:          
3018:              Return Values:
3019:                  None
3020:          
3021:              Remarks:
3022:                  This function does not need to be called during USB suspend conditions, when
3023:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
3024:            ***************************************************************************/
3025:          void USBIncrement1msInternalTimers(void)
3026:          {
3027:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3028:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3029:              #endif
3030:          
3031:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3032:              //that needs a 1ms time base that is active during USB non-suspended operation.
3033:              USB1msTickCount++;
1288  3001     MOVLW 0x1
1289  0024     MOVLB 0x4
128A  07BC     ADDWF USB1msTickCount, F
128B  3000     MOVLW 0x0
128C  3DBD     ADDWFC 0x23D, F
128D  3000     MOVLW 0x0
128E  3DBE     ADDWFC 0x23E, F
128F  3000     MOVLW 0x0
1290  3DBF     ADDWFC 0x23F, F
3034:              if(USBIsBusSuspended() == false)
1291  0023     MOVLB 0x3
1292  0848     MOVF USBBusIsSuspended, W
1293  1D03     BTFSS 0x183, 0x2
1294  0008     RETURN
3035:              {
3036:                  USBTicksSinceSuspendEnd++;
1295  3001     MOVLW 0x1
1296  00F2     MOVWF 0x1F2
1297  0872     MOVF 0x1F2, W
1298  07D0     ADDWF USBTicksSinceSuspendEnd, F
3037:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3038:                  if(USBTicksSinceSuspendEnd == 0)
1299  0850     MOVF USBTicksSinceSuspendEnd, W
129A  1D03     BTFSS 0x183, 0x2
129B  0008     RETURN
3039:                  {
3040:                      USBTicksSinceSuspendEnd = 255;
129C  30FF     MOVLW 0xFF
129D  00F2     MOVWF 0x1F2
129E  0872     MOVF 0x1F2, W
129F  00D0     MOVWF USBTicksSinceSuspendEnd
3041:                  }
12A0  0008     RETURN
3042:              }
3043:          }
3044:          
3045:          
3046:          
3047:          
3048:          /**************************************************************************
3049:              Function:
3050:                  uint32_t USBGet1msTickCount(void)
3051:          
3052:              Description:
3053:                  This function retrieves a 32-bit unsigned integer that normally increments by
3054:                  one every one millisecond.  The count value starts from zero when the
3055:                  USBDeviceInit() function is first called.  See the remarks section for
3056:                  details on special circumstances where the tick count will not increment.
3057:          
3058:              Precondition:
3059:                  This function should be called only after USBDeviceInit() has been
3060:                  called (at least once at the start of the application).
3061:          
3062:              Parameters:
3063:                  None
3064:          
3065:              Return Values:
3066:                  uint32_t representing the approximate millisecond count, since the time the
3067:                  USBDeviceInit() function was first called.
3068:          
3069:              Remarks:
3070:                  On 8-bit USB full speed devices, the internal counter is incremented on
3071:                  every SOF packet detected.  Therefore, it will not increment during suspend
3072:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3073:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3074:                  on 16-bit devices, the count continue to increment during USB suspend or
3075:                  detach events, so long as the application code has not put the microcontroller
3076:                  to sleep during these events, and the application firmware is regularly
3077:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3078:                  USB_INTERRUPT mode operation).
3079:          
3080:                  In USB low speed applications, the host does not broadcast SOF packets to
3081:                  the device, so the application firmware becomes responsible for calling
3082:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3083:                  timer interrupt handler), or else the returned value from this function will
3084:                  not increment.
3085:                  
3086:                  Prior to calling USBDeviceInit() for the first time the returned value will
3087:                  be unpredictable.
3088:          
3089:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3090:                  code without risk of retrieving a partially updated 32-bit number.
3091:          
3092:                  However, this value only increments when the USBDeviceTasks() function is allowed
3093:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3094:                  function.  If however USB_POLLING mode is used, one must not block on this
3095:                  function without also calling USBDeviceTasks() continuously for the blocking
3096:                  duration (since the USB stack must still be allowed to execute, and the USB
3097:                  stack is also responsible for updating the tick counter internally).
3098:          
3099:                  If the application is operating in USB_POLLING mode, this function should
3100:                  only be called from the main loop context, and not from an interrupt handler,
3101:                  as the returned value could be incorrect, if the main loop context code was in
3102:                  the process of updating the internal count at the moment of the interrupt event.
3103:             ***************************************************************************/
3104:          uint32_t USBGet1msTickCount(void)
3105:          {
3106:              #if defined (USB_INTERRUPT)
3107:                  uint32_t localContextValue;
3108:          
3109:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3110:                  //value.  This ensures that the complete 32-bit value got read without
3111:                  //getting interrupted in between bytes.
3112:                  do
3113:                  {
3114:                      localContextValue = USB1msTickCount;
3115:                  }while(localContextValue != USB1msTickCount);
3116:          
3117:                  return localContextValue;    
3118:              
3119:              #else
3120:                  return USB1msTickCount;
3121:              #endif
3122:          }
3123:          
3124:          
3125:          
3126:          
3127:          
3128:          
3129:          /** EOF USBDevice.c *****************************************************/
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/tmr2.c  -------------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include <xc.h>
51:            #include "tmr2.h"
52:            
53:            /**
54:              Section: Global Variables Definitions
55:            */
56:            
57:            void (*TMR2_InterruptHandler)(void);
58:            
59:            /**
60:              Section: TMR2 APIs
61:            */
62:            
63:            void TMR2_Initialize(void)
64:            {
65:                // Set TMR2 to the options selected in the User Interface
66:            
67:                // T2CKPS 1:1; T2OUTPS 1:1; TMR2ON off; 
68:                T2CON = 0x00;
11E7  0020     MOVLB 0x0
11E8  019C     CLRF T2CON
69:            
70:                // PR2 23; 
71:                PR2 = 0x17;
11E9  3017     MOVLW 0x17
11EA  009B     MOVWF PR2
72:            
73:                // TMR2 0; 
74:                TMR2 = 0x00;
11EB  019A     CLRF TMR2
75:            
76:                // Clearing IF flag.
77:                PIR1bits.TMR2IF = 0;
11EC  1091     BCF PIR1, 0x1
78:            
79:                // Start TMR2
80:                TMR2_StartTimer();
11ED  3191     MOVLP 0x11
11EE  21D2     CALL 0x1D2
81:            }
11EF  0008     RETURN
82:            
83:            void TMR2_StartTimer(void)
84:            {
85:                // Start the Timer by writing to TMRxON bit
86:                T2CONbits.TMR2ON = 1;
11D2  0020     MOVLB 0x0
11D3  151C     BSF T2CON, 0x2
87:            }
11D4  0008     RETURN
88:            
89:            void TMR2_StopTimer(void)
90:            {
91:                // Stop the Timer by writing to TMRxON bit
92:                T2CONbits.TMR2ON = 0;
93:            }
94:            
95:            uint8_t TMR2_ReadTimer(void)
96:            {
97:                uint8_t readVal;
98:            
99:                readVal = TMR2;
100:           
101:               return readVal;
102:           }
103:           
104:           void TMR2_WriteTimer(uint8_t timerVal)
105:           {
106:               // Write to the Timer2 register
107:               TMR2 = timerVal;
108:           }
109:           
110:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
111:           {
112:              PR2 = periodVal;
113:           }
114:           
115:           bool TMR2_HasOverflowOccured(void)
116:           {
117:               // check if  overflow has occurred by checking the TMRIF bit
118:               bool status = PIR1bits.TMR2IF;
119:               if(status)
120:               {
121:                   // Clearing IF flag.
122:                   PIR1bits.TMR2IF = 0;
123:               }
124:               return status;
125:           }
126:           /**
127:             End of File
128:           */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/tmr1.c  -------------------------
1:             /**
2:               TMR1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR1 driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This source file provides APIs for TMR1.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include <xc.h>
51:            #include "tmr1.h"
52:            
53:            /**
54:              Section: Global Variables Definitions
55:            */
56:            volatile uint16_t timer1ReloadVal;
57:            void (*TMR1_InterruptHandler)(void);
58:            
59:            /**
60:              Section: TMR1 APIs
61:            */
62:            
63:            void TMR1_Initialize(void)
64:            {
65:                //Set the Timer to the options selected in the GUI
66:            
67:                //T1CKPS 1:8; T1OSCEN disabled; nT1SYNC do_not_synchronize; TMR1CS LFINTOSC; TMR1ON off; 
68:                T1CON = 0xF4;
122F  30F4     MOVLW 0xF4
1230  0020     MOVLB 0x0
1231  0098     MOVWF T1CON
69:            
70:                //T1GSS T1G; TMR1GE disabled; T1GTM disabled; T1GPOL low; T1GGO_nDONE done; T1GSPM disabled; 
71:                T1GCON = 0x00;
1232  0199     CLRF T1GCON
72:            
73:                //TMR1H 244; 
74:                TMR1H = 0xF4;
1233  30F4     MOVLW 0xF4
1234  0097     MOVWF TMR1H
75:            
76:                //TMR1L 166; 
77:                TMR1L = 0xA6;
1235  30A6     MOVLW 0xA6
1236  0096     MOVWF TMR1
78:            
79:                // Load the TMR value to reload variable
80:                timer1ReloadVal=(TMR1H << 8) | TMR1L;
1237  0817     MOVF TMR1H, W
1238  0023     MOVLB 0x3
1239  00BF     MOVWF 0x1BF
123A  0020     MOVLB 0x0
123B  0816     MOVF TMR1, W
123C  0023     MOVLB 0x3
123D  00BE     MOVWF timer1ReloadVal
81:            
82:                // Clearing IF flag.
83:                PIR1bits.TMR1IF = 0;
123E  0020     MOVLB 0x0
123F  1011     BCF PIR1, 0x0
84:            
85:                // Start TMR1
86:                TMR1_StartTimer();
1240  3191     MOVLP 0x11
1241  21CF     CALL 0x1CF
87:            }
1242  0008     RETURN
88:            
89:            void TMR1_StartTimer(void)
90:            {
91:                // Start the Timer by writing to TMRxON bit
92:                T1CONbits.TMR1ON = 1;
11CF  0020     MOVLB 0x0
11D0  1418     BSF T1CON, 0x0
93:            }
11D1  0008     RETURN
94:            
95:            void TMR1_StopTimer(void)
96:            {
97:                // Stop the Timer by writing to TMRxON bit
98:                T1CONbits.TMR1ON = 0;
99:            }
100:           
101:           uint16_t TMR1_ReadTimer(void)
102:           {
103:               uint16_t readVal;
104:           
105:               readVal = (TMR1H << 8) | TMR1L;
106:           
107:               return readVal;
108:           }
109:           
110:           void TMR1_WriteTimer(uint16_t timerVal)
111:           {
112:               if (T1CONbits.nT1SYNC == 1)
113:               {
114:                   // Stop the Timer by writing to TMRxON bit
115:                   T1CONbits.TMR1ON = 0;
116:           
117:                   // Write to the Timer1 register
118:                   TMR1H = (timerVal >> 8);
119:                   TMR1L = timerVal;
120:           
121:                   // Start the Timer after writing to the register
122:                   T1CONbits.TMR1ON =1;
123:               }
124:               else
125:               {
126:                   // Write to the Timer1 register
127:                   TMR1H = (timerVal >> 8);
128:                   TMR1L = timerVal;
129:               }
130:           }
131:           
132:           void TMR1_Reload(void)
133:           {
134:               //Write to the Timer1 register
135:               TMR1H = (timer1ReloadVal >> 8);
11F0  0023     MOVLB 0x3
11F1  083F     MOVF 0x1BF, W
11F2  0020     MOVLB 0x0
11F3  0097     MOVWF TMR1H
136:               TMR1L = timer1ReloadVal;
11F4  0023     MOVLB 0x3
11F5  083E     MOVF timer1ReloadVal, W
11F6  0020     MOVLB 0x0
11F7  0096     MOVWF TMR1
137:           }
11F8  0008     RETURN
138:           
139:           void TMR1_StartSinglePulseAcquisition(void)
140:           {
141:               T1GCONbits.T1GGO_nDONE = 1;
142:           }
143:           
144:           uint8_t TMR1_CheckGateValueStatus(void)
145:           {
146:               return (T1GCONbits.T1GVAL);
147:           }
148:           
149:           bool TMR1_HasOverflowOccured(void)
150:           {
151:               // check if  overflow has occurred by checking the TMRIF bit
152:               return(PIR1bits.TMR1IF);
153:           }
154:           /**
155:             End of File
156:           */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/pwm2.c  -------------------------
1:              /**
2:                PWM2 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm2.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM2 driver using MPLAB(c) Code Configurator
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM2.
15:                 Generation Information :
16:                     Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                     Device            :  PIC16F1455
18:                     Driver Version    :  2.00
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 1.35
21:                     MPLAB             :  MPLAB X 3.40
22:             */ 
23:            
24:             /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:             
46:             /**
47:               Section: Included Files
48:             */
49:            
50:             #include <xc.h>
51:             #include "pwm2.h"
52:            
53:             /**
54:               Section: PWM Module APIs
55:             */
56:            
57:             void PWM2_Initialize(void)
58:             {
59:                 // Set the PWM to the options selected in the MPLAB(c) Code Configurator.
60:                 // PWM2POL active_lo; PWM2OE enabled; PWM2EN enabled; 
61:                 PWM2CON = 0xD0;
11E1  30D0     MOVLW 0xD0
11E2  002C     MOVLB 0xC
11E3  0096     MOVWF PWM2CON
62:                 
63:                 // PWM2DCH 0; 
64:                 PWM2DCH = 0x00;
11E4  0195     CLRF PWM2DCH
65:                 
66:                 // PWM2DCL 0; 
67:                 PWM2DCL = 0x00;
11E5  0194     CLRF PWM2DCL
68:                 
69:             }
11E6  0008     RETURN
70:            
71:             void PWM2_LoadDutyValue(uint16_t dutyValue)
72:             {
73:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
74:                 PWM2DCH = (dutyValue & 0x03FC)>>2;
1243  0873     MOVF 0x673, W
1244  00F5     MOVWF 0x675
1245  0872     MOVF 0x672, W
1246  00F4     MOVWF 0x674
1247  36F5     LSRF 0x675, F
1248  0CF4     RRF 0x674, F
1249  36F5     LSRF 0x675, F
124A  0CF4     RRF 0x674, F
124B  0874     MOVF 0x674, W
124C  002C     MOVLB 0xC
124D  0095     MOVWF PWM2DCH
75:                 
76:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
77:                 PWM2DCL = (dutyValue & 0x0003)<<6;
124E  0872     MOVF 0x672, W
124F  3903     ANDLW 0x3
1250  00F4     MOVWF 0x674
1251  3005     MOVLW 0x5
1252  35F4     LSLF 0x674, F
1253  3EFF     ADDLW 0xFF
1254  1D03     BTFSS 0x603, 0x2
1255  2A52     GOTO 0x252
1256  3574     LSLF 0x674, W
1257  0094     MOVWF PWM2DCL
78:             }
1258  0008     RETURN
79:             /**
80:              End of File
81:             */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/pin_manager.c  ------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using MPLAB(c) Code Configurator
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  1.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            
25:                Microchip licenses to you the right to use, modify, copy and distribute
26:                Software only when embedded on a Microchip microcontroller or digital signal
27:                controller that is integrated into your product or third party product
28:                (pursuant to the sublicense terms in the accompanying license agreement).
29:            
30:                You should refer to the license agreement accompanying this Software for
31:                additional information regarding your rights and obligations.
32:            
33:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:            
44:            */
45:            
46:            #include <xc.h>
47:            #include "pin_manager.h"
48:            #include "stdbool.h"
49:            
50:            
51:            void PIN_MANAGER_Initialize(void)
52:            {
53:                /**
54:                LATx registers
55:                */   
56:                LATA = 0x20;    
1259  3020     MOVLW 0x20
125A  0022     MOVLB 0x2
125B  008C     MOVWF LATA
57:                LATC = 0x00;    
125C  018E     CLRF LATC
58:            
59:                /**
60:                TRISx registers
61:                */    
62:                TRISA = 0x10;
125D  3010     MOVLW 0x10
125E  0021     MOVLB 0x1
125F  008C     MOVWF TRISA
63:                TRISC = 0x24;
1260  3024     MOVLW 0x24
1261  008E     MOVWF TRISC
64:            
65:                /**
66:                ANSELx registers
67:                */   
68:                ANSELC = 0x0F;
1262  300F     MOVLW 0xF
1263  0023     MOVLB 0x3
1264  008E     MOVWF ANSELC
69:                ANSELA = 0x10;
1265  3010     MOVLW 0x10
1266  008C     MOVWF ANSELA
70:            
71:                /**
72:                WPUx registers
73:                */ 
74:                WPUA = 0x08;
1267  3008     MOVLW 0x8
1268  0024     MOVLB 0x4
1269  008C     MOVWF WPUA
75:                OPTION_REGbits.nWPUEN = 0;
126A  0021     MOVLB 0x1
126B  1395     BCF OPTION_REG, 0x7
76:            
77:                
78:                /**
79:                APFCONx registers
80:                */
81:                APFCON = 0x04;
126C  3004     MOVLW 0x4
126D  0022     MOVLB 0x2
126E  009D     MOVWF APFCON
82:            
83:            
84:               
85:                
86:            }       
126F  0008     RETURN
87:            
88:            void PIN_MANAGER_IOC(void)
89:            {   
90:            
91:            }
92:            
93:            /**
94:             End of File
95:            */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/mcc.c  --------------------------
1:             /**
2:               @Generated MPLAB(c) Code Configurator Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using MPLAB(c) Code Configurator
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  1.02
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            // Configuration bits: selected in the GUI
47:            
48:            // CONFIG1
49:            #pragma config FOSC = INTOSC    // Oscillator Selection Bits->INTOSC oscillator: I/O function on CLKIN pin
50:            #pragma config WDTE = ON    // Watchdog Timer Enable->WDT enabled
51:            #pragma config PWRTE = OFF    // Power-up Timer Enable->PWRT disabled
52:            #pragma config MCLRE = ON    // MCLR Pin Function Select->MCLR/VPP pin function is MCLR
53:            #pragma config CP = ON    // Flash Program Memory Code Protection->Program memory code protection is enabled
54:            #pragma config BOREN = ON    // Brown-out Reset Enable->Brown-out Reset enabled
55:            #pragma config CLKOUTEN = OFF    // Clock Out Enable->CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin
56:            #pragma config IESO = OFF    // Internal/External Switchover Mode->Internal/External Switchover Mode is disabled
57:            #pragma config FCMEN = OFF    // Fail-Safe Clock Monitor Enable->Fail-Safe Clock Monitor is disabled
58:            
59:            // CONFIG2
60:            #pragma config WRT = OFF    // Flash Memory Self-Write Protection->Write protection off
61:            #pragma config CPUDIV = NOCLKDIV    // CPU System Clock Selection Bit->NO CPU system divide
62:            #pragma config USBLSCLK = 48MHz    // USB Low SPeed Clock Selection bit->System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.
63:            #pragma config PLLMULT = 3x    // PLL Multipler Selection Bit->3x Output Frequency Selected
64:            #pragma config PLLEN = ENABLED    // PLL Enable Bit->3x or 4x PLL Enabled
65:            #pragma config STVREN = ON    // Stack Overflow/Underflow Reset Enable->Stack Overflow or Underflow will cause a Reset
66:            #pragma config BORV = LO    // Brown-out Reset Voltage Selection->Brown-out Reset Voltage (Vbor), low trip point selected.
67:            #pragma config LPBOR = OFF    // Low-Power Brown Out Reset->Low-Power BOR is disabled
68:            #pragma config LVP = OFF    // Low-Voltage Programming Enable->High-voltage on MCLR/VPP must be used for programming
69:            
70:            #include "mcc.h"
71:            
72:            void SYSTEM_Initialize(void)
73:            {
74:            
75:                PIN_MANAGER_Initialize();
12A1  3192     MOVLP 0x12
12A2  2259     CALL 0x259
12A3  3192     MOVLP 0x12
76:                OSCILLATOR_Initialize();
12A4  3192     MOVLP 0x12
12A5  2203     CALL 0x203
12A6  3192     MOVLP 0x12
77:                WDT_Initialize();
12A7  3191     MOVLP 0x11
12A8  21D9     CALL 0x1D9
12A9  3192     MOVLP 0x12
78:                FVR_Initialize();
12AA  3191     MOVLP 0x11
12AB  21D5     CALL 0x1D5
12AC  3192     MOVLP 0x12
79:                PWM2_Initialize();
12AD  3191     MOVLP 0x11
12AE  21E1     CALL 0x1E1
12AF  3192     MOVLP 0x12
80:                ADC_Initialize();
12B0  3191     MOVLP 0x11
12B1  21F9     CALL 0x1F9
12B2  3192     MOVLP 0x12
81:                TMR2_Initialize();
12B3  3191     MOVLP 0x11
12B4  21E7     CALL 0x1E7
12B5  3192     MOVLP 0x12
82:                TMR1_Initialize();
12B6  3192     MOVLP 0x12
12B7  222F     CALL 0x22F
12B8  3192     MOVLP 0x12
83:                EUSART_Initialize();
12B9  3188     MOVLP 0x8
12BA  2000     CALL 0x0
84:            }
12BB  0008     RETURN
85:            
86:            void OSCILLATOR_Initialize(void)
87:            {
88:                // SCS FOSC; SPLLMULT 3xPLL; SPLLEN enabled; IRCF 16MHz_HF; 
89:                OSCCON = 0xFC;
1203  30FC     MOVLW 0xFC
1204  0021     MOVLB 0x1
1205  0099     MOVWF OSCCON
90:                // TUN 0; 
91:                OSCTUNE = 0x00;
1206  0198     CLRF OSCTUNE
92:                // ACTSRC Full speed USB events; ACTUD enabled; ACTEN enabled; 
93:                ACTCON = 0x90;
1207  3090     MOVLW 0x90
1208  0027     MOVLB 0x7
1209  009B     MOVWF ACTCON
94:                // Set the secondary oscillator
95:                
96:                // Wait for PLL to stabilize
97:                while(PLLRDY == 0)
98:                {
99:                }
120A  0021     MOVLB 0x1
100:           }
101:           
102:           void WDT_Initialize(void)
103:           {
104:               // WDTPS 1:256; SWDTEN OFF; 
105:               WDTCON = 0x06;
11D9  3006     MOVLW 0x6
11DA  0021     MOVLB 0x1
11DB  0097     MOVWF WDTCON
106:           }
11DC  0008     RETURN
107:           
108:           /**
109:            End of File
110:           */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/fvr.c  --------------------------
1:             /**
2:               FVR Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 fvr.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the FVR driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This source file provides APIs for FVR.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include <xc.h>
51:            #include "fvr.h"
52:            
53:            /**
54:              Section: FVR APIs
55:            */
56:            
57:            void FVR_Initialize(void)
58:            {
59:                // CDAFVR off; FVREN enabled; TSRNG Lo_range; ADFVR 4x; TSEN disabled; 
60:                FVRCON = 0x83;
11D5  3083     MOVLW 0x83
11D6  0022     MOVLB 0x2
11D7  0097     MOVWF FVRCON
61:            }
11D8  0008     RETURN
62:            
63:            bool FVR_IsOutputReady(void)
64:            {
65:                return (FVRCONbits.FVRRDY);
66:            }
67:            /**
68:             End of File
69:            */
70:            
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/eusart.c  -----------------------
1:             /**
2:               EUSART Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for EUSART.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            #include "eusart.h"
50:            
51:            /**
52:              Section: EUSART APIs
53:            */
54:            
55:            void EUSART_Initialize(void)
56:            {
57:                // Set the EUSART module to the options selected in the user interface.
58:            
59:                // ABDOVF no_overflow; SCKP Non-Inverted; RCIDL idle; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
60:                BAUDCON = 0x48;
0800  3048     MOVLW 0x48
0801  0023     MOVLB 0x3
0802  009F     MOVWF BAUDCON
61:            
62:                // SPEN enabled; OERR no_error; RX9 8-bit; RX9D 0; CREN enabled; ADDEN disabled; SREN disabled; FERR no_error; 
63:                RCSTA = 0x90;
0803  3090     MOVLW 0x90
0804  009D     MOVWF RCSTA
64:            
65:                // TRMT TSR_empty; TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
66:                TXSTA = 0x26;
0805  3026     MOVLW 0x26
0806  009E     MOVWF TXSTA
67:            
68:                // Baud Rate = 9600; SPBRGL 225; 
69:                SPBRGL = 0xE1;
0807  30E1     MOVLW 0xE1
0808  009B     MOVWF SPBRG
70:            
71:                // Baud Rate = 9600; SPBRGH 4; 
72:                SPBRGH = 0x04;
0809  3004     MOVLW 0x4
080A  009C     MOVWF SPBRGH
73:            
74:            }
080B  0008     RETURN
75:            
76:            
77:            uint8_t EUSART_Read(void)
78:            {
79:            
80:                while(!PIR1bits.RCIF)
81:                {
82:                }
83:            
84:                
85:                if(1 == RCSTAbits.OERR)
86:                {
87:                    // EUSART error - restart
88:            
89:                    RCSTAbits.CREN = 0; 
90:                    RCSTAbits.CREN = 1; 
91:                }
92:            
93:                return RCREG;
94:            }
95:            
96:            void EUSART_Write(uint8_t txData)
97:            {
98:                while(0 == PIR1bits.TXIF)
99:                {
100:               }
101:           
102:               TXREG = txData;    // Write the data byte to the USART.
103:           }
104:           /**
105:             End of File
106:           */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/mcc_generated_files/adc.c  --------------------------
1:             /**
2:               ADC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADC driver using MPLAB(c) Code Configurator
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for ADC.
15:                Generation Information :
16:                    Product Revision  :  MPLAB(c) Code Configurator - 4.15
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.35
21:                    MPLAB             :  MPLAB X 3.40
22:            */
23:            
24:            /*
25:                (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                software and any derivatives exclusively with Microchip products.
27:            
28:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:            
42:                MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                TERMS.
44:            */
45:            
46:            /**
47:              Section: Included Files
48:            */
49:            
50:            #include <xc.h>
51:            #include "adc.h"
52:            #include "mcc.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            
58:            #define ACQ_US_DELAY 5
59:            
60:            /**
61:              Section: ADC Module APIs
62:            */
63:            
64:            void ADC_Initialize(void)
65:            {
66:                // set the ADC to the options selected in the User Interface
67:                
68:                // GO_nDONE stop; ADON enabled; CHS AN6; 
69:                ADCON0 = 0x19;
11F9  3019     MOVLW 0x19
11FA  0021     MOVLB 0x1
11FB  009D     MOVWF ADCON0
70:                
71:                // ADFM right; ADPREF FVR; ADCS FOSC/64; 
72:                ADCON1 = 0xE3;
11FC  30E3     MOVLW 0xE3
11FD  009E     MOVWF ADCON1
73:                
74:                // TRIGSEL no_auto_trigger; 
75:                ADCON2 = 0x00;
11FE  019F     CLRF ADCON2
76:                
77:                // ADRESL 0; 
78:                ADRESL = 0x00;
11FF  019B     CLRF ADRES
79:                
80:                // ADRESH 0; 
81:                ADRESH = 0x00;
1200  019C     CLRF ADRESH
82:                
83:                // Enabling ADC interrupt.
84:                PIE1bits.ADIE = 1;
1201  1711     BSF PIE1, 0x6
85:            }
1202  0008     RETURN
86:            
87:            void ADC_SelectChannel(adc_channel_t channel)
88:            {
89:                // select the A/D channel
90:                ADCON0bits.CHS = channel;    
91:                // Turn on the ADC module
92:                ADCON0bits.ADON = 1;  
93:            }
94:            
95:            void ADC_StartConversion()
96:            {
97:                // Start the conversion
98:                ADCON0bits.GO_nDONE = 1;
11CC  0021     MOVLB 0x1
11CD  149D     BSF ADCON0, 0x1
99:            }
11CE  0008     RETURN
100:           
101:           
102:           bool ADC_IsConversionDone()
103:           {
104:               // Start the conversion
105:               return (!ADCON0bits.GO_nDONE);
106:           }
107:           
108:           adc_result_t ADC_GetConversionResult(void)
109:           {
110:               // Conversion finished, return the result
111:               return ((ADRESH << 8) + ADRESL);
112:           }
113:           
114:           adc_result_t ADC_GetConversion(adc_channel_t channel)
115:           {
116:               // select the A/D channel
117:               ADCON0bits.CHS = channel;    
118:           
119:               // Turn on the ADC module
120:               ADCON0bits.ADON = 1;
121:               // Acquisition time delay
122:               __delay_us(ACQ_US_DELAY);
123:           
124:               // Start the conversion
125:               ADCON0bits.GO_nDONE = 1;
126:           
127:               // Wait for the conversion to finish
128:               while (ADCON0bits.GO_nDONE)
129:               {
130:               }
131:               // Conversion finished, return the result
132:               return ((ADRESH << 8) + ADRESL);
133:           
134:           }
135:           
136:           
137:           //void ADC_ISR(void)
138:           //{
139:           //    // Clear the ADC interrupt flag
140:           //    PIR1bits.ADIF = 0;
141:           //}
142:           /**
143:            End of File
144:           */
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/main.c  ---------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #include "system.h"
22:            
23:            #include "app_uart_usb_utils.h"
24:            
25:            #include "usb.h"
26:            #include "usb_device.h"
27:            #include "usb_device_cdc.h"
28:            #include "mcc_generated_files/mcc.h"
29:            #include <stdlib.h>
30:            
31:            //#define PWM_TEST
32:            #define PWM_PERIOD                      (93)// (333)//142kHz.   (93)//500KHz,  (237) //200KHz
33:            #define PWM_PERIOD_LIMIT                (PWM_PERIOD)
34:            #define PWM_REGULATION_SWITCH_LIMIT     (4800/1761) //4v8
35:            
36:            #define MAX_POWER_mWt           (2400000U)
37:            
38:            #define MAX_UOUT_mV             (15000U)
39:            #define MIN_UOUT_mV             (0U)
40:            
41:            #define MAX_IOUT_mA             (1000U)
42:            #define MIN_IOUT_mA             (0U)
43:            
44:            uint8_t PwmDutyCycleVoltageLimit = 0, rampPwmDutyCycleVoltageLimit = 0;
45:            volatile uint16_t Uadc = 0, Iadc = 0;
46:            uint16_t Iadc_limit = 0, Uadc_target = 0;
47:            
48:            int32_t MAIN_Uout_target_mV = 0;
49:            int32_t MAIN_Iout_limit_mA = 500;
50:            
51:            static uint16_t MAIN_Uout_mV = 0;
52:            static uint16_t MAIN_Iout_mA = 0;
53:            static int8_t MAIN_ovcFlag = 0;
54:            
55:            static uint8_t readBuffer[CDC_DATA_OUT_EP_SIZE];
56:            static uint8_t writeBuffer[CDC_DATA_IN_EP_SIZE];
57:            static uint8_t writeStatusBuffer[CDC_DATA_IN_EP_SIZE];
58:            
59:            static const uint8_t errorMsg[] = "Wrong cmd!\r\n";
60:            static const uint8_t okMsg[] = "OK\r\n";
61:            
62:            static uint8_t USB_Out_Buffer[CDC_DATA_OUT_EP_SIZE];
63:            static uint8_t RS232_Out_Data[CDC_DATA_IN_EP_SIZE];
64:            unsigned char  NextUSBOut;
65:            unsigned char  NextUSBOut;
66:            unsigned char  LastRS232Out;  // Number of characters in the buffer
67:            unsigned char  RS232cp;       // current position within the buffer
68:            unsigned char  RS232_Out_Data_Rdy = 0;
69:            
70:            //we use stepDown for voltages 0..5v, stepUp for 5..15v
71:            void main_switchStepUp_Down(int32_t Uout_mV)
72:            {
73:               //disable power
74:               RA5_SetHigh();
0C23  0022     MOVLB 0x2
0C24  168C     BSF LATA, 0x5
75:               //adjust PWM
76:               if(Uout_mV <= 4600) { 
0C25  1BE9     BTFSC dwBaud, 0x7
0C26  2C33     GOTO 0x433
0C27  0869     MOVF dwBaud, W
0C28  1D03     BTFSS 0x103, 0x2
0C29  2C6F     GOTO 0x46F
0C2A  0868     MOVF 0x168, W
0C2B  1D03     BTFSS 0x103, 0x2
0C2C  2C6F     GOTO 0x46F
0C2D  30F9     MOVLW 0xF9
0C2E  0266     SUBWF Uout_mV, W
0C2F  3011     MOVLW 0x11
0C30  3B67     SUBWFB 0x167, W
0C31  1803     BTFSC 0x103, 0x0
0C32  2C6F     GOTO 0x46F
77:                    PwmDutyCycleVoltageLimit = 15+(PWM_PERIOD*(Uout_mV))/(5000);//use larger PWM due to losses in coil and diod
0C33  3000     MOVLW 0x0
0C34  0021     MOVLB 0x1
0C35  00E7     MOVWF 0xE7
0C36  3000     MOVLW 0x0
0C37  00E6     MOVWF buffer
0C38  3013     MOVLW 0x13
0C39  00E5     MOVWF byte_to_send
0C3A  3088     MOVLW 0x88
0C3B  00E4     MOVWF ep
0C3C  0022     MOVLB 0x2
0C3D  0869     MOVF dwBaud, W
0C3E  00F5     MOVWF 0x175
0C3F  0868     MOVF 0x168, W
0C40  00F4     MOVWF 0x174
0C41  0867     MOVF 0x167, W
0C42  00F3     MOVWF 0x173
0C43  0866     MOVF Uout_mV, W
0C44  00F2     MOVWF 0x172
0C45  3000     MOVLW 0x0
0C46  00F9     MOVWF 0x179
0C47  3000     MOVLW 0x0
0C48  00F8     MOVWF 0x178
0C49  3000     MOVLW 0x0
0C4A  00F7     MOVWF 0x177
0C4B  305D     MOVLW 0x5D
0C4C  00F6     MOVWF 0x176
0C4D  3193     MOVLP 0x13
0C4E  23A5     CALL 0x3A5
0C4F  318C     MOVLP 0xC
0C50  0875     MOVF 0x175, W
0C51  0021     MOVLB 0x1
0C52  00EB     MOVWF str
0C53  0874     MOVF 0xF4, W
0C54  00EA     MOVWF strIncremet
0C55  0873     MOVF 0xF3, W
0C56  00E9     MOVWF 0xE9
0C57  0872     MOVF 0xF2, W
0C58  00E8     MOVWF dividend
0C59  3187     MOVLP 0x7
0C5A  2760     CALL 0x760
0C5B  318C     MOVLP 0xC
0C5C  0021     MOVLB 0x1
0C5D  0864     MOVF ep, W
0C5E  3E0F     ADDLW 0xF
0C5F  00ED     MOVWF ziffer
0C60  086D     MOVF ziffer, W
0C61  0023     MOVLB 0x3
0C62  00C4     MOVWF PwmDutyCycleVoltageLimit
78:                    PWM2_LoadDutyValue(0);
0C63  3000     MOVLW 0x0
0C64  00F2     MOVWF 0x1F2
0C65  00F3     MOVWF 0x1F3
0C66  3192     MOVLP 0x12
0C67  2243     CALL 0x243
79:                    PWM2CON = 0xD0; //active LOW
0C68  30D0     MOVLW 0xD0
0C69  002C     MOVLB 0xC
0C6A  0096     MOVWF PWM2CON
80:                    APFCON = 0x04;
0C6B  3004     MOVLW 0x4
0C6C  0022     MOVLB 0x2
0C6D  009D     MOVWF APFCON
81:                } else {
0C6E  0008     RETURN
82:                    PwmDutyCycleVoltageLimit = ((PWM_PERIOD*(Uout_mV - 4600))/Uout_mV);
0C6F  0869     MOVF dwBaud, W
0C70  0021     MOVLB 0x1
0C71  00E7     MOVWF 0xE7
0C72  0022     MOVLB 0x2
0C73  0868     MOVF 0x168, W
0C74  0021     MOVLB 0x1
0C75  00E6     MOVWF buffer
0C76  0022     MOVLB 0x2
0C77  0867     MOVF 0x167, W
0C78  0021     MOVLB 0x1
0C79  00E5     MOVWF byte_to_send
0C7A  0022     MOVLB 0x2
0C7B  0866     MOVF Uout_mV, W
0C7C  0021     MOVLB 0x1
0C7D  00E4     MOVWF ep
0C7E  3008     MOVLW 0x8
0C7F  0022     MOVLB 0x2
0C80  0766     ADDWF Uout_mV, W
0C81  00F2     MOVWF 0x172
0C82  30EE     MOVLW 0xEE
0C83  3D67     ADDWFC 0x167, W
0C84  00F3     MOVWF 0x173
0C85  30FF     MOVLW 0xFF
0C86  3D68     ADDWFC 0x168, W
0C87  00F4     MOVWF 0x174
0C88  30FF     MOVLW 0xFF
0C89  3D69     ADDWFC dwBaud, W
0C8A  00F5     MOVWF 0x175
0C8B  3000     MOVLW 0x0
0C8C  00F9     MOVWF 0x179
0C8D  3000     MOVLW 0x0
0C8E  00F8     MOVWF 0x178
0C8F  3000     MOVLW 0x0
0C90  00F7     MOVWF 0x177
0C91  305D     MOVLW 0x5D
0C92  00F6     MOVWF 0x176
0C93  3193     MOVLP 0x13
0C94  23A5     CALL 0x3A5
0C95  318C     MOVLP 0xC
0C96  0875     MOVF 0x175, W
0C97  0021     MOVLB 0x1
0C98  00EB     MOVWF str
0C99  0874     MOVF 0xF4, W
0C9A  00EA     MOVWF strIncremet
0C9B  0873     MOVF 0xF3, W
0C9C  00E9     MOVWF 0xE9
0C9D  0872     MOVF 0xF2, W
0C9E  00E8     MOVWF dividend
0C9F  3187     MOVLP 0x7
0CA0  2760     CALL 0x760
0CA1  318C     MOVLP 0xC
0CA2  0021     MOVLB 0x1
0CA3  0864     MOVF ep, W
0CA4  00ED     MOVWF ziffer
0CA5  086D     MOVF ziffer, W
0CA6  0023     MOVLB 0x3
0CA7  00C4     MOVWF PwmDutyCycleVoltageLimit
83:                    PWM2_LoadDutyValue(0);
0CA8  3000     MOVLW 0x0
0CA9  00F2     MOVWF 0x1F2
0CAA  00F3     MOVWF 0x1F3
0CAB  3192     MOVLP 0x12
0CAC  2243     CALL 0x243
84:                    PWM2CON = 0xC0; //active HIGH
0CAD  30C0     MOVLW 0xC0
0CAE  002C     MOVLB 0xC
0CAF  0096     MOVWF PWM2CON
85:                    APFCON = 0x00;
0CB0  0022     MOVLB 0x2
0CB1  019D     CLRF APFCON
86:                    RA5_SetLow();//enable power output
0CB2  128C     BCF LATA, 0x5
87:                }
88:            }
89:            
90:            void main_CDC_to_RS485_Initialize()
91:            {   
92:                unsigned char i;
93:                
94:                line_coding2.bCharFormat = 0;
137F  0024     MOVLB 0x4
1380  01E2     CLRF 0x262
95:                line_coding2.bDataBits = 8;
1381  3008     MOVLW 0x8
1382  00F2     MOVWF 0x272
1383  0872     MOVF 0x272, W
1384  00E4     MOVWF 0x264
96:                line_coding2.bParityType = 0;
1385  01E3     CLRF 0x263
97:                line_coding2.dwDTERate = 9600;
1386  3000     MOVLW 0x0
1387  00E1     MOVWF 0x261
1388  3000     MOVLW 0x0
1389  00E0     MOVWF 0x260
138A  3025     MOVLW 0x25
138B  00DF     MOVWF 0x25F
138C  3080     MOVLW 0x80
138D  00DE     MOVWF line_coding2
98:            
99:            // 	 Initialize the arrays
100:           	for (i=0; i<sizeof(USB_Out_Buffer); i++)
138E  01F3     CLRF 0x273
138F  3040     MOVLW 0x40
1390  0273     SUBWF 0x273, W
1391  1803     BTFSC 0x203, 0x0
1392  2BA1     GOTO 0x3A1
1399  3001     MOVLW 0x1
139A  00F2     MOVWF 0x272
139B  0872     MOVF 0x272, W
139C  07F3     ADDWF 0x273, F
139D  3040     MOVLW 0x40
139E  0273     SUBWF 0x273, W
139F  1C03     BTFSS 0x203, 0x0
13A0  2B93     GOTO 0x393
101:               {
102:           		USB_Out_Buffer[i] = 0;
1393  0873     MOVF 0x273, W
1394  3E20     ADDLW 0x20
1395  0086     MOVWF 0x206
1396  3004     MOVLW 0x4
1397  0087     MOVWF 0x207
1398  0181     CLRF 0x201
103:               }
104:           
105:           	NextUSBOut = 0;
13A1  0023     MOVLB 0x3
13A2  01C3     CLRF NextUSBOut
106:           	LastRS232Out = 0;
13A3  01C1     CLRF LastRS232Out
107:           }
13A4  0008     RETURN
108:           
109:           #define mDataRdyUSART()         PIR1bits.RCIF
110:           #define mTxRdyUSART()           TXSTAbits.TRMT
111:           
112:           void main_CDC_to_RS485_Tasks()
113:           {
114:               /* If the USB device isn't configured yet, we can't really do anything
115:                * else since we don't have a host to talk to.  So jump back to the
116:                * top of the while loop. */
117:               if( USBGetDeviceState() < CONFIGURED_STATE )
118:               {
119:                   return;
120:               }
121:           
122:               /* If we are currently suspended, then we need to see if we need to
123:                * issue a remote wakeup.  In either case, we shouldn't process any
124:                * keyboard commands since we aren't currently communicating to the host
125:                * thus just continue back to the start of the while loop. */
126:               if( USBIsDeviceSuspended()== true )
127:               {
128:                   return;
129:               }
130:           
131:           //    /* Check to see if there is a transmission in progress, if there isn't, then
132:           //     * we can see about performing an echo response to data received.
133:           //     */
134:           //    if( USBUSARTIsTxTrfReady2() == true)
135:           //    {
136:           //        uint8_t i;
137:           //        uint8_t numBytesRead;
138:           //
139:           //        numBytesRead = getsUSBUSART2(readBufferRS485, sizeof(readBufferRS485));
140:           //
141:           //        //for test only!!!!
142:           //        if(numBytesRead > 0)
143:           //        {
144:           //            memcpy(writeBufferRS485,readBufferRS485, numBytesRead);
145:           //            /* send out the "echo" data now.
146:           //             */
147:           //            putUSBUSART2(writeBufferRS485,numBytesRead);
148:           //        }
149:           //    }
150:           
151:               if (RS232_Out_Data_Rdy == 0)  // only check for new USB buffer if the old RS232 buffer is
152:           	{						      // empty.  This will cause additional USB packets to be NAK'd
153:           		LastRS232Out = getsUSBUSART2(RS232_Out_Data,64); //until the buffer is free.
154:           		if(LastRS232Out > 0)
155:           		{
156:           			RS232_Out_Data_Rdy = 1;  // signal buffer full
157:           			RS232cp = 0;  // Reset the current position
158:                       IO_RC1_SetHigh(); //Set TXE signal for RS485
159:           		} else {
160:                       if(mTxRdyUSART()) IO_RC1_SetLow(); //Reset TXE signal for RS485
161:                   }
162:           	}
163:           
164:               
165:               //Check if one or more bytes are waiting in the physical UART transmit
166:               //queue.  If so, send it out the UART TX pin.
167:           	if(RS232_Out_Data_Rdy && mTxRdyUSART())
168:           	{
169:           	        //Hardware flow control not being used.  Just send the data.
170:               		USART_putcUSART(RS232_Out_Data[RS232cp]);
171:               		++RS232cp;
172:               		if (RS232cp == LastRS232Out) {
173:                           RS232_Out_Data_Rdy = 0;
174:                       }
175:           	}
176:           
177:               //Check if we received a character over the physical UART, and we need
178:               //to buffer it up for eventual transmission to the USB host.
179:           	if(mDataRdyUSART() && (NextUSBOut < (CDC_DATA_OUT_EP_SIZE - 1)))
180:                   {
181:           		USB_Out_Buffer[NextUSBOut] = USART_getcUSART();
182:           		++NextUSBOut;
183:           		USB_Out_Buffer[NextUSBOut] = 0;
184:           	}
185:           
186:               //Check if any bytes are waiting in the queue to send to the USB host.
187:               //If any bytes are waiting, and the endpoint is available, prepare to
188:               //send the USB packet to the host.
189:           	if((USBUSARTIsTxTrfReady2()) && (NextUSBOut > 0))
190:           	{
191:           		putUSBUSART2(&USB_Out_Buffer[0], NextUSBOut);
192:           		NextUSBOut = 0;
193:           	}
194:               
195:               CDCTxService2();
196:           }
197:           
198:           
199:           void main_SetDcDcRegulator(int32_t * pU_mV, int32_t * pI_mA)
0539  0021     MOVLB 0x1
053A  00EF     MOVWF lastDTS
200:           {
201:               //limit voltage
202:               if((*pU_mV) > MAX_UOUT_mV) (*pU_mV) = MAX_UOUT_mV;
053B  086F     MOVF lastDTS, W
053C  0086     MOVWF 0x86
053D  3001     MOVLW 0x1
053E  0087     MOVWF 0x87
053F  3F43     MOVIW [3]FSR1
0540  1B89     BTFSC 0x89, 0x7
0541  2D60     GOTO 0x560
0542  3F43     MOVIW [3]FSR1
0543  1D03     BTFSS 0x83, 0x2
0544  2D53     GOTO 0x553
0545  3F42     MOVIW [2]FSR1
0546  1D03     BTFSS 0x83, 0x2
0547  2D53     GOTO 0x553
0548  3F40     MOVIW [0]FSR1
0549  0022     MOVLB 0x2
054A  00EA     MOVWF 0x16A
054B  3099     MOVLW 0x99
054C  026A     SUBWF 0x16A, W
054D  3F41     MOVIW [1]FSR1
054E  00EA     MOVWF 0x16A
054F  303A     MOVLW 0x3A
0550  3B6A     SUBWFB 0x16A, W
0551  1C03     BTFSS 0x103, 0x0
0552  2D60     GOTO 0x560
0553  0021     MOVLB 0x1
0554  086F     MOVF lastDTS, W
0555  0086     MOVWF 0x86
0556  3001     MOVLW 0x1
0557  0087     MOVWF 0x87
0558  3098     MOVLW 0x98
0559  3FC0     MOVWI [0]FSR1
055A  303A     MOVLW 0x3A
055B  3FC1     MOVWI [1]FSR1
055C  3000     MOVLW 0x0
055D  3FC2     MOVWI [2]FSR1
055E  3000     MOVLW 0x0
055F  3FC3     MOVWI [3]FSR1
203:               if((*pU_mV) < MIN_UOUT_mV) (*pU_mV) = MIN_UOUT_mV;
0560  0021     MOVLB 0x1
0561  086F     MOVF lastDTS, W
0562  0086     MOVWF 0x86
0563  3001     MOVLW 0x1
0564  0087     MOVWF 0x87
0565  3F40     MOVIW [0]FSR1
0566  0022     MOVLB 0x2
0567  00EA     MOVWF 0x16A
0568  3F41     MOVIW [1]FSR1
0569  00EB     MOVWF 0x16B
056A  3F42     MOVIW [2]FSR1
056B  00EC     MOVWF 0x16C
056C  3F43     MOVIW [3]FSR1
056D  00ED     MOVWF i
056E  1FED     BTFSS i, 0x7
056F  2D7A     GOTO 0x57A
0570  0021     MOVLB 0x1
0571  086F     MOVF lastDTS, W
0572  0086     MOVWF 0x86
0573  3001     MOVLW 0x1
0574  0087     MOVWF 0x87
0575  3000     MOVLW 0x0
0576  3FC0     MOVWI [0]FSR1
0577  3FC1     MOVWI [1]FSR1
0578  3FC2     MOVWI [2]FSR1
0579  3FC3     MOVWI [3]FSR1
204:               //limit current
205:               if((*pI_mA) > MAX_IOUT_mA) (*pI_mA) = MAX_IOUT_mA;
057A  0021     MOVLB 0x1
057B  086E     MOVF pI_mA, W
057C  0086     MOVWF 0x86
057D  3002     MOVLW 0x2
057E  0087     MOVWF 0x87
057F  3F43     MOVIW [3]FSR1
0580  1B89     BTFSC 0x89, 0x7
0581  2DA0     GOTO 0x5A0
0582  3F43     MOVIW [3]FSR1
0583  1D03     BTFSS 0x83, 0x2
0584  2D93     GOTO 0x593
0585  3F42     MOVIW [2]FSR1
0586  1D03     BTFSS 0x83, 0x2
0587  2D93     GOTO 0x593
0588  3F40     MOVIW [0]FSR1
0589  0022     MOVLB 0x2
058A  00EA     MOVWF 0x16A
058B  30E9     MOVLW 0xE9
058C  026A     SUBWF 0x16A, W
058D  3F41     MOVIW [1]FSR1
058E  00EA     MOVWF 0x16A
058F  3003     MOVLW 0x3
0590  3B6A     SUBWFB 0x16A, W
0591  1C03     BTFSS 0x103, 0x0
0592  2DA0     GOTO 0x5A0
0593  0021     MOVLB 0x1
0594  086E     MOVF pI_mA, W
0595  0086     MOVWF 0x86
0596  3002     MOVLW 0x2
0597  0087     MOVWF 0x87
0598  30E8     MOVLW 0xE8
0599  3FC0     MOVWI [0]FSR1
059A  3003     MOVLW 0x3
059B  3FC1     MOVWI [1]FSR1
059C  3000     MOVLW 0x0
059D  3FC2     MOVWI [2]FSR1
059E  3000     MOVLW 0x0
059F  3FC3     MOVWI [3]FSR1
206:               if((*pI_mA) < MIN_IOUT_mA) (*pI_mA) = MIN_IOUT_mA;
05A0  0021     MOVLB 0x1
05A1  086E     MOVF pI_mA, W
05A2  0086     MOVWF 0x86
05A3  3002     MOVLW 0x2
05A4  0087     MOVWF 0x87
05A5  3F40     MOVIW [0]FSR1
05A6  0022     MOVLB 0x2
05A7  00EA     MOVWF 0x16A
05A8  3F41     MOVIW [1]FSR1
05A9  00EB     MOVWF 0x16B
05AA  3F42     MOVIW [2]FSR1
05AB  00EC     MOVWF 0x16C
05AC  3F43     MOVIW [3]FSR1
05AD  00ED     MOVWF i
05AE  1FED     BTFSS i, 0x7
05AF  2DBA     GOTO 0x5BA
05B0  0021     MOVLB 0x1
05B1  086E     MOVF pI_mA, W
05B2  0086     MOVWF 0x86
05B3  3002     MOVLW 0x2
05B4  0087     MOVWF 0x87
05B5  3000     MOVLW 0x0
05B6  3FC0     MOVWI [0]FSR1
05B7  3FC1     MOVWI [1]FSR1
05B8  3FC2     MOVWI [2]FSR1
05B9  3FC3     MOVWI [3]FSR1
207:               
208:               //limit DC-DC power due to USB limitations
209:               if(((*pU_mV)*(*pI_mA)) > MAX_POWER_mWt) {
05BA  0021     MOVLB 0x1
05BB  086F     MOVF lastDTS, W
05BC  0086     MOVWF 0x86
05BD  3001     MOVLW 0x1
05BE  0087     MOVWF 0x87
05BF  3F40     MOVIW [0]FSR1
05C0  00F2     MOVWF 0xF2
05C1  3F41     MOVIW [1]FSR1
05C2  00F3     MOVWF 0xF3
05C3  3F42     MOVIW [2]FSR1
05C4  00F4     MOVWF 0xF4
05C5  3F43     MOVIW [3]FSR1
05C6  00F5     MOVWF 0xF5
05C7  086E     MOVF pI_mA, W
05C8  0086     MOVWF 0x86
05C9  3002     MOVLW 0x2
05CA  0087     MOVWF 0x87
05CB  3F40     MOVIW [0]FSR1
05CC  00F6     MOVWF 0xF6
05CD  3F41     MOVIW [1]FSR1
05CE  00F7     MOVWF 0xF7
05CF  3F42     MOVIW [2]FSR1
05D0  00F8     MOVWF 0xF8
05D1  3F43     MOVIW [3]FSR1
05D2  00F9     MOVWF 0xF9
05D3  3193     MOVLP 0x13
05D4  23A5     CALL 0x3A5
05D5  3185     MOVLP 0x5
05D6  0875     MOVF 0xF5, W
05D7  1D03     BTFSS 0x83, 0x2
05D8  2DE1     GOTO 0x5E1
05D9  3001     MOVLW 0x1
05DA  0272     SUBWF 0xF2, W
05DB  309F     MOVLW 0x9F
05DC  3B73     SUBWFB 0xF3, W
05DD  3024     MOVLW 0x24
05DE  3B74     SUBWFB 0xF4, W
05DF  1C03     BTFSS 0x83, 0x0
05E0  2E06     GOTO 0x606
210:                   *pI_mA = MAX_POWER_mWt/(*pU_mV);
05E1  0021     MOVLB 0x1
05E2  086F     MOVF lastDTS, W
05E3  0086     MOVWF 0x86
05E4  3001     MOVLW 0x1
05E5  0087     MOVWF 0x87
05E6  3F40     MOVIW [0]FSR1
05E7  00E4     MOVWF ep
05E8  3F41     MOVIW [1]FSR1
05E9  00E5     MOVWF byte_to_send
05EA  3F42     MOVIW [2]FSR1
05EB  00E6     MOVWF buffer
05EC  3F43     MOVIW [3]FSR1
05ED  00E7     MOVWF 0xE7
05EE  3000     MOVLW 0x0
05EF  00EB     MOVWF str
05F0  3024     MOVLW 0x24
05F1  00EA     MOVWF strIncremet
05F2  309F     MOVLW 0x9F
05F3  00E9     MOVWF 0xE9
05F4  3000     MOVLW 0x0
05F5  00E8     MOVWF dividend
05F6  3188     MOVLP 0x8
05F7  2070     CALL 0x70
05F8  3185     MOVLP 0x5
05F9  0021     MOVLB 0x1
05FA  086E     MOVF pI_mA, W
05FB  0086     MOVWF 0x86
05FC  3002     MOVLW 0x2
05FD  0087     MOVWF 0x87
05FE  0864     MOVF ep, W
05FF  3FC0     MOVWI [0]FSR1
0600  0865     MOVF byte_to_send, W
0601  3FC1     MOVWI [1]FSR1
0602  0866     MOVF buffer, W
0603  3FC2     MOVWI [2]FSR1
0604  0867     MOVF 0xE7, W
0605  3FC3     MOVWI [3]FSR1
211:               }
212:               
213:               //adjust dc-dc regulation limits
214:               //switch between step Up/Down modes
215:               INTERRUPT_PeripheralInterruptDisable();
0606  130B     BCF 0x8B, 0x6
216:               main_switchStepUp_Down(*pU_mV);
0607  0021     MOVLB 0x1
0608  086F     MOVF lastDTS, W
0609  0086     MOVWF 0x86
060A  3001     MOVLW 0x1
060B  0087     MOVWF 0x87
060C  3F40     MOVIW [0]FSR1
060D  0022     MOVLB 0x2
060E  00E6     MOVWF Uout_mV
060F  3F41     MOVIW [1]FSR1
0610  00E7     MOVWF 0x167
0611  3F42     MOVIW [2]FSR1
0612  00E8     MOVWF 0x168
0613  3F43     MOVIW [3]FSR1
0614  00E9     MOVWF dwBaud
0615  318C     MOVLP 0xC
0616  2423     CALL 0x423
0617  3185     MOVLP 0x5
217:               Iadc_limit = (*pI_mA)/10;
0618  3000     MOVLW 0x0
0619  0021     MOVLB 0x1
061A  00E7     MOVWF 0xE7
061B  3000     MOVLW 0x0
061C  00E6     MOVWF buffer
061D  3000     MOVLW 0x0
061E  00E5     MOVWF byte_to_send
061F  300A     MOVLW 0xA
0620  00E4     MOVWF ep
0621  086E     MOVF pI_mA, W
0622  0086     MOVWF 0x86
0623  3002     MOVLW 0x2
0624  0087     MOVWF 0x87
0625  3F40     MOVIW [0]FSR1
0626  00E8     MOVWF dividend
0627  3F41     MOVIW [1]FSR1
0628  00E9     MOVWF 0xE9
0629  3F42     MOVIW [2]FSR1
062A  00EA     MOVWF strIncremet
062B  3F43     MOVIW [3]FSR1
062C  00EB     MOVWF str
062D  3187     MOVLP 0x7
062E  2760     CALL 0x760
062F  3185     MOVLP 0x5
0630  0021     MOVLB 0x1
0631  0865     MOVF byte_to_send, W
0632  0024     MOVLB 0x4
0633  00C3     MOVWF 0x243
0634  0021     MOVLB 0x1
0635  0864     MOVF ep, W
0636  0024     MOVLB 0x4
0637  00C2     MOVWF Iadc_limit
218:               Uadc_target = (100*(*pU_mV))/1761;//17.61v per 1024steps
0638  3000     MOVLW 0x0
0639  0021     MOVLB 0x1
063A  00E7     MOVWF 0xE7
063B  3000     MOVLW 0x0
063C  00E6     MOVWF buffer
063D  3006     MOVLW 0x6
063E  00E5     MOVWF byte_to_send
063F  30E1     MOVLW 0xE1
0640  00E4     MOVWF ep
0641  086F     MOVF lastDTS, W
0642  0086     MOVWF 0x86
0643  3001     MOVLW 0x1
0644  0087     MOVWF 0x87
0645  3F40     MOVIW [0]FSR1
0646  00F2     MOVWF 0xF2
0647  3F41     MOVIW [1]FSR1
0648  00F3     MOVWF 0xF3
0649  3F42     MOVIW [2]FSR1
064A  00F4     MOVWF 0xF4
064B  3F43     MOVIW [3]FSR1
064C  00F5     MOVWF 0xF5
064D  3000     MOVLW 0x0
064E  00F9     MOVWF 0xF9
064F  3000     MOVLW 0x0
0650  00F8     MOVWF 0xF8
0651  3000     MOVLW 0x0
0652  00F7     MOVWF 0xF7
0653  3064     MOVLW 0x64
0654  00F6     MOVWF 0xF6
0655  3193     MOVLP 0x13
0656  23A5     CALL 0x3A5
0657  3185     MOVLP 0x5
0658  0875     MOVF 0xF5, W
0659  0021     MOVLB 0x1
065A  00EB     MOVWF str
065B  0874     MOVF 0xF4, W
065C  00EA     MOVWF strIncremet
065D  0873     MOVF 0xF3, W
065E  00E9     MOVWF 0xE9
065F  0872     MOVF 0xF2, W
0660  00E8     MOVWF dividend
0661  3187     MOVLP 0x7
0662  2760     CALL 0x760
0663  0021     MOVLB 0x1
0664  0865     MOVF byte_to_send, W
0665  0024     MOVLB 0x4
0666  00CD     MOVWF 0x24D
0667  0021     MOVLB 0x1
0668  0864     MOVF ep, W
0669  0024     MOVLB 0x4
066A  00CC     MOVWF Uadc_target
219:               INTERRUPT_PeripheralInterruptEnable();
066B  170B     BSF 0x20B, 0x6
220:               MAIN_ovcFlag = 0;
066C  0023     MOVLB 0x3
066D  01C2     CLRF MAIN_ovcFlag
221:           }
066E  0008     RETURN
222:           
223:           //// Implementation of itoa()
224:           //void my_uitoa(char* str, uint16_t num)
225:           //{
226:           //    uint16_t dividerArray[5] = {10000,1000,100,10,1}; //we have up to 65535 input number
227:           //    uint8_t i=0;
228:           //
229:           //    for(i=0; i<5; i++) {
230:           //        if(num >= dividerArray[i]) {
231:           //            //do uint16 to string conversation
232:           //            for(; i<5; i++) {
233:           //                *str = '0' + (num / dividerArray[i]);
234:           //                num %= dividerArray[i];
235:           //                str++;
236:           //            }
237:           //            return;
238:           //        }
239:           //    }
240:           //    *str = '0';
241:           //}
242:           
243:           // Implementation of itoa()
244:           const uint16_t dividerArray[5][9] = { 
245:               {1,2,3,4,5,6,7,8,9},
246:               {10,20,30,40,50,60,70,80,90},
247:               {100,200,300,400,500,600,700,800,900},
248:               {1000,2000,3000,4000,5000,6000,7000,8000,9000},
249:               {10000,20000,30000,40000,50000,60000,0,0,0} }; //we have up to 65535 input number
250:               
251:           void my_uitoa(char* str, uint16_t num)
0D46  0021     MOVLB 0x1
0D47  00EB     MOVWF str
252:           {
253:               int8_t powerOfTen, ziffer = 5;
0D48  3005     MOVLW 0x5
0D49  00E0     MOVWF __pcstackBANK1
0D4A  0860     MOVF __pcstackBANK1, W
0D4B  00ED     MOVWF ziffer
254:               uint8_t strIncremet = 0;
0D4C  01EA     CLRF strIncremet
255:           
256:               for(powerOfTen=4; powerOfTen>=0; powerOfTen--) {
0D4D  3004     MOVLW 0x4
0D4E  00E0     MOVWF __pcstackBANK1
0D4F  0860     MOVF __pcstackBANK1, W
0D50  00EC     MOVWF powerOfTen
0D51  1BEC     BTFSC powerOfTen, 0x7
0D52  0008     RETURN
0DD3  30FF     MOVLW 0xFF
257:                   *str = '0';
0D53  3030     MOVLW 0x30
0D54  00E0     MOVWF __pcstackBANK1
0D55  086B     MOVF str, W
0D56  0086     MOVWF 0x86
0D57  3003     MOVLW 0x3
0D58  0087     MOVWF 0x87
0D59  0860     MOVF __pcstackBANK1, W
0D5A  0081     MOVWF 0x81
258:                   for(; ziffer>=0; ziffer--) {            
0D5B  1BED     BTFSC ziffer, 0x7
0D5C  2DCB     GOTO 0x5CB
0DC5  30FF     MOVLW 0xFF
0DC6  00E0     MOVWF __pcstackBANK1
0DC7  0860     MOVF __pcstackBANK1, W
0DC8  07ED     ADDWF ziffer, F
0DC9  1FED     BTFSS ziffer, 0x7
0DCA  2D5D     GOTO 0x55D
259:                       if(num > dividerArray[powerOfTen][ziffer]) {
0D5D  086D     MOVF ziffer, W
0D5E  00E0     MOVWF __pcstackBANK1
0D5F  01E1     CLRF handle
0D60  35E0     LSLF __pcstackBANK1, F
0D61  0DE1     RLF handle, F
0D62  086C     MOVF powerOfTen, W
0D63  00E2     MOVWF p
0D64  01E3     CLRF len
0D65  0862     MOVF p, W
0D66  00F2     MOVWF 0xF2
0D67  0863     MOVF len, W
0D68  00F3     MOVWF 0xF3
0D69  3012     MOVLW 0x12
0D6A  00F4     MOVWF 0xF4
0D6B  3000     MOVLW 0x0
0D6C  00F5     MOVWF 0xF5
0D6D  3192     MOVLP 0x12
0D6E  22BC     CALL 0x2BC
0D6F  318D     MOVLP 0xD
0D70  3098     MOVLW 0x98
0D71  0021     MOVLB 0x1
0D72  00E4     MOVWF ep
0D73  3080     MOVLW 0x80
0D74  00E5     MOVWF byte_to_send
0D75  0872     MOVF 0xF2, W
0D76  0764     ADDWF ep, W
0D77  00E6     MOVWF buffer
0D78  0873     MOVF 0xF3, W
0D79  3D65     ADDWFC byte_to_send, W
0D7A  00E7     MOVWF 0xE7
0D7B  0866     MOVF buffer, W
0D7C  0760     ADDWF __pcstackBANK1, W
0D7D  0084     MOVWF 0x84
0D7E  0867     MOVF 0xE7, W
0D7F  3D61     ADDWFC handle, W
0D80  0085     MOVWF 0x85
0D81  3F00     MOVIW [0]FSR0
0D82  00E8     MOVWF dividend
0D83  3F01     MOVIW [1]FSR0
0D84  00E9     MOVWF 0xE9
0D85  0879     MOVF 0xF9, W
0D86  0269     SUBWF 0xE9, W
0D87  1D03     BTFSS 0x83, 0x2
0D88  2D8B     GOTO 0x58B
0D89  0878     MOVF 0xF8, W
0D8A  0268     SUBWF dividend, W
0D8B  1803     BTFSC 0x83, 0x0
0D8C  2DC5     GOTO 0x5C5
260:                           strIncremet = 1;
0D8D  01EA     CLRF strIncremet
0D8E  0AEA     INCF strIncremet, F
261:                           *str += ziffer+1;
0D8F  086D     MOVF ziffer, W
0D90  3E01     ADDLW 0x1
0D91  00E0     MOVWF __pcstackBANK1
0D92  086B     MOVF str, W
0D93  0086     MOVWF 0x86
0D94  3003     MOVLW 0x3
0D95  0087     MOVWF 0x87
0D96  0860     MOVF __pcstackBANK1, W
0D97  0781     ADDWF 0x81, F
262:                           num -= dividerArray[powerOfTen][ziffer];
0D98  086D     MOVF ziffer, W
0D99  00E0     MOVWF __pcstackBANK1
0D9A  01E1     CLRF handle
0D9B  35E0     LSLF __pcstackBANK1, F
0D9C  0DE1     RLF handle, F
0D9D  086C     MOVF powerOfTen, W
0D9E  00E2     MOVWF p
0D9F  01E3     CLRF len
0DA0  0862     MOVF p, W
0DA1  00F2     MOVWF 0xF2
0DA2  0863     MOVF len, W
0DA3  00F3     MOVWF 0xF3
0DA4  3012     MOVLW 0x12
0DA5  00F4     MOVWF 0xF4
0DA6  3000     MOVLW 0x0
0DA7  00F5     MOVWF 0xF5
0DA8  3192     MOVLP 0x12
0DA9  22BC     CALL 0x2BC
0DAA  318D     MOVLP 0xD
0DAB  3098     MOVLW 0x98
0DAC  0021     MOVLB 0x1
0DAD  00E4     MOVWF ep
0DAE  3080     MOVLW 0x80
0DAF  00E5     MOVWF byte_to_send
0DB0  0872     MOVF 0xF2, W
0DB1  0764     ADDWF ep, W
0DB2  00E6     MOVWF buffer
0DB3  0873     MOVF 0xF3, W
0DB4  3D65     ADDWFC byte_to_send, W
0DB5  00E7     MOVWF 0xE7
0DB6  0866     MOVF buffer, W
0DB7  0760     ADDWF __pcstackBANK1, W
0DB8  0084     MOVWF 0x84
0DB9  0867     MOVF 0xE7, W
0DBA  3D61     ADDWFC handle, W
0DBB  0085     MOVWF 0x85
0DBC  3F00     MOVIW [0]FSR0
0DBD  00E8     MOVWF dividend
0DBE  3F01     MOVIW [1]FSR0
0DBF  00E9     MOVWF 0xE9
0DC0  0868     MOVF dividend, W
0DC1  02F8     SUBWF 0xF8, F
0DC2  0869     MOVF 0xE9, W
0DC3  3BF9     SUBWFB 0xF9, F
263:                           break;
0DC4  2DCB     GOTO 0x5CB
264:                       }
265:                   }
266:                   ziffer=8;
0DCB  3008     MOVLW 0x8
0DCC  00E0     MOVWF __pcstackBANK1
0DCD  0860     MOVF __pcstackBANK1, W
0DCE  00ED     MOVWF ziffer
267:                   str+=strIncremet;
0DCF  086A     MOVF strIncremet, W
0DD0  00E0     MOVWF __pcstackBANK1
0DD1  0860     MOVF __pcstackBANK1, W
0DD2  07EB     ADDWF str, F
268:               }
269:               
270:           }
271:           
272:           void main_Communication_Initialize(void)
273:           {
274:               unsigned char i;
275:               
276:               line_coding.bCharFormat = 0;
1336  0024     MOVLB 0x4
1337  01DB     CLRF 0x25B
277:               line_coding.bDataBits = 8;
1338  3008     MOVLW 0x8
1339  00F2     MOVWF 0x272
133A  0872     MOVF 0x272, W
133B  00DD     MOVWF 0x25D
278:               line_coding.bParityType = 0;
133C  01DC     CLRF 0x25C
279:               line_coding.dwDTERate = 9600;
133D  3000     MOVLW 0x0
133E  00DA     MOVWF 0x25A
133F  3000     MOVLW 0x0
1340  00D9     MOVWF 0x259
1341  3025     MOVLW 0x25
1342  00D8     MOVWF 0x258
1343  3080     MOVLW 0x80
1344  00D7     MOVWF line_coding
280:           
281:               // clear the TMR1 interrupt flag
282:               TMR1IF = 0;
1345  0020     MOVLB 0x0
1346  1011     BCF PIR1, 0x0
283:               // Reload the initial value of TMR1
284:               TMR1_Reload();
1347  3191     MOVLP 0x11
1348  21F0     CALL 0x1F0
1349  3193     MOVLP 0x13
285:               
286:               // 	 Initialize the arrays
287:           	for (i=0; i<sizeof(writeBuffer); i++)
134A  01F3     CLRF p
134B  3040     MOVLW 0x40
134C  0273     SUBWF p, W
134D  1803     BTFSC STATUS, 0x0
134E  0008     RETURN
1355  3001     MOVLW 0x1
288:               {
289:           		writeBuffer[i] = 0;
134F  0873     MOVF p, W
1350  3EA0     ADDLW 0xA0
1351  0086     MOVWF FSR1
1352  3004     MOVLW 0x4
1353  0087     MOVWF FSR1H
1354  0181     CLRF INDF1
290:               }    
291:           }
292:           
293:           void main_CommunicationHandler()
294:           {
295:               static uint8_t step = 0;
296:               /* If the USB device isn't configured yet, we can't really do anything
297:                * else since we don't have a host to talk to.  So jump back to the
298:                * top of the while loop. */
299:               if( USBGetDeviceState() < CONFIGURED_STATE )
028A  3020     MOVLW 0x20
028B  0023     MOVLB 0x3
028C  024C     SUBWF USBDeviceState, W
028D  1C03     BTFSS 0x183, 0x0
028E  0008     RETURN
300:               {
301:                   return;
302:               }
303:           
304:               /* If we are currently suspended, then we need to see if we need to
305:                * issue a remote wakeup.  In either case, we shouldn't process any
306:                * keyboard commands since we aren't currently communicating to the host
307:                * thus just continue back to the start of the while loop. */
308:               if( USBIsDeviceSuspended()== true )
028F  003D     MOVLB 0x1D
0290  188E     BTFSC UCON, 0x1
0291  0008     RETURN
309:               {
310:                   return;
311:               }
312:           
313:               /* Check to see if there is a transmission in progress, if there isn't, then
314:                * we can see about performing an echo response to data received.
315:                */
316:               if( USBUSARTIsTxTrfReady() == true)
0292  0023     MOVLB 0x3
0293  0855     MOVF cdc_trf_state, W
0294  1D03     BTFSS 0x183, 0x2
0295  2BE3     GOTO 0x3E3
317:               {
318:                   uint8_t i;
319:                   uint8_t numBytesRead;
320:           
321:                   numBytesRead = getsUSBUSART(readBuffer, sizeof(readBuffer));
0296  3040     MOVLW 0x40
0297  0022     MOVLB 0x2
0298  00EE     MOVWF byteToRead
0299  086E     MOVF byteToRead, W
029A  0021     MOVLB 0x1
029B  00E3     MOVWF len
029C  3020     MOVLW 0x20
029D  3196     MOVLP 0x16
029E  2639     CALL 0x639
029F  3182     MOVLP 0x2
02A0  0022     MOVLB 0x2
02A1  00EF     MOVWF i
02A2  086F     MOVF i, W
02A3  0023     MOVLB 0x3
02A4  00E9     MOVWF __pcstackBANK3
322:           
323:                   if(numBytesRead) {
02A5  0869     MOVF __pcstackBANK3, W
02A6  1903     BTFSC 0x183, 0x2
02A7  2B28     GOTO 0x328
324:                       /* For every byte that was read... */
325:                       for(i=0; i<numBytesRead; i++)
02A8  01EA     CLRF i
02A9  0869     MOVF __pcstackBANK3, W
02AA  026A     SUBWF i, W
02AB  1803     BTFSC 0x183, 0x0
02AC  2BE3     GOTO 0x3E3
0321  3001     MOVLW 0x1
0322  0022     MOVLB 0x2
0323  00EE     MOVWF byteToRead
0324  086E     MOVF byteToRead, W
0325  0023     MOVLB 0x3
0326  07EA     ADDWF i, F
0327  2AA9     GOTO 0x2A9
326:                       {
327:                           if((0x0A == readBuffer[i]) || (0x0D == readBuffer[i]))
02AD  086A     MOVF i, W
02AE  3E20     ADDLW 0x20
02AF  0086     MOVWF 0x186
02B0  3003     MOVLW 0x3
02B1  0087     MOVWF 0x187
02B2  300A     MOVLW 0xA
02B3  0601     XORWF 0x181, W
02B4  1903     BTFSC 0x183, 0x2
02B5  2ABF     GOTO 0x2BF
02B6  086A     MOVF i, W
02B7  3E20     ADDLW 0x20
02B8  0086     MOVWF 0x186
02B9  3003     MOVLW 0x3
02BA  0087     MOVWF 0x187
02BB  300D     MOVLW 0xD
02BC  0601     XORWF 0x181, W
02BD  1D03     BTFSS 0x183, 0x2
02BE  2B21     GOTO 0x321
328:                           {
329:                               //execute command here
330:                               if(('U' == readBuffer[0]) || ('u' == readBuffer[0])) {
02BF  3055     MOVLW 0x55
02C0  0026     MOVLB 0x6
02C1  0620     XORWF readBuffer, W
02C2  1903     BTFSC 0x303, 0x2
02C3  2AC8     GOTO 0x2C8
02C4  3075     MOVLW 0x75
02C5  0620     XORWF readBuffer, W
02C6  1D03     BTFSS 0x303, 0x2
02C7  2AD7     GOTO 0x2D7
331:                                   MAIN_Uout_target_mV = atoi(&readBuffer[1]);
02C8  3021     MOVLW 0x21
02C9  3189     MOVLP 0x9
02CA  21A7     CALL 0x1A7
02CB  3182     MOVLP 0x2
02CC  0878     MOVF 0x378, W
02CD  0023     MOVLB 0x3
02CE  00E1     MOVWF MAIN_Uout_target_mV
02CF  0879     MOVF 0x1F9, W
02D0  00E2     MOVWF 0x1E2
02D1  0D89     RLF 0x189, F
02D2  3B89     SUBWFB 0x189, F
02D3  0989     COMF 0x189, F
02D4  00E3     MOVWF 0x1E3
02D5  00E4     MOVWF 0x1E4
02D6  2AEE     GOTO 0x2EE
332:           //                        memcpy(writeBuffer,okMsg,sizeof(okMsg));
333:           //                        putUSBUSART(writeBuffer,sizeof(okMsg)-1);
334:                                   main_SetDcDcRegulator(&MAIN_Uout_target_mV, &MAIN_Iout_limit_mA);
335:                                   if(MAIN_Uout_target_mV) IO_RC0_SetHigh();
336:                                   else IO_RC0_SetLow();
337:                               } else if(('I' == readBuffer[0]) || ('i' == readBuffer[0])) {
02D7  3049     MOVLW 0x49
02D8  0026     MOVLB 0x6
02D9  0620     XORWF readBuffer, W
02DA  1903     BTFSC 0x303, 0x2
02DB  2AE0     GOTO 0x2E0
02DC  3069     MOVLW 0x69
02DD  0620     XORWF readBuffer, W
02DE  1D03     BTFSS 0x303, 0x2
02DF  2B05     GOTO 0x305
338:                                   MAIN_Iout_limit_mA = atoi(&readBuffer[1]);                        
02E0  3021     MOVLW 0x21
02E1  3189     MOVLP 0x9
02E2  21A7     CALL 0x1A7
02E3  3182     MOVLP 0x2
02E4  0878     MOVF 0x378, W
02E5  0024     MOVLB 0x4
02E6  00E7     MOVWF MAIN_Iout_limit_mA
02E7  0879     MOVF 0x279, W
02E8  00E8     MOVWF 0x268
02E9  0D89     RLF 0x209, F
02EA  3B89     SUBWFB 0x209, F
02EB  0989     COMF 0x209, F
02EC  00E9     MOVWF 0x269
02ED  00EA     MOVWF 0x26A
339:           //                        memcpy(writeBuffer,okMsg,sizeof(okMsg));
340:           //                        putUSBUSART(writeBuffer,sizeof(okMsg)-1);
341:                                   main_SetDcDcRegulator(&MAIN_Uout_target_mV, &MAIN_Iout_limit_mA);
02EE  3067     MOVLW 0x67
02EF  0022     MOVLB 0x2
02F0  00EE     MOVWF byteToRead
02F1  086E     MOVF byteToRead, W
02F2  0021     MOVLB 0x1
02F3  00EE     MOVWF pI_mA
02F4  30E1     MOVLW 0xE1
02F5  3185     MOVLP 0x5
02F6  2539     CALL 0x539
02F7  3182     MOVLP 0x2
342:                                   if(MAIN_Uout_target_mV) IO_RC0_SetHigh();
02F8  0023     MOVLB 0x3
02F9  0864     MOVF 0x1E4, W
02FA  0463     IORWF 0x1E3, W
02FB  0462     IORWF 0x1E2, W
02FC  0461     IORWF MAIN_Uout_target_mV, W
02FD  1903     BTFSC 0x183, 0x2
02FE  2B02     GOTO 0x302
02FF  0022     MOVLB 0x2
0300  140E     BSF LATC, 0x0
0301  2BE3     GOTO 0x3E3
343:                                   else IO_RC0_SetLow();
0302  0022     MOVLB 0x2
0303  100E     BCF LATC, 0x0
344:                               } else {
0304  2BE3     GOTO 0x3E3
345:                                   memcpy(writeBuffer,errorMsg,sizeof(errorMsg));
0305  30A0     MOVLW 0xA0
0306  0086     MOVWF 0x106
0307  3004     MOVLW 0x4
0308  0087     MOVWF 0x107
0309  3052     MOVLW 0x52
030A  0084     MOVWF 0x104
030B  3082     MOVLW 0x82
030C  0085     MOVWF 0x105
030D  300D     MOVLW 0xD
030E  0022     MOVLB 0x2
030F  00EE     MOVWF byteToRead
0310  0012     MOVIW FSR0++
0311  001E     MOVWI FSR1++
0312  0BEE     DECFSZ byteToRead, F
0313  2B10     GOTO 0x310
346:                                   putUSBUSART(writeBuffer,sizeof(errorMsg)-1);
0314  30A0     MOVLW 0xA0
0315  00F2     MOVWF 0x172
0316  3004     MOVLW 0x4
0317  00F3     MOVWF 0x173
0318  300C     MOVLW 0xC
0319  0022     MOVLB 0x2
031A  00EE     MOVWF byteToRead
031B  086E     MOVF byteToRead, W
031C  00F4     MOVWF 0x174
031D  3192     MOVLP 0x12
031E  221C     CALL 0x21C
031F  3182     MOVLP 0x2
347:                               }
348:                               break;
0320  2BE3     GOTO 0x3E3
349:                           }
350:                       }
351:                   } else if(TMR1IF) {
0328  0020     MOVLB 0x0
0329  1811     BTFSC PIR1, 0x0
032A  2BD4     GOTO 0x3D4
032B  2BE3     GOTO 0x3E3
352:                       switch (step){
03D4  0023     MOVLB 0x3
03D5  0860     MOVF step, W
03D6  3A00     XORLW 0x0
03D7  1903     BTFSC 0x183, 0x2
03D8  2B2C     GOTO 0x32C
03D9  3A01     XORLW 0x1
03DA  1903     BTFSC 0x183, 0x2
03DB  2B6C     GOTO 0x36C
03DC  3A03     XORLW 0x3
03DD  1903     BTFSC 0x183, 0x2
03DE  2B7E     GOTO 0x37E
03DF  3A01     XORLW 0x1
03E0  1903     BTFSC 0x183, 0x2
03E1  2B85     GOTO 0x385
03E2  2BB7     GOTO 0x3B7
353:                       case 0:
354:                           MAIN_Uout_mV = (1761*(uint32_t)Uadc)/100;
032C  3000     MOVLW 0x0
032D  0021     MOVLB 0x1
032E  00E7     MOVWF 0xE7
032F  3000     MOVLW 0x0
0330  00E6     MOVWF buffer
0331  3000     MOVLW 0x0
0332  00E5     MOVWF byte_to_send
0333  3064     MOVLW 0x64
0334  00E4     MOVWF ep
0335  0023     MOVLB 0x3
0336  0865     MOVF Uadc, W
0337  00F2     MOVWF 0x1F2
0338  0866     MOVF 0x1E6, W
0339  00F3     MOVWF 0x1F3
033A  01F4     CLRF 0x1F4
033B  01F5     CLRF 0x1F5
033C  3000     MOVLW 0x0
033D  00F9     MOVWF 0x1F9
033E  3000     MOVLW 0x0
033F  00F8     MOVWF 0x1F8
0340  3006     MOVLW 0x6
0341  00F7     MOVWF 0x1F7
0342  30E1     MOVLW 0xE1
0343  00F6     MOVWF 0x1F6
0344  3193     MOVLP 0x13
0345  23A5     CALL 0x3A5
0346  3182     MOVLP 0x2
0347  0875     MOVF 0x1F5, W
0348  0021     MOVLB 0x1
0349  00EB     MOVWF str
034A  0874     MOVF 0xF4, W
034B  00EA     MOVWF strIncremet
034C  0873     MOVF 0xF3, W
034D  00E9     MOVWF 0xE9
034E  0872     MOVF 0xF2, W
034F  00E8     MOVWF dividend
0350  3188     MOVLP 0x8
0351  2070     CALL 0x70
0352  3182     MOVLP 0x2
0353  0021     MOVLB 0x1
0354  0865     MOVF byte_to_send, W
0355  0024     MOVLB 0x4
0356  00C7     MOVWF 0x247
0357  0021     MOVLB 0x1
0358  0864     MOVF ep, W
0359  0024     MOVLB 0x4
035A  00C6     MOVWF MAIN_Uout_mV
355:                           MAIN_Iout_mA = Iadc*10;
035B  0841     MOVF 0x241, W
035C  00F3     MOVWF 0x273
035D  0840     MOVF Iadc, W
035E  00F2     MOVWF 0x272
035F  300A     MOVLW 0xA
0360  00F4     MOVWF 0x274
0361  3000     MOVLW 0x0
0362  00F5     MOVWF 0x275
0363  3192     MOVLP 0x12
0364  22BC     CALL 0x2BC
0365  3182     MOVLP 0x2
0366  0873     MOVF 0x273, W
0367  0024     MOVLB 0x4
0368  00C5     MOVWF 0x245
0369  0872     MOVF 0x272, W
036A  00C4     MOVWF MAIN_Iout_mA
036B  2B8E     GOTO 0x38E
356:                           step++;
357:                           break;
358:                       case 1:                    
359:                           writeStatusBuffer[0] = 0;
036C  0027     MOVLB 0x7
036D  01A0     CLRF writeStatusBuffer
360:                           memcpy(writeStatusBuffer,"EasyVolts \tU(mV)=      \t I(mA)=     \r\n", 38/*+5*/);
036E  30A0     MOVLW 0xA0
036F  0086     MOVWF 0x386
0370  3003     MOVLW 0x3
0371  0087     MOVWF 0x387
0372  3063     MOVLW 0x63
0373  0084     MOVWF 0x384
0374  3082     MOVLW 0x82
0375  0085     MOVWF 0x385
0376  3026     MOVLW 0x26
0377  0022     MOVLB 0x2
0378  00EE     MOVWF byteToRead
0379  0012     MOVIW FSR0++
037A  001E     MOVWI FSR1++
037B  0BEE     DECFSZ byteToRead, F
037C  2B79     GOTO 0x379
361:                           step++;
037D  2B8E     GOTO 0x38E
362:                           break;
363:                       case 2:                    
364:                           my_uitoa(&writeStatusBuffer[17],MAIN_Uout_mV);//voltage
037E  0024     MOVLB 0x4
037F  0847     MOVF 0x247, W
0380  00F9     MOVWF 0x279
0381  0846     MOVF MAIN_Uout_mV, W
0382  00F8     MOVWF 0x278
0383  30B1     MOVLW 0xB1
0384  2B8B     GOTO 0x38B
365:                           step++;
366:                           break;
367:                       case 3:
368:                           my_uitoa(&writeStatusBuffer[31],MAIN_Iout_mA);//current  
0385  0024     MOVLB 0x4
0386  0845     MOVF 0x245, W
0387  00F9     MOVWF 0x279
0388  0844     MOVF MAIN_Iout_mA, W
0389  00F8     MOVWF 0x278
038A  30BF     MOVLW 0xBF
038B  318D     MOVLP 0xD
038C  2546     CALL 0x546
038D  3182     MOVLP 0x2
369:           //                my_uitoa(&writeStatusBuffer[36],PwmDutyCycle);
370:                           step++;
038E  3001     MOVLW 0x1
038F  0022     MOVLB 0x2
0390  00EE     MOVWF byteToRead
0391  086E     MOVF byteToRead, W
0392  0023     MOVLB 0x3
0393  07E0     ADDWF step, F
371:                           break;
0394  2BE3     GOTO 0x3E3
372:                       default:
373:                           //handle led and special symbols
374:                           switch(MAIN_ovcFlag){
03B7  0023     MOVLB 0x3
03B8  0842     MOVF MAIN_ovcFlag, W
03B9  3A00     XORLW 0x0
03BA  1903     BTFSC 0x183, 0x2
03BB  2B95     GOTO 0x395
03BC  3A01     XORLW 0x1
03BD  1903     BTFSC 0x183, 0x2
03BE  2BA2     GOTO 0x3A2
03BF  2BAF     GOTO 0x3AF
375:                               case 0:
376:                                   if(0 == MAIN_Uout_target_mV) {
0395  0864     MOVF 0x1E4, W
0396  0463     IORWF 0x1E3, W
0397  0462     IORWF 0x1E2, W
0398  0461     IORWF MAIN_Uout_target_mV, W
0399  1D03     BTFSS 0x183, 0x2
039A  2B9F     GOTO 0x39F
377:                                       IO_RC0_SetLow();//switch off led and print "_" if output is OFF
039B  0022     MOVLB 0x2
039C  100E     BCF LATC, 0x0
378:                                       writeStatusBuffer[24] = '_';
039D  305F     MOVLW 0x5F
039E  2BB2     GOTO 0x3B2
379:                                   } else IO_RC0_SetHigh();
039F  0022     MOVLB 0x2
03A0  140E     BSF LATC, 0x0
380:                                   break;
03A1  2BC0     GOTO 0x3C0
381:                               case 1:
382:                                   IO_RC0_Toggle();//blink led and print "^" if overcurrent
03A2  1003     BCF 0x103, 0x0
03A3  0022     MOVLB 0x2
03A4  1C0E     BTFSS LATC, 0x0
03A5  1403     BSF 0x103, 0x0
03A6  1C03     BTFSS 0x103, 0x0
03A7  2BAB     GOTO 0x3AB
03A8  0022     MOVLB 0x2
03A9  140E     BSF LATC, 0x0
03AA  2BAD     GOTO 0x3AD
03AB  0022     MOVLB 0x2
03AC  100E     BCF LATC, 0x0
383:                                   writeStatusBuffer[24] = '^';
03AD  305E     MOVLW 0x5E
03AE  2BB2     GOTO 0x3B2
384:                                   break;
385:                               default:
386:                                   IO_RC0_SetLow();//switch off led and print "!" if overcurrent error
03AF  0022     MOVLB 0x2
03B0  100E     BCF LATC, 0x0
387:                                   writeStatusBuffer[24] = '!';
03B1  3021     MOVLW 0x21
03B2  00EE     MOVWF byteToRead
03B3  086E     MOVF byteToRead, W
03B4  0027     MOVLB 0x7
03B5  00B8     MOVWF 0x3B8
388:                                   break;
389:                           }
03B6  2BC0     GOTO 0x3C0
390:                           putUSBUSART(writeStatusBuffer,38/*+5*/);
03C0  30A0     MOVLW 0xA0
03C1  00F2     MOVWF 0x3F2
03C2  3003     MOVLW 0x3
03C3  00F3     MOVWF 0x3F3
03C4  3026     MOVLW 0x26
03C5  0022     MOVLB 0x2
03C6  00EE     MOVWF byteToRead
03C7  086E     MOVF byteToRead, W
03C8  00F4     MOVWF 0x174
03C9  3192     MOVLP 0x12
03CA  221C     CALL 0x21C
03CB  3182     MOVLP 0x2
391:                           // clear the TMR1 interrupt flag
392:                           TMR1IF = 0;
03CC  0020     MOVLB 0x0
03CD  1011     BCF PIR1, 0x0
393:                           // Reload the initial value of TMR1
394:                           TMR1_Reload();
03CE  3191     MOVLP 0x11
03CF  21F0     CALL 0x1F0
03D0  3182     MOVLP 0x2
395:                           step = 0;
03D1  0023     MOVLB 0x3
03D2  01E0     CLRF step
396:                           break;
397:                       }
03D3  2BE3     GOTO 0x3E3
398:                   }
399:               }
400:           
401:               CDCTxService();
03E3  318E     MOVLP 0xE
03E4  2686     CALL 0x686
402:           }
03E5  0008     RETURN
403:           
404:           /********************************************************************
405:            * Function:        void main(void)
406:            *
407:            * PreCondition:    None
408:            *
409:            * Input:           None
410:            *
411:            * Output:          None
412:            *
413:            * Side Effects:    None
414:            *
415:            * Overview:        Main program entry point.
416:            *
417:            * Note:            None
418:            *******************************************************************/
419:           MAIN_RETURN main(void)
420:           {
421:               uint8_t temp = 0;
14FF  0024     MOVLB 0x4
1500  01EC     CLRF temp
422:               SYSTEM_Initialize();
1501  3192     MOVLP 0x12
1502  22A1     CALL 0x2A1
1503  3194     MOVLP 0x14
423:               TMR1_StartTimer();
1504  3191     MOVLP 0x11
1505  21CF     CALL 0x1CF
1506  3194     MOVLP 0x14
424:           //    TMR0_Reload();
425:               INTERRUPT_GlobalInterruptEnable();
1507  178B     BSF 0x20B, 0x7
426:               INTERRUPT_PeripheralInterruptEnable();
1508  170B     BSF 0x20B, 0x6
427:               ADC_StartConversion();
1509  3191     MOVLP 0x11
150A  21CC     CALL 0x1CC
150B  3194     MOVLP 0x14
428:               
429:               USBDeviceInit();
150C  318D     MOVLP 0xD
150D  25D8     CALL 0x5D8
150E  3194     MOVLP 0x14
430:               USBDeviceAttach();
431:               
432:               main_SetDcDcRegulator(&MAIN_Uout_target_mV, &MAIN_Iout_limit_mA);
150F  3067     MOVLW 0x67
1510  0024     MOVLB 0x4
1511  00EB     MOVWF __pcstackBANK4
1512  086B     MOVF __pcstackBANK4, W
1513  0021     MOVLB 0x1
1514  00EE     MOVWF pI_mA
1515  30E1     MOVLW 0xE1
1516  3185     MOVLP 0x5
1517  2539     CALL 0x539
1518  3194     MOVLP 0x14
433:               
434:               while(1)
1541  2D19     GOTO 0x519
435:               {
436:                   SYSTEM_Tasks();
437:           //        #if defined(USB_POLLING)
438:           //            // Interrupt or polling method.  If using polling, must call
439:           //            // this function periodically.  This function will take care
440:           //            // of processing and responding to SETUP transactions
441:           //            // (such as during the enumeration process when you first
442:           //            // plug in).  USB hosts require that USB devices should accept
443:           //            // and process SETUP packets in a timely fashion.  Therefore,
444:           //            // when using polling, this function should be called
445:           //            // regularly (such as once every 1.8ms or faster** [see
446:           //            // inline code comments in usb_device.c for explanation when
447:           //            // "or faster" applies])  In most cases, the USBDeviceTasks()
448:           //            // function does not take very long to execute (ex: <100
449:           //            // instruction cycles) before it returns.
450:           //            USBDeviceTasks();
451:           //        #endif
452:                   //this is to increase output voltage slowly to prevent overcurrent of power source at startup
453:                   temp++;
1519  3001     MOVLW 0x1
151A  0024     MOVLB 0x4
151B  00EB     MOVWF __pcstackBANK4
151C  086B     MOVF __pcstackBANK4, W
151D  07EC     ADDWF temp, F
454:                   if(temp > 10) {
151E  300B     MOVLW 0xB
151F  026C     SUBWF temp, W
1520  1C03     BTFSS 0x203, 0x0
1521  2D2F     GOTO 0x52F
455:                       if(rampPwmDutyCycleVoltageLimit < PwmDutyCycleVoltageLimit) rampPwmDutyCycleVoltageLimit++;
1522  0023     MOVLB 0x3
1523  0844     MOVF PwmDutyCycleVoltageLimit, W
1524  025E     SUBWF rampPwmDutyCycleVoltageLimit, W
1525  1803     BTFSC 0x183, 0x0
1526  2D2D     GOTO 0x52D
1527  3001     MOVLW 0x1
1528  0024     MOVLB 0x4
1529  00EB     MOVWF __pcstackBANK4
152A  086B     MOVF __pcstackBANK4, W
152B  0023     MOVLB 0x3
152C  07DE     ADDWF rampPwmDutyCycleVoltageLimit, F
456:                       temp = 0;
152D  0024     MOVLB 0x4
152E  01EC     CLRF temp
457:                   }
458:                   if(rampPwmDutyCycleVoltageLimit > PwmDutyCycleVoltageLimit) rampPwmDutyCycleVoltageLimit = PwmDutyCycleVoltageLimit;
152F  0023     MOVLB 0x3
1530  085E     MOVF rampPwmDutyCycleVoltageLimit, W
1531  0244     SUBWF PwmDutyCycleVoltageLimit, W
1532  1803     BTFSC 0x183, 0x0
1533  2D3A     GOTO 0x53A
1534  0844     MOVF PwmDutyCycleVoltageLimit, W
1535  0024     MOVLB 0x4
1536  00EB     MOVWF __pcstackBANK4
1537  086B     MOVF __pcstackBANK4, W
1538  0023     MOVLB 0x3
1539  00DE     MOVWF rampPwmDutyCycleVoltageLimit
459:                   //Application specific tasks     
460:                   main_CommunicationHandler();
153A  3182     MOVLP 0x2
153B  228A     CALL 0x28A
153C  3194     MOVLP 0x14
461:                   USBDeviceTasks();
153D  3186     MOVLP 0x6
153E  266F     CALL 0x66F
153F  3194     MOVLP 0x14
462:                   CLRWDT();             
1540  0064     CLRWDT
463:               }//end while
464:           }//end main
465:           
466:           /*******************************************************************************
467:            End of File
468:           */
469:           
470:           void interrupt INTERRUPT_InterruptManager(void)
0004  147E     BSF 0x1FE, 0x0
0005  3180     MOVLP 0x0
0006  0020     MOVLB 0x0
0007  087F     MOVF 0x7F, W
0008  00F1     MOVWF 0x71
471:           {
472:               
473:           //    IO_RC0_SetHigh();
474:           //    static uint8_t i=0;
475:           //    
476:           //    if(i>5) {
477:           //        FVRCON = 0x82; //switch Vref for adc to 2.048v and start I measurement
478:           //        ADC_SelectChannel(channel_AN3);
479:           //        i=0;
480:           //        PWM2_LoadDutyValue(0);
481:           //        ADC_StartConversion();  
482:           //        main_CDC_to_RS485_Tasks();
483:           //        while(false == ADC_IsConversionDone());
484:           //        Iadc = ADC_GetConversionResult();
485:           //        FVRCON = 0x83;
486:           //        ADC_SelectChannel(channel_AN6);
487:           //        USBDeviceTasks();
488:           //        ADC_StartConversion();        
489:           //    } else {
490:                   Uadc = ((ADRESH << 8) | ADRESL);//ADC_GetConversionResult() - (Iadc>>1);
0009  0021     MOVLB 0x1
000A  081C     MOVF ADRESH, W
000B  0023     MOVLB 0x3
000C  00E6     MOVWF 0x1E6
000D  0021     MOVLB 0x1
000E  081B     MOVF ADRES, W
000F  0023     MOVLB 0x3
0010  00E5     MOVWF Uadc
491:                   //main_CDC_to_RS485_Tasks();
492:                   ADCON0bits.GO_nDONE = 1;//ADC_StartConversion();
0011  0021     MOVLB 0x1
0012  149D     BSF ADCON0, 0x1
493:                   if(Uadc >= Uadc_target) {
0013  0024     MOVLB 0x4
0014  084D     MOVF 0x24D, W
0015  0023     MOVLB 0x3
0016  0266     SUBWF 0x1E6, W
0017  1D03     BTFSS 0x183, 0x2
0018  281D     GOTO 0x1D
0019  0024     MOVLB 0x4
001A  084C     MOVF Uadc_target, W
001B  0023     MOVLB 0x3
001C  0265     SUBWF Uadc, W
001D  1C03     BTFSS 0x183, 0x0
001E  2823     GOTO 0x23
494:                       //PWM2_LoadDutyValue(0);
495:                       // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
496:                       PWM2DCH = 0;
001F  002C     MOVLB 0xC
0020  0195     CLRF PWM2DCH
497:                       // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
498:                       PWM2DCL = 0;
0021  0194     CLRF PWM2DCL
499:                   } else {
0022  283A     GOTO 0x3A
500:                       //PWM2_LoadDutyValue(rampPwmDutyCycleVoltageLimit);
501:                       // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
502:                       PWM2DCH = (rampPwmDutyCycleVoltageLimit & 0x03FC)>>2;
0023  0023     MOVLB 0x3
0024  085E     MOVF rampPwmDutyCycleVoltageLimit, W
0025  00F0     MOVWF 0x1F0
0026  3002     MOVLW 0x2
0027  36F0     LSRF 0x1F0, F
0028  0B89     DECFSZ 0x189, F
0029  2827     GOTO 0x27
002A  0870     MOVF 0x1F0, W
002B  393F     ANDLW 0x3F
002C  002C     MOVLB 0xC
002D  0095     MOVWF PWM2DCH
503:                       // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
504:                       PWM2DCL = (rampPwmDutyCycleVoltageLimit & 0x0003)<<6;
002E  0023     MOVLB 0x3
002F  085E     MOVF rampPwmDutyCycleVoltageLimit, W
0030  3903     ANDLW 0x3
0031  00F0     MOVWF 0x1F0
0032  3005     MOVLW 0x5
0033  35F0     LSLF 0x1F0, F
0034  3EFF     ADDLW 0xFF
0035  1D03     BTFSS 0x183, 0x2
0036  2833     GOTO 0x33
0037  3570     LSLF 0x1F0, W
0038  002C     MOVLB 0xC
0039  0094     MOVWF PWM2DCL
505:                   }
506:           //        i++;
507:           //    }
508:               // Clear the ADC interrupt flag
509:               PIR1bits.ADIF = 0; 
003A  0020     MOVLB 0x0
003B  1311     BCF PIR1, 0x6
510:           //    IO_RC0_SetLow();
511:           }
003C  0871     MOVF 0x71, W
---  C:/Users/Valerii/MPLABXProjects/EasyPowerUSB.X/app_uart_usb_utils.c  -------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            // *****************************************************************************
21:            // *****************************************************************************
22:            // Section: Included Files
23:            // *****************************************************************************
24:            // *****************************************************************************
25:            #include <stdint.h>
26:            #include "mcc_generated_files/mcc.h"
27:            #include "usb_device_cdc.h"
28:            
29:            
30:            // *****************************************************************************
31:            // *****************************************************************************
32:            // Section: File Scope or Global Constants
33:            // *****************************************************************************
34:            // *****************************************************************************
35:            
36:            
37:            // *****************************************************************************
38:            // *****************************************************************************
39:            // Section: File Scope Data Types
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            
43:            
44:            // *****************************************************************************
45:            // *****************************************************************************
46:            // Section: Macros or Functions
47:            // *****************************************************************************
48:            // *****************************************************************************
49:            
50:            /******************************************************************************
51:             * Function:        void USART_putcUSART(char c)
52:             *
53:             * PreCondition:    None
54:             *
55:             * Input:           char c - character to print to the UART
56:             *
57:             * Output:          None
58:             *
59:             * Side Effects:    None
60:             *
61:             * Overview:        Print the input character to the UART
62:             *
63:             * Note:
64:             *
65:             *****************************************************************************/
66:            void USART_putcUSART(char c)
67:            {
68:                  TXREG = c;
69:            }
70:            
71:            
72:            /******************************************************************************
73:             * Function:        void USART_mySetLineCodingHandler(void)
74:             *
75:             * PreCondition:    USB_CDC_SET_LINE_CODING_HANDLER is defined
76:             *
77:             * Input:           None
78:             *
79:             * Output:          None
80:             *
81:             * Side Effects:    None
82:             *
83:             * Overview:        This function gets called when a SetLineCoding command
84:             *                  is sent on the bus.  This function will evaluate the request
85:             *                  and determine if the application should update the baudrate
86:             *                  or not.
87:             *
88:             * Note:
89:             *
90:             *****************************************************************************/
91:            #if defined(USB_CDC_SET_LINE_CODING_HANDLER2)
92:            void USART_mySetLineCodingHandler(void)
93:            {
94:                //If the request is not in a valid range
95:                //if(cdc_notice.GetLineCoding.dwDTERate > 115200)
96:                //{
97:                    //NOTE: There are two ways that an unsupported baud rate could be
98:                    //handled.  The first is just to ignore the request and don't change
99:                    //the values.  That is what is currently implemented in this function.
100:                   //The second possible method is to stall the STATUS stage of the request.
101:                   //STALLing the STATUS stage will cause an exception to be thrown in the
102:                   //requesting application.  Some programs, like HyperTerminal, handle the
103:                   //exception properly and give a pop-up box indicating that the request
104:                   //settings are not valid.  Any application that does not handle the
105:                   //exception correctly will likely crash when this requiest fails.  For
106:                   //the sake of example the code required to STALL the status stage of the
107:                   //request is provided below.  It has been left out so that this demo
108:                   //does not cause applications without the required exception handling
109:                   //to crash.
110:                   //---------------------------------------
111:                   //USBStallEndpoint(0,1);
112:               //}
113:               //else
114:               //{
115:                   //Update the baudrate info in the CDC driver
116:                   CDCSetBaudRate2(cdc_notice2.GetLineCoding.dwDTERate);
1745  0025     MOVLB 0x5
1746  082D     MOVF 0x2AD, W
1747  0024     MOVLB 0x4
1748  00E1     MOVWF 0x261
1749  0025     MOVLB 0x5
174A  082C     MOVF 0x2AC, W
174B  0024     MOVLB 0x4
174C  00E0     MOVWF 0x260
174D  0025     MOVLB 0x5
174E  082B     MOVF 0x2AB, W
174F  0024     MOVLB 0x4
1750  00DF     MOVWF 0x25F
1751  0025     MOVLB 0x5
1752  082A     MOVF cdc_notice2, W
1753  0024     MOVLB 0x4
1754  00DE     MOVWF line_coding2
117:                   //Update the baudrate of the UART
118:                   uint32_t dwBaud;
119:                   dwBaud = ((_XTAL_FREQ/4) / line_coding2.dwDTERate) - 1;
1755  0861     MOVF 0x261, W
1756  0021     MOVLB 0x1
1757  00E7     MOVWF 0xE7
1758  0024     MOVLB 0x4
1759  0860     MOVF 0x260, W
175A  0021     MOVLB 0x1
175B  00E6     MOVWF buffer
175C  0024     MOVLB 0x4
175D  085F     MOVF 0x25F, W
175E  0021     MOVLB 0x1
175F  00E5     MOVWF byte_to_send
1760  0024     MOVLB 0x4
1761  085E     MOVF line_coding2, W
1762  0021     MOVLB 0x1
1763  00E4     MOVWF ep
1764  3000     MOVLW 0x0
1765  00EB     MOVWF str
1766  30B7     MOVLW 0xB7
1767  00EA     MOVWF strIncremet
1768  301B     MOVLW 0x1B
1769  00E9     MOVWF 0xE9
176A  3000     MOVLW 0x0
176B  00E8     MOVWF dividend
176C  3188     MOVLP 0x8
176D  2070     CALL 0x70
176E  3197     MOVLP 0x17
176F  30FF     MOVLW 0xFF
1770  0021     MOVLB 0x1
1771  0764     ADDWF ep, W
1772  0022     MOVLB 0x2
1773  00E9     MOVWF dwBaud
1774  30FF     MOVLW 0xFF
1775  0021     MOVLB 0x1
1776  3D65     ADDWFC byte_to_send, W
1777  0022     MOVLB 0x2
1778  00EA     MOVWF 0x16A
1779  30FF     MOVLW 0xFF
177A  0021     MOVLB 0x1
177B  3D66     ADDWFC buffer, W
177C  0022     MOVLB 0x2
177D  00EB     MOVWF 0x16B
177E  30FF     MOVLW 0xFF
177F  0021     MOVLB 0x1
1780  3D67     ADDWFC 0xE7, W
1781  0022     MOVLB 0x2
1782  00EC     MOVWF 0x16C
120:                   SPBRG = (uint8_t) dwBaud;
1783  0869     MOVF dwBaud, W
1784  00E5     MOVWF 0x165
1785  01E6     CLRF Uout_mV
1786  0865     MOVF 0x165, W
1787  0023     MOVLB 0x3
1788  009B     MOVWF SPBRG
1789  0022     MOVLB 0x2
178A  0866     MOVF Uout_mV, W
178B  0023     MOVLB 0x3
178C  009C     MOVWF SPBRGH
121:                   SPBRGH = (uint8_t)((uint16_t) (dwBaud >> 8));
178D  0022     MOVLB 0x2
178E  0869     MOVF dwBaud, W
178F  00E5     MOVWF 0x165
1790  086A     MOVF 0x16A, W
1791  00E6     MOVWF Uout_mV
1792  086B     MOVF 0x16B, W
1793  00E7     MOVWF 0x167
1794  086C     MOVF 0x16C, W
1795  00E8     MOVWF 0x168
1796  3008     MOVLW 0x8
1797  36E8     LSRF 0x168, F
1798  0CE7     RRF 0x167, F
1799  0CE6     RRF Uout_mV, F
179A  0CE5     RRF 0x165, F
179B  0B89     DECFSZ 0x109, F
179C  2F97     GOTO 0x797
179D  0865     MOVF 0x165, W
179E  0023     MOVLB 0x3
179F  009C     MOVWF SPBRGH
122:               //}
123:           }
17A0  0008     RETURN
124:           #endif
125:           
126:           /******************************************************************************
127:            * Function:        void USART_getcUSART(char c)
128:            *
129:            * PreCondition:    None
130:            *
131:            * Input:           None
132:            *
133:            * Output:          unsigned char c - character to received on the UART
134:            *
135:            * Side Effects:    None
136:            *
137:            * Overview:        Print the input character to the UART
138:            *
139:            * Note:
140:            *
141:            *****************************************************************************/
142:           unsigned char USART_getcUSART ()
143:           {
144:           	char  c;
145:           
146:           	if (RCSTAbits.OERR)  // in case of overrun error
147:           	{                    // we should never see an overrun error, but if we do,
148:           		RCSTAbits.CREN = 0;  // reset the port
149:           		c = RCREG;
150:           		RCSTAbits.CREN = 1;  // and keep going.
151:           	}
152:           	else
153:               {
154:           		c = RCREG;
155:               }
156:           // not necessary.  EUSART auto clears the flag when RCREG is cleared
157:           //	PIR1bits.RCIF = 0;    // clear Flag
158:           
159:             
160:           	return c;
161:           }
162:           
163:           /*******************************************************************************
164:            End of File
165:           */
---  C:/Program Files (x86)/Microchip/xc8/v1.40/sources/common/memset.c  --------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far void *
5:             memset(far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
1270  0873     MOVF 0x1F3, W
1271  00F9     MOVWF 0x1F9
1272  0872     MOVF 0x1F2, W
1273  00F8     MOVWF 0x1F8
19:            	while(n--)
1274  3001     MOVLW 0x1
1275  02F6     SUBWF 0x1F6, F
1276  3000     MOVLW 0x0
1277  3BF7     SUBWFB 0x1F7, F
1278  0A76     INCF 0x1F6, W
1279  1903     BTFSC 0x183, 0x2
127A  0A77     INCF 0x1F7, W
127B  1903     BTFSC 0x183, 0x2
127C  0008     RETURN
1287  2A74     GOTO 0x274
20:            		*p++ = c;
127D  0878     MOVF 0x1F8, W
127E  0086     MOVWF 0x186
127F  0879     MOVF 0x1F9, W
1280  0087     MOVWF 0x187
1281  0874     MOVF 0x1F4, W
1282  0081     MOVWF 0x181
1283  3001     MOVLW 0x1
1284  07F8     ADDWF 0x1F8, F
1285  3000     MOVLW 0x0
1286  3DF9     ADDWFC 0x1F9, F
21:            	return p1;
22:            }
---  C:/Program Files (x86)/Microchip/xc8/v1.40/sources/common/lldiv.c  ---------------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lldiv(unsigned long int divisor, unsigned long int dividend)
7:             #else
8:             __lldiv(unsigned long int dividend, unsigned long int divisor)
9:             #endif
10:            {
11:            	unsigned long int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0870  3000     MOVLW 0x0
0871  0022     MOVLB 0x2
0872  00E3     MOVWF i
0873  3000     MOVLW 0x0
0874  00E2     MOVWF i
0875  3000     MOVLW 0x0
0876  00E1     MOVWF sign
0877  3000     MOVLW 0x0
0878  00E0     MOVWF __pcstackBANK2
15:            	if(divisor != 0) {
0879  0021     MOVLB 0x1
087A  0867     MOVF 0xE7, W
087B  0466     IORWF buffer, W
087C  0465     IORWF byte_to_send, W
087D  0464     IORWF ep, W
087E  1903     BTFSC 0x83, 0x2
087F  28C4     GOTO 0xC4
16:            		counter = 1;
0880  0022     MOVLB 0x2
0881  01E4     CLRF counter
0882  0AE4     INCF counter, F
17:            		while((divisor & 0x80000000UL) == 0) {
0883  0021     MOVLB 0x1
0884  1BE7     BTFSC 0xE7, 0x7
0885  2894     GOTO 0x94
0893  2883     GOTO 0x83
18:            			divisor <<= 1;
0886  3001     MOVLW 0x1
0887  0021     MOVLB 0x1
0888  35E4     LSLF ep, F
0889  0DE5     RLF byte_to_send, F
088A  0DE6     RLF buffer, F
088B  0DE7     RLF 0xE7, F
088C  0B89     DECFSZ 0x89, F
088D  2887     GOTO 0x87
19:            			counter++;
088E  3001     MOVLW 0x1
088F  00EC     MOVWF powerOfTen
0890  086C     MOVF powerOfTen, W
0891  0022     MOVLB 0x2
0892  07E4     ADDWF counter, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
0894  3001     MOVLW 0x1
0895  0022     MOVLB 0x2
0896  35E0     LSLF __pcstackBANK2, F
0897  0DE1     RLF sign, F
0898  0DE2     RLF i, F
0899  0DE3     RLF i, F
089A  0B89     DECFSZ 0x109, F
089B  2895     GOTO 0x95
23:            			if(divisor <= dividend) {
089C  0021     MOVLB 0x1
089D  0867     MOVF 0xE7, W
089E  026B     SUBWF str, W
089F  1D03     BTFSS 0x83, 0x2
08A0  28AB     GOTO 0xAB
08A1  0866     MOVF buffer, W
08A2  026A     SUBWF strIncremet, W
08A3  1D03     BTFSS 0x83, 0x2
08A4  28AB     GOTO 0xAB
08A5  0865     MOVF byte_to_send, W
08A6  0269     SUBWF 0xE9, W
08A7  1D03     BTFSS 0x83, 0x2
08A8  28AB     GOTO 0xAB
08A9  0864     MOVF ep, W
08AA  0268     SUBWF dividend, W
08AB  1C03     BTFSS 0x83, 0x0
08AC  28B7     GOTO 0xB7
24:            				dividend -= divisor;
08AD  0864     MOVF ep, W
08AE  02E8     SUBWF dividend, F
08AF  0865     MOVF byte_to_send, W
08B0  3BE9     SUBWFB 0xE9, F
08B1  0866     MOVF buffer, W
08B2  3BEA     SUBWFB strIncremet, F
08B3  0867     MOVF 0xE7, W
08B4  3BEB     SUBWFB str, F
25:            				quotient |= 1;
08B5  0022     MOVLB 0x2
08B6  1460     BSF __pcstackBANK2, 0x0
26:            			}
27:            			divisor >>= 1;
08B7  3001     MOVLW 0x1
08B8  0021     MOVLB 0x1
08B9  36E7     LSRF 0xE7, F
08BA  0CE6     RRF buffer, F
08BB  0CE5     RRF byte_to_send, F
08BC  0CE4     RRF ep, F
08BD  0B89     DECFSZ 0x89, F
08BE  28B8     GOTO 0xB8
28:            		} while(--counter != 0);
08BF  3001     MOVLW 0x1
08C0  0022     MOVLB 0x2
08C1  02E4     SUBWF counter, F
08C2  1D03     BTFSS 0x103, 0x2
08C3  2894     GOTO 0x94
29:            	}
30:            	return quotient;
08C4  0022     MOVLB 0x2
31:            }
---  C:/Program Files (x86)/Microchip/xc8/v1.40/sources/common/isdigit.c  -------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
120E  00F3     MOVWF 0x173
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
120F  01F2     CLRF 0x172
15:            }
16:            
17:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.40/sources/common/atoi.c  ----------------------------------
1:             #include	<ctype.h>
2:             #include	<stdlib.h>
3:             
4:             int
5:             atoi(register const char * s)
09A7  0021     MOVLB 0x1
09A8  00E5     MOVWF byte_to_send
6:             {
7:             	register int	a;
8:             	register unsigned char	sign;
9:             
10:            	while(*s == ' ' || *s == '\t')
09A9  0865     MOVF byte_to_send, W
09AA  0086     MOVWF 0x86
09AB  3003     MOVLW 0x3
09AC  0087     MOVWF 0x87
09AD  3020     MOVLW 0x20
09AE  0601     XORWF 0x81, W
09AF  1D03     BTFSS 0x83, 0x2
09B0  29B6     GOTO 0x1B6
09B5  29A9     GOTO 0x1A9
09B6  0865     MOVF byte_to_send, W
09B7  0086     MOVWF 0x86
09B8  3003     MOVLW 0x3
09B9  0087     MOVWF 0x87
09BA  3009     MOVLW 0x9
09BB  0601     XORWF 0x81, W
09BC  1903     BTFSC 0x83, 0x2
09BD  29B1     GOTO 0x1B1
11:            		s++;
09B1  3001     MOVLW 0x1
09B2  00E0     MOVWF __pcstackBANK1
09B3  0860     MOVF __pcstackBANK1, W
09B4  07E5     ADDWF byte_to_send, F
12:            	a = 0;
09BE  01E3     CLRF len
09BF  01E4     CLRF ep
13:            	sign = 0;
09C0  01E2     CLRF p
14:            	if(*s == '-') {
09C1  0865     MOVF byte_to_send, W
09C2  0086     MOVWF 0x86
09C3  3003     MOVLW 0x3
09C4  0087     MOVWF 0x87
09C5  302D     MOVLW 0x2D
09C6  0601     XORWF 0x81, W
09C7  1D03     BTFSS 0x83, 0x2
09C8  29CE     GOTO 0x1CE
15:            		sign++;
09C9  3001     MOVLW 0x1
09CA  00E0     MOVWF __pcstackBANK1
09CB  0860     MOVF __pcstackBANK1, W
09CC  07E2     ADDWF p, F
09CD  29D6     GOTO 0x1D6
16:            		s++;
17:            	} else if(*s == '+')
09CE  0865     MOVF byte_to_send, W
09CF  0086     MOVWF 0x86
09D0  3003     MOVLW 0x3
09D1  0087     MOVWF 0x87
09D2  302B     MOVLW 0x2B
09D3  0601     XORWF 0x81, W
09D4  1D03     BTFSS 0x83, 0x2
09D5  29DA     GOTO 0x1DA
18:            		s++;
19:            	while(isdigit(*s))
09DA  0865     MOVF byte_to_send, W
09DB  0086     MOVWF 0x86
09DC  3003     MOVLW 0x3
09DD  0087     MOVWF 0x87
09DE  0801     MOVF 0x81, W
09DF  3192     MOVLP 0x12
09E0  220E     CALL 0x20E
09E1  3189     MOVLP 0x9
09E2  1C03     BTFSS 0x83, 0x0
09E3  2A03     GOTO 0x203
0A02  29D6     GOTO 0x1D6
20:            		a = a*10 + (*s++ - '0');
09D6  3001     MOVLW 0x1
09D7  00E0     MOVWF __pcstackBANK1
09D8  0860     MOVF __pcstackBANK1, W
09D9  07E5     ADDWF byte_to_send, F
09E4  0021     MOVLB 0x1
09E5  0864     MOVF ep, W
09E6  00F3     MOVWF 0xF3
09E7  0863     MOVF len, W
09E8  00F2     MOVWF 0xF2
09E9  300A     MOVLW 0xA
09EA  00F4     MOVWF 0xF4
09EB  3000     MOVLW 0x0
09EC  00F5     MOVWF 0xF5
09ED  3192     MOVLP 0x12
09EE  22BC     CALL 0x2BC
09EF  3189     MOVLP 0x9
09F0  0021     MOVLB 0x1
09F1  0865     MOVF byte_to_send, W
09F2  0086     MOVWF 0x86
09F3  3003     MOVLW 0x3
09F4  0087     MOVWF 0x87
09F5  0801     MOVF 0x81, W
09F6  0772     ADDWF 0xF2, W
09F7  00E0     MOVWF __pcstackBANK1
09F8  0873     MOVF 0xF3, W
09F9  1803     BTFSC 0x83, 0x0
09FA  0A73     INCF 0xF3, W
09FB  00E1     MOVWF handle
09FC  0860     MOVF __pcstackBANK1, W
09FD  3ED0     ADDLW 0xD0
09FE  00E3     MOVWF len
09FF  30FF     MOVLW 0xFF
0A00  3D61     ADDWFC handle, W
0A01  00E4     MOVWF ep
21:            	if(sign)
0A03  0021     MOVLB 0x1
0A04  0862     MOVF p, W
0A05  1903     BTFSC 0x83, 0x2
0A06  2A13     GOTO 0x213
22:            		return -a;
0A07  0963     COMF len, W
0A08  00E0     MOVWF __pcstackBANK1
0A09  0964     COMF ep, W
0A0A  00E1     MOVWF handle
0A0B  0AE0     INCF __pcstackBANK1, F
0A0C  1903     BTFSC 0x83, 0x2
0A0D  0AE1     INCF handle, F
0A0E  0860     MOVF __pcstackBANK1, W
0A0F  00F8     MOVWF 0xF8
0A10  0861     MOVF handle, W
0A11  00F9     MOVWF 0xF9
0A12  0008     RETURN
23:            	return a;
0A13  0864     MOVF ep, W
24:            }
---  C:/Program Files (x86)/Microchip/xc8/v1.40/sources/common/aldiv.c  ---------------------------------
1:             // long signed unsigned division
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __aldiv(signed long int divisor, signed long int dividend)
7:             #else
8:             __aldiv(signed long int dividend, signed long int divisor)
9:             #endif
10:            {
11:            	signed long int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0760  0022     MOVLB 0x2
0761  01E1     CLRF sign
15:            	if(divisor < 0) {
0762  0021     MOVLB 0x1
0763  1FE7     BTFSS 0xE7, 0x7
0764  2F73     GOTO 0x773
16:            		divisor = -divisor;
0765  09E4     COMF ep, F
0766  09E5     COMF byte_to_send, F
0767  09E6     COMF buffer, F
0768  09E7     COMF 0xE7, F
0769  0AE4     INCF ep, F
076A  1903     BTFSC 0x83, 0x2
076B  0AE5     INCF byte_to_send, F
076C  1903     BTFSC 0x83, 0x2
076D  0AE6     INCF buffer, F
076E  1903     BTFSC 0x83, 0x2
076F  0AE7     INCF 0xE7, F
17:            		sign = 1;
0770  0022     MOVLB 0x2
0771  01E1     CLRF sign
0772  0AE1     INCF sign, F
18:            	}
19:            	if(dividend < 0) {
0773  0021     MOVLB 0x1
0774  1FEB     BTFSS str, 0x7
0775  2F86     GOTO 0x786
20:            		dividend = -dividend;
0776  09E8     COMF dividend, F
0777  09E9     COMF 0xE9, F
0778  09EA     COMF strIncremet, F
0779  09EB     COMF str, F
077A  0AE8     INCF dividend, F
077B  1903     BTFSC 0x83, 0x2
077C  0AE9     INCF 0xE9, F
077D  1903     BTFSC 0x83, 0x2
077E  0AEA     INCF strIncremet, F
077F  1903     BTFSC 0x83, 0x2
0780  0AEB     INCF str, F
21:            		sign ^= 1;
0781  3001     MOVLW 0x1
0782  00EC     MOVWF powerOfTen
0783  086C     MOVF powerOfTen, W
0784  0022     MOVLB 0x2
0785  06E1     XORWF sign, F
22:            	}
23:            	quotient = 0;
0786  3000     MOVLW 0x0
0787  0022     MOVLB 0x2
0788  00E5     MOVWF 0x165
0789  3000     MOVLW 0x0
078A  00E4     MOVWF counter
078B  3000     MOVLW 0x0
078C  00E3     MOVWF i
078D  3000     MOVLW 0x0
078E  00E2     MOVWF i
24:            	if(divisor != 0) {
078F  0021     MOVLB 0x1
0790  0867     MOVF 0xE7, W
0791  0466     IORWF buffer, W
0792  0465     IORWF byte_to_send, W
0793  0464     IORWF ep, W
0794  1903     BTFSC 0x83, 0x2
0795  2FDA     GOTO 0x7DA
25:            		counter = 1;
0796  0022     MOVLB 0x2
0797  01E0     CLRF __pcstackBANK2
0798  0AE0     INCF __pcstackBANK2, F
26:            		while((divisor & 0x80000000UL) == 0) {
0799  0021     MOVLB 0x1
079A  1BE7     BTFSC 0xE7, 0x7
079B  2FAA     GOTO 0x7AA
07A9  2F99     GOTO 0x799
27:            			divisor <<= 1;
079C  3001     MOVLW 0x1
079D  0021     MOVLB 0x1
079E  35E4     LSLF ep, F
079F  0DE5     RLF byte_to_send, F
07A0  0DE6     RLF buffer, F
07A1  0DE7     RLF 0xE7, F
07A2  0B89     DECFSZ 0x89, F
07A3  2F9D     GOTO 0x79D
28:            			counter++;
07A4  3001     MOVLW 0x1
07A5  00EC     MOVWF powerOfTen
07A6  086C     MOVF powerOfTen, W
07A7  0022     MOVLB 0x2
07A8  07E0     ADDWF __pcstackBANK2, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
07AA  3001     MOVLW 0x1
07AB  0022     MOVLB 0x2
07AC  35E2     LSLF i, F
07AD  0DE3     RLF i, F
07AE  0DE4     RLF counter, F
07AF  0DE5     RLF 0x165, F
07B0  0B89     DECFSZ 0x109, F
07B1  2FAB     GOTO 0x7AB
32:            			if((unsigned long)divisor <= (unsigned long)dividend) {
07B2  0021     MOVLB 0x1
07B3  0867     MOVF 0xE7, W
07B4  026B     SUBWF str, W
07B5  1D03     BTFSS 0x83, 0x2
07B6  2FC1     GOTO 0x7C1
07B7  0866     MOVF buffer, W
07B8  026A     SUBWF strIncremet, W
07B9  1D03     BTFSS 0x83, 0x2
07BA  2FC1     GOTO 0x7C1
07BB  0865     MOVF byte_to_send, W
07BC  0269     SUBWF 0xE9, W
07BD  1D03     BTFSS 0x83, 0x2
07BE  2FC1     GOTO 0x7C1
07BF  0864     MOVF ep, W
07C0  0268     SUBWF dividend, W
07C1  1C03     BTFSS 0x83, 0x0
07C2  2FCD     GOTO 0x7CD
33:            				dividend -= divisor;
07C3  0864     MOVF ep, W
07C4  02E8     SUBWF dividend, F
07C5  0865     MOVF byte_to_send, W
07C6  3BE9     SUBWFB 0xE9, F
07C7  0866     MOVF buffer, W
07C8  3BEA     SUBWFB strIncremet, F
07C9  0867     MOVF 0xE7, W
07CA  3BEB     SUBWFB str, F
34:            				quotient |= 1;
07CB  0022     MOVLB 0x2
07CC  1462     BSF i, 0x0
35:            			}
36:            			*(unsigned long int *)&divisor >>= 1;
07CD  3001     MOVLW 0x1
07CE  0021     MOVLB 0x1
07CF  36E7     LSRF 0xE7, F
07D0  0CE6     RRF buffer, F
07D1  0CE5     RRF byte_to_send, F
07D2  0CE4     RRF ep, F
07D3  0B89     DECFSZ 0x89, F
07D4  2FCE     GOTO 0x7CE
37:            		} while(--counter != 0);
07D5  3001     MOVLW 0x1
07D6  0022     MOVLB 0x2
07D7  02E0     SUBWF __pcstackBANK2, F
07D8  1D03     BTFSS 0x103, 0x2
07D9  2FAA     GOTO 0x7AA
38:            	}
39:            	if(sign)
07DA  0022     MOVLB 0x2
07DB  0861     MOVF sign, W
07DC  1903     BTFSC 0x103, 0x2
07DD  2FE9     GOTO 0x7E9
40:            		quotient = -quotient;
07DE  09E2     COMF i, F
07DF  09E3     COMF i, F
07E0  09E4     COMF counter, F
07E1  09E5     COMF 0x165, F
07E2  0AE2     INCF i, F
07E3  1903     BTFSC 0x103, 0x2
07E4  0AE3     INCF i, F
07E5  1903     BTFSC 0x103, 0x2
07E6  0AE4     INCF counter, F
07E7  1903     BTFSC 0x103, 0x2
07E8  0AE5     INCF 0x165, F
41:            	return quotient;
07E9  0865     MOVF 0x165, W
42:            }
---  C:/Program Files (x86)/Microchip/xc8/v1.40/sources/common/Umul32.c  --------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
13A5  3000     MOVLW 0x0
13A6  0021     MOVLB 0x1
13A7  00E3     MOVWF len
13A8  3000     MOVLW 0x0
13A9  00E2     MOVWF p
13AA  3000     MOVLW 0x0
13AB  00E1     MOVWF handle
13AC  3000     MOVLW 0x0
13AD  00E0     MOVWF __pcstackBANK1
120:           	do {
121:           		if(multiplier & 1)
13AE  1C72     BTFSS 0xF2, 0x0
13AF  2BB9     GOTO 0x3B9
122:           			product += multiplicand;
13B0  0876     MOVF 0xF6, W
13B1  0021     MOVLB 0x1
13B2  07E0     ADDWF __pcstackBANK1, F
13B3  0877     MOVF 0xF7, W
13B4  3DE1     ADDWFC handle, F
13B5  0878     MOVF 0xF8, W
13B6  3DE2     ADDWFC p, F
13B7  0879     MOVF 0xF9, W
13B8  3DE3     ADDWFC len, F
123:           		multiplicand <<= 1;
13B9  3001     MOVLW 0x1
13BA  35F6     LSLF 0xF6, F
13BB  0DF7     RLF 0xF7, F
13BC  0DF8     RLF 0xF8, F
13BD  0DF9     RLF 0xF9, F
13BE  0B89     DECFSZ 0x89, F
13BF  2BBA     GOTO 0x3BA
124:           		multiplier >>= 1;
13C0  3001     MOVLW 0x1
13C1  36F5     LSRF 0xF5, F
13C2  0CF4     RRF 0xF4, F
13C3  0CF3     RRF 0xF3, F
13C4  0CF2     RRF 0xF2, F
13C5  0B89     DECFSZ 0x89, F
13C6  2BC1     GOTO 0x3C1
125:           	} while(multiplier != 0);
13C7  0875     MOVF 0xF5, W
13C8  0474     IORWF 0xF4, W
13C9  0473     IORWF 0xF3, W
13CA  0472     IORWF 0xF2, W
13CB  1D03     BTFSS 0x83, 0x2
13CC  2BAE     GOTO 0x3AE
126:           
127:           #endif
128:           	return product;
13CD  0021     MOVLB 0x1
129:           }
---  C:/Program Files (x86)/Microchip/xc8/v1.40/sources/common/Umul16.c  --------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
12BC  01F6     CLRF 0xF6
12BD  01F7     CLRF 0xF7
44:            	do {
45:            		if(multiplier & 1)
12BE  1C72     BTFSS 0xF2, 0x0
12BF  2AC4     GOTO 0x2C4
46:            			product += multiplicand;
12C0  0874     MOVF 0xF4, W
12C1  07F6     ADDWF 0xF6, F
12C2  0875     MOVF 0xF5, W
12C3  3DF7     ADDWFC 0xF7, F
47:            		multiplicand <<= 1;
12C4  3001     MOVLW 0x1
12C5  35F4     LSLF 0xF4, F
12C6  0DF5     RLF 0xF5, F
12C7  0B89     DECFSZ 0x89, F
12C8  2AC5     GOTO 0x2C5
48:            		multiplier >>= 1;
12C9  3001     MOVLW 0x1
12CA  36F3     LSRF 0xF3, F
12CB  0CF2     RRF 0xF2, F
12CC  0B89     DECFSZ 0x89, F
12CD  2ACA     GOTO 0x2CA
49:            	} while(multiplier != 0);
12CE  0872     MOVF 0xF2, W
12CF  0473     IORWF 0xF3, W
12D0  1D03     BTFSS 0x83, 0x2
12D1  2ABE     GOTO 0x2BE
50:            
51:            #endif
52:                    return product;
12D2  0877     MOVF 0xF7, W
53:            }
